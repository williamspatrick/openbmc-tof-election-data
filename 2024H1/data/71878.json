{
    "project": "openbmc/phosphor-dbus-interfaces",
    "branch": "master",
    "id": "I09aedcb3cac2c69126a398e40d5e7e7827519e40",
    "number": 71878,
    "subject": "Add xyz.openbmc_project.Console.Control interface",
    "owner": {
        "name": "Alexander",
        "email": "alexander.hansen@9elements.com",
        "username": "pointbazaar"
    },
    "url": "https://gerrit.openbmc.org/c/openbmc/phosphor-dbus-interfaces/+/71878",
    "hashtags": [],
    "createdOn": 1717756315,
    "lastUpdated": 1718870128,
    "open": false,
    "status": "ABANDONED",
    "comments": [
        {
            "timestamp": 1717756315,
            "reviewer": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "message": "Uploaded patch set 1."
        },
        {
            "timestamp": 1717756338,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1717756338,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: -Ok-To-Test"
        },
        {
            "timestamp": 1717756686,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: Verified-1\n\nBuild Failed \n\nhttps://jenkins.openbmc.org/job/ci-repository/85633/ : FAILURE"
        },
        {
            "timestamp": 1717760974,
            "reviewer": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "message": "Uploaded patch set 2.\n\nOutdated Votes:\n* Verified-1 (copy condition: \"changekind:NO_CHANGE\")\n"
        },
        {
            "timestamp": 1717760999,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1717760999,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: -Ok-To-Test"
        },
        {
            "timestamp": 1717761335,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/85637/ : SUCCESS"
        },
        {
            "timestamp": 1718056606,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 2:\n\n(2 comments)"
        },
        {
            "timestamp": 1718070546,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@codeconstruct.com.au",
                "username": "amboar"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1718099660,
            "reviewer": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "message": "Uploaded patch set 3.\n\nOutdated Votes:\n* Verified+1 (copy condition: \"changekind:NO_CHANGE\")\n"
        },
        {
            "timestamp": 1718099691,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1718099691,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: -Ok-To-Test"
        },
        {
            "timestamp": 1718100029,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/85862/ : SUCCESS"
        },
        {
            "timestamp": 1718100215,
            "reviewer": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "message": "Patch Set 3:\n\n(2 comments)"
        },
        {
            "timestamp": 1718157702,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@codeconstruct.com.au",
                "username": "amboar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1718182129,
            "reviewer": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1718333405,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@codeconstruct.com.au",
                "username": "amboar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1718367749,
            "reviewer": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1718603512,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@codeconstruct.com.au",
                "username": "amboar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1718643912,
            "reviewer": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1718674308,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@codeconstruct.com.au",
                "username": "amboar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1718870128,
            "reviewer": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "message": "Abandoned\n\nsince there is now consensus on connection-based mux control"
        }
    ],
    "patchSets": [
        {
            "number": 1,
            "revision": "a1e1d4bdedcbc301b56535c12fb0061d4fc196bb",
            "parents": [
                "9b664e95f79a66b515e360bf3cdce13e42d818ef"
            ],
            "ref": "refs/changes/78/71878/1",
            "uploader": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "createdOn": 1717756315,
            "author": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 20,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "type": "ADDED",
                    "insertions": 21,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 41,
            "sizeDeletions": 0
        },
        {
            "number": 2,
            "revision": "5b83dafa3af98ae5254def306010a745205a3234",
            "parents": [
                "9b664e95f79a66b515e360bf3cdce13e42d818ef"
            ],
            "ref": "refs/changes/78/71878/2",
            "uploader": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "createdOn": 1717760974,
            "author": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "It seems like you're going to add this object onto all of the \"Access\" objects, when switching is allowed?  Or are you always going to have it?  How are you able to determine which set of UARTs are switched with each other (which seems like valuable information).\n\nWould it be useful to have a top-level Console.Manager object, which has an Active property holding an object_path to the active console (of the consoles managed by that manager process)?"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@codeconstruct.com.au",
                        "username": "amboar"
                    },
                    "message": "Using \"Control\" in the interface name seems a bit abstract to me and a bit unconstrained. The functionality we're caring about is supporting muxed consoles. I feel it would be in improvement to constrain the interface to the problem and name it accordingly. Perhaps something with `.Mux` in it, and have it live on a \"manager\" object?"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Alexander",
                        "email": "alexander.hansen@9elements.com",
                        "username": "pointbazaar"
                    },
                    "message": "The plan was to have this interface present on every console, independent of the presence of a mux.\n\nThat way there does not have to be a check in other projects that want to use this interface to interact with the console. They can simply assume it to always be there.\n\nFor the information about which UARTs are switched with each other, that was exposed in my previous implementation as \"ConflictingConsoleIds\" property. But that implementation was discarded in favor of a single-process solution.\n\nFor the \"Console.Manager\" or similar object, that could be interesting for other software to discover the active console. Using objectmapper to find all the 'Active' properties would work aswell.\n\nI would not want to expose much more information than needed by obmc-console-ctl initially. We can always add more objects, paths and properties later on.\n\n\nFor the 'xyz.openbmc_project.Console.Control' name, i chose it intentionally to not refer to a mux. I wanted it to be abstract enough to not expose that implementation detail to other sw. \n\nThe console could be \"inactive\" due to any number of reasons or states that may be implemented in obmc-console in the future, or it could fail to \"Activate()\" due to these same reasons. The other sw does not need to know the internal reason and could probably not do much about it if it had that information."
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@codeconstruct.com.au",
                        "username": "amboar"
                    },
                    "message": "> That way there does not have to be a check in other projects that want to use this interface to interact with the console. They can simply assume it to always be there.\n\nIMO it's self-evident that a console that does not have an interposing mux is active. I think presence of the interface adds some unnecessary confusion in the less complex setups.\n\nThe assumption that the interface is always present might sound like it simplifies things, but I'm not sure that has much impact. You'll still have to handle errors coming back, and invoking a method on an interface that doesn't exist just another type of error. I don't think that argument is overly reductive?\n\nBroadly, the presence of an interface presents the existence of a capability. For instance we already [conditionally expose](https://github.com/openbmc/obmc-console/blob/master/console-dbus.c#L189-L199) the [UART interface](https://github.com/openbmc/phosphor-dbus-interfaces/blob/master/yaml/xyz/openbmc_project/Console/UART.interface.yaml), as it's not meaningful to set a baud rate on a VUART. If setting the active console isn't meaningful because there's only one option, then it's not really the case that there's a capability to switch.\n\n> For the 'xyz.openbmc_project.Console.Control' name, i chose it intentionally to not refer to a mux. I wanted it to be abstract enough to not expose that implementation detail to other sw.\n>\n> The console could be \"inactive\" due to any number of reasons or states that may be implemented in obmc-console in the future, or it could fail to \"Activate()\" due to these same reasons.\n\nOkay, so considering the future is important. Also important is having the restraint not to implement abstractions that we don't immediately need so long as we don't inhibit future development. I'm not saying that the abstraction is unquestionably unnecessary, just I'm not convinced it's necessary **yet**.\n\nIn the spirit of considering the future, can you enumerate your reasons why the console could be \"inactive\" in support of the `Active` concept and the more abstract `Control` interface?\n\nWhat I'm trying to explore is whether any of them cause a more specific (straw-person) `Mux` interface on some kind of manager object to inhibit the abstraction to a `Control` interface (on a console object) down the track."
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Alexander",
                        "email": "alexander.hansen@9elements.com",
                        "username": "pointbazaar"
                    },
                    "message": "The 'Mux' interface on some manager object just exposes implementation details already by it's name.\nThen we would need to think about some method of how to switch that mux which could take console id as an argument to switch to that Console.\n\nSince the console id is already part of the bus name, i would assume the manager object needs it's own bus name. Something like\n\nxyz.openbmc_project.Console.Manager\n\nBut then that is not possible with multiple console servers which each have their own mux.\n\nOne could suggest doing something related to the name of the tty device, like\n\nxyz.openbmc_project.Console.TTYS1Manager\n  /xyz/openbmc_project/console/manager\n     xyz.openbmc_project.Console.Mux\n        method   Select(console_id)\n        property Selected (string)\n\nThis is somewhat inconvenient to use since the name of the tty device is exposed, which is configuration detail, and instead of having to just know the name of the console id, the user now also has to know the name of the tty device to use this concept. However this could be made to work, let me know if you prefer.\n\nIn the case of not having a separate dbus name, the Manager needs to be at the path or interface level for each console.\n\nxyz.openbmc_project.Console.console1\n  /xyz/openbmc_project/console/console1\n  /xyz/openbmc_project/console/Manager\n      xyz.openbmc_project.Console.Mux\n\nIn that case this 'Manager' with it's 'Mux' interface, independent of it's object path, is already doing what the 'xyz.openbmc_project.Console.Control' interface was doing, just with another name.\n\n\nI can think of a few reasons why having the 'Active' property might be beneficial.\nIn case of a board with multiple UARTs connected to the BMC, this can help bmcweb SOL select which one to show. \n\nLet's make an example with CPLD, PCH or BIC.\nWhen the host boots, there may be another controller which is printing on it's UART and it may be interesting to show the output. That UART is 'Active' while the host UART is 'Inactive' at this point. Then later the host uart becomes 'Active' since it's UART controller has only recently been powered.\n\nIn some cases the 'Active' state could be detected by e.g. powergood or other gpio.\n\nSo we know that there is multiple states for a console\n- uart controller not powered -> console inactive\n- uart controller powered but uart is disconnected by other chip\n  (someone told me there is atleast 1 such board) -> console inactive\n- uart controller powered, connected -> console active\n\nThen there could be other cases in which there is a mux and several uarts behind it and some of them may be available to be activated, since we know the devices they are connected to are powered (via gpio or other info). In that case there could be 'Available' property to indicate that an 'Activate' call could succeed.\nBut that's out of scope for this change anyways since this is just about a mux.\n\nWhat i'm trying to demonstrate is that 'Active' can have uses beyond mux. 'Activate()' can also be used in the future for other things, taking steps needed to try and connect that console, if that's switching a mux or setting some gpio value for another device or whatever.\n\n\n\nI just care about a working dbus interface that can accomplish what i need (switch the mux to some console id).\n\nSo since you have the better idea, please paste the interface and how it should look like, with detailed info on \n\n- dbus name\n - object path\n  - interface name\n   - properties\n   - methods\n\nand if it should be conditionally exposed.\n\nThen i can create the new revision and update the documentation + implementation on the obmc-console patches."
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@codeconstruct.com.au",
                        "username": "amboar"
                    },
                    "message": "Sorry, this is a wall of text, but I feel like I need to work from first principles to clarify my thoughts.\n\n> So since you have the better idea\n\nLet me first say that my intent is for a discussion where we reach consensus on a reasonable approach. I'm not trying to have better ideas than anyone else, much less assert mine are better. I'm trying to consider alternatives and balance trade-offs.\n\nMy starting points are:\n\n1. We already have support for concurrent console server instances\n2. Concurrent console support is implemented as one obmc-console-server process per Linux TTY device\n3. As each Linux TTY device is paired with its obmc-console-server process, each obmc-console-server DBus connection needs a unique name\n4. We use the unique `console-id`s to name global resources, including both the DBus connection and the instance's unix domain socket.\n5. Currently, each obmc-console-server instance exposes one console via its associated Linux TTY device\n\nThe first impact of muxed consoles is at the final point. Disregarding muxes briefly and restating point 5 above, the current implementation of obmc-console has a `1:1:1` relationship over the `(console, obmc-console-server, TTY)` pieces of the system.\n\nIMO handling muxes needs us to pick between two design points with the following relationships:\n\n1. One obmc-console-server process exposes one muxed console: `N:N:1`\n2. One obmc-console-server process exposes many muxed consoles: `N:1:1`\n\nThe approach you initially proposed is design point 1. In the reviews I've been suggesting we also consider design point 2.\n\nMy concern with design point 1 is that it requires a bunch of coordination across multiple processes for resources that don't handle multiple access very gracefully (primarily GPIOs and TTYs).\n\nBy contrast, design point 2 handles the GPIOs and the TTY in a single process (while exposing multiple consoles), which by definition requires no inter-process coordination for these resources. I think that lifts some concern.\n\nHowever, that leads us to the current ABI of obmc-console-server:\n\n- Each console has a unique DBus connection name, derived from the `console-id`.\n- Each console has a unique object path under its DBus connection, derived from `console-id`\n- Each console has a unique Unix domain socket abstract path, derived from `console-id`.\n\nThis drives another consideration: Because the concurrent consoles feature is implemented as separate obmc-console-server processes, the current implementation has a `1:1:1` relationship between the `(name, connection, process)` properties of the design. We only ever host one console, so there's no need for multiple names or connections in the process.\n\nChoosing design point 1 above would necessarily maintain this relationship, as it uses further processes to represent the muxed consoles.\n\nAs mentioned in reviews of the other patches, DBus allows us to claim multiple bus names. From [the spec](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus):\n\n> As with interface names, including a version number in well-known bus names is a good idea; it's possible to have the well-known bus name for more than one version simultaneously if backwards compatibility is required.\n\nDesign point 2 above allows us to choose between a two more options:\n\n1. `N:N:1`: In our one obmc-console-server process we create N connections to represent the N mux legs, and we create 1 bus name for each of the N connections\n2. `N:1:1`: In our one obmc-console-server process we create 1 connection, and request N bus names for it\n\nThe trade-off between these two is that option 1 splits the object tree, while option 2 unifies it: Using any claimed connection name to communicate with the process yields the same object tree as any other claimed connection name.\n\nFurther, option 2 doesn't have a negative impact on the current DBus ABI - the unified object tree just has more objects in it than would otherwise be expected, but still contains the object at the path expected by current implementations in e.g. bmcweb or phosphor-host-ipmid.\n\nHere's a gist demonstrating the concept:\n\nhttps://gist.github.com/amboar/4ad0c808ffa3d7b3be0b85d26b7db619\n\nGiven the circumstances where we have a mux as a focal point, I think the second design-point with the second bus connection option is a more natural representation: It gives us one object tree for all consoles behind a mux, and therefore an opportunity for a singular instance of an interface to control the mux in the manner of a \"manager\" object. In essence, we could put a hypothetical `Mux` interface on an object at `/xyz/openbmc_project/console` that controls the mux for all the console objects underneath its path. At this point it's a bit limited in that the representation suggests a single mux and not a tree of `N` muxes with `N > 1`, but it's not clear to me that we should be concerned by that. Possibly we could work around it with clever specification of GPIOs in the config and our `mux-index` property anyway.\n\nNow, I still think it's reasonable that we have an `Active` property on an interface on each individual console object that generates a `PropertiesChanged` signal. This signals to any watchers that the mux has been switched to or away from the console of interest while only watching that console object and without relying on some unspecified in-band text. However, that doesn't do anything for consumers that didn't connect via the DBus API either, so I'm yet to form an opinion.\n\n---\n\nSo addressing your request and your broader response:\n\n> please paste the interface and how it should look like, with detailed info on ... and if it should be conditionally exposed.\n\nWith the demo in the gist defining `Mux` as a separate interface on the `/xyz/openbmc_project/console` object it's easy for it to be conditionally exposed. I think the output in the gist captures the rest of the details of what I'm proposing. Please do be assured that I'm not claiming it's perfect and can't be changed in the face of reason, but I consider it a starting point that accounts for my thoughts above. It's not a directive, and I would like your feedback.\n\n> I can think of a few reasons why having the 'Active' property might be beneficial.\n\nThanks for enumerating your thoughts there. My feeling is exploiting the `Active` property to represent power states of the connected devices is a bridge too far, especially in the face of an `Activate()` method. If `Active` comes to represent power state then it follows that `Activate()` affects power state, and IMO that's really not something `obmc-console` should be concerned with.\n\n> In the case of not having a separate dbus name, the Manager needs to be at the path or interface level for each console.\n\nI don't necessarily agree with this, and I've set this statement aside in my suggestion above. [The DBus spec says](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus):\n\n> If a well-known bus name implies the presence of a \"main\" interface, that \"main\" interface is often given the same name as the well-known bus name, and situated at the corresponding object path. \n\nIt's suggesting an idiomatic structure, but it doesn't require it. Further, if we consider the \"main\" interface to be the `Access` interface for the console then we're still upholding the spirit of the spec. Just that we locate another interface on a parent object that can control some behaviour of the \"main\" interface.\n\n> Since the console id is already part of the bus name, i would assume the manager object needs it's own bus name. Something like\n>\n> xyz.openbmc_project.Console.Manager\n> \n> But then that is not possible with multiple console servers which each have their own mux.\n>\n\n> One could suggest doing something related to the name of the tty device, like\n>\n> xyz.openbmc_project.Console.TTYS1Manager\n> ...\n>\n> This is somewhat inconvenient to use since the name of the tty device is exposed, which is configuration detail, and instead of having to just know the name of the console id, the user now also has to know the name of the tty device to use this concept.\n\n> In that case this 'Manager' with it's 'Mux' interface, independent of it's object path, is already doing what the 'xyz.openbmc_project.Console.Control' interface was doing, just with another name.\n\nYeah, I agree these approaches are all a bit undesirable. However, what I've proposed isn't any of these and I don't think suffers from the drawbacks.\n\nI'm interested in your thoughts and apologies again for such a long response."
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Alexander",
                        "email": "alexander.hansen@9elements.com",
                        "username": "pointbazaar"
                    },
                    "message": "Well, thanks for all this feeback \ud83d\udc4d.\n\nI'm more of an \"write code now and ask questions later\" kind of person but maybe\nthat's not what's needed now \ud83d\ude04\n\nIt really helps to see some ```busctl tree``` and introspect output. I would have thought you would just write something down but you did a complete code example!\n\n### Power State\n\n> Thanks for enumerating your thoughts there. My feeling is exploiting the Active property to represent power states of the connected devices is a bridge too far, especially in the face of an Activate() method. If Active comes to represent power state then it follows that Activate() affects power state, and IMO that's really not something obmc-console should be concerned with.\n\nYes, obmc-console should not affect power state.\n\n### Negative impact to current dbus API\n\n> Further, option 2 doesn't have a negative impact on the current DBus ABI - the unified object tree just has more objects in it than would otherwise be expected, but still contains the object at the path expected by current implementations in e.g. bmcweb or phosphor-host-ipmid.\n\nWhy would option 1 have a negative impact on the current DBus ABI? The tree would be the same as before, when looking at a single console, just with an additional interface.\nCould the additional dbus interface break existing software?\n\n### Concern about reaching console host2 via dbus name of console host1\n\nFrom your example:\n```\nbusctl tree --user xyz.openbmc_project.Console.host1\n\u2514\u2500/xyz\n  \u2514\u2500/xyz/openbmc_project\n    \u2514\u2500/xyz/openbmc_project/console\n      \u251c\u2500/xyz/openbmc_project/console/host1\n      \u2514\u2500/xyz/openbmc_project/console/host2\n```\n\nIMO what's kind of unfortunate with this tree is there is ```host1``` dbus name exposing ```host2``` object path. But it's only a minor detail. I'm not sure if it's pattern or anti-pattern to do something like that in dbus. You probably know better about how to properly represent things in dbus.\n\nThe benefit is clear, as you said all the console-ids controlled by one mux are exposed. So it is clear i can write ```host2``` into ```Selected``` property.\n\nWith the current implementation (split tree) we cannot directly see all the consoles controlled by one process. This could be easily exposed but i'm not sure it's needed for now.\n\n### Concern about multiple ways do do something\n\nroughly\n```\nbusctl set-property xyz.openbmc_project.Console.host2 \\\n/xyz/openbmc_project/console \\\nxyz.openbmc_project.Console.Mux Selected s \"host2\"\n```\n\nbut this would also be possible:\n```\nbusctl set-property xyz.openbmc_project.Console.host1 \\\n/xyz/openbmc_project/console \\\nxyz.openbmc_project.Console.Mux Selected s \"host2\"\n```\n\nWhich creates two ways of doing one thing \ud83d\ude2d\n\nSo we can access the mux via dbus name of any console connected to it.\n\n\n### Concern about non-inclusive unified tree.\n\nThen people may ask, why unrelated console \"myconsole3\" from different tty is not part of that tree.\n\nSo the unified tree is specific to a mux. But software using obmc-console's dbus interfaces may not care about this mux. And people may be confused about how this tree came to look like that. Then they need to learn about the existence of a mux to see why some consoles are in this tree and not in the other.\n\nIf we make a split tree, where every console has it's own dbus name and only exposes itself, that may be easier for people to work with, since the tree looks almost the same for every console.\n\nPeople who only need to select one console for interactive use can then use\nthe ```/xyz/openbmc_project/console``` path or ```/xyz/openbmc_project/console/host1```, depending on where we want to handle mux control.\n\nIt would not matter which mux it's connected to or which obmc-console-server is exposing it.\n\nIt would not even matter if there is a mux at all. ('Active' would just be true, and 'Activate()' would be nop).\n\nSo this 'split tree' approach would make it extremely simple to work with,\nfor the use case of selecting one console when needed.\n\n### Concern about dbus bloat\n\nFor software which is iterating or aggregating over dbus resources, it is better to have less dbus names and less dbus paths. The split tree is smaller in this way.\n\n### Exposing Mux Topology\n\nFor exposing the details of the mux topology (conflicting consoles) to other software, this can easily be done but does not have any urgency IMO.\n\nThe unified tree already exposes this but does so implicitly, and not in a straightforward and obvious way.\nA straightforward way could be a property (array of strings).\n\n### Conclusion\n\nThe use-case i see for this work is for external software to control the mux state implicitly by selecting a console. In both cases that's possible.\n\nI feel like the major issue we need to agree on is split-tree vs. unified tree.\n\nFor me, i prefer the split tree, but the unified tree would also work fine.\nAll the concerns i listed are minor concerns. So i would be fine to do the unified tree.\n\nPlease let me know which approach you want, and i can upload the next revision and get started on the minor details."
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@codeconstruct.com.au",
                        "username": "amboar"
                    },
                    "message": "Just a note that I expect a bunch of this discussion will also need to be reflected in the design doc requested here:\n\nhttps://gerrit.openbmc.org/c/openbmc/obmc-console/+/71867/comment/6ecabc29_aba89ebc/"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Alexander",
                        "email": "alexander.hansen@9elements.com",
                        "username": "pointbazaar"
                    },
                    "message": "But which approach do you prefer? Since you asked for feedback,\ni assume the dbus representation still up for discussion.\n\nAs per your request, design doc created here.\n\nPlease comment on there if there is anything missing \ud83d\udc4d\n\nhttps://gerrit.openbmc.org/c/openbmc/docs/+/72125"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 1,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@codeconstruct.com.au",
                        "username": "amboar"
                    },
                    "message": "> But which approach do you prefer? Since you asked for feedback, i assume the dbus representation still up for discussion.\n\nYeah, I'm not determined to push through what I outlined above. There are trade-offs as you've highlighted, hence wanting to make sure they're discussed and captured somewhere that isn't a fragmented set of Gerrit comments \ud83d\ude0a\n\n> As per your request, design doc created here.\n>\n> Please comment on there if there is anything missing \ud83d\udc4d\n\nThanks for that, will do.\n\nI'll mark this as resolved for now with the expectation that we'll figure it out in discussion on the design doc."
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 13,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "This isn't C.  Use a dbus error if you have an error to return."
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "line": 13,
                    "reviewer": {
                        "name": "Alexander",
                        "email": "alexander.hansen@9elements.com",
                        "username": "pointbazaar"
                    },
                    "message": "Done"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 20,
                    "deletions": 0
                },
                {
                    "file": "gen/xyz/openbmc_project/Console/meson.build",
                    "type": "MODIFIED",
                    "insertions": 15,
                    "deletions": 0
                },
                {
                    "file": "gen/xyz/openbmc_project/Console/Control/meson.build",
                    "type": "ADDED",
                    "insertions": 15,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "type": "ADDED",
                    "insertions": 21,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 71,
            "sizeDeletions": 0
        },
        {
            "number": 3,
            "revision": "555c78bb8742fdf55b3669c3a92e42c18629d6db",
            "parents": [
                "9b664e95f79a66b515e360bf3cdce13e42d818ef"
            ],
            "ref": "refs/changes/78/71878/3",
            "uploader": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "createdOn": 1718099660,
            "author": {
                "name": "Alexander",
                "email": "alexander.hansen@9elements.com",
                "username": "pointbazaar"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 20,
                    "deletions": 0
                },
                {
                    "file": "gen/xyz/openbmc_project/Console/meson.build",
                    "type": "MODIFIED",
                    "insertions": 15,
                    "deletions": 0
                },
                {
                    "file": "gen/xyz/openbmc_project/Console/Control/meson.build",
                    "type": "ADDED",
                    "insertions": 15,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
                    "type": "ADDED",
                    "insertions": 16,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 66,
            "sizeDeletions": 0
        }
    ]
}