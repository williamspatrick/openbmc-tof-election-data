{
    "project": "openbmc/entity-manager",
    "branch": "master",
    "id": "I7fac63f184aa62731ac0619b3027ea6c270817be",
    "number": 49341,
    "subject": "fru-device: add support for LI1902 FRU data format",
    "owner": {
        "name": "Zev Weiss",
        "email": "zev@bewilderbeest.net",
        "username": "zevweiss"
    },
    "url": "https://gerrit.openbmc.org/c/openbmc/entity-manager/+/49341",
    "commitMessage": "fru-device: add support for LI1902 FRU data format\n\nThis is an EEPROM format employed on the Delta AHE-50DC (and possibly\nother systems we've yet to discover).  I don't know of a spec or any\nreal documentation of the format being available anywhere, but it has\nenough overlap with IPMI FRU data that we can reasonably translate it\ninto the standard format after parsing it, which is the approach taken\nhere as a fallback if the initial attempt at finding standard IPMI FRU\ndata fails.\n\nTested: on a Delta AHE-50DC, running\n\n  $ busctl introspect xyz.openbmc_project.FruDevice \\\n      /xyz/openbmc_project/FruDevice/DeltaPowerShelf\n\nproduces a listing of the expected baseboard FRU data.\n\nSigned-off-by: Zev Weiss <zev@bewilderbeest.net>\nChange-Id: I7fac63f184aa62731ac0619b3027ea6c270817be\n",
    "createdOn": 1638584800,
    "lastUpdated": 1645227663,
    "open": true,
    "status": "NEW",
    "comments": [
        {
            "timestamp": 1638584800,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Uploaded patch set 1."
        },
        {
            "timestamp": 1638584811,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1638585029,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: Verified-1\n\nBuild Failed \n\nhttps://jenkins.openbmc.org/job/ci-repository/31246/ : FAILURE"
        },
        {
            "timestamp": 1638585307,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Uploaded patch set 2."
        },
        {
            "timestamp": 1638585321,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1638585636,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/31249/ : SUCCESS"
        },
        {
            "timestamp": 1638585840,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 2:\n\nOne aspect of this that's still an open question is handling WriteFru requests -- my inclination is to just blanket deny write requests to FRUs in this format (e.g. by returning a \"read-only\" bool from readFRUContents() and recording the bus/address in a map to be checked against later in writeFRU()).  Ed (or others), does that seem tolerable?"
        },
        {
            "timestamp": 1638591024,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Uploaded patch set 3."
        },
        {
            "timestamp": 1638591038,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1638591226,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 3:\n\n> Patch Set 2:\n> \n> One aspect of this that's still an open question is handling WriteFru requests -- my inclination is to just blanket deny write requests to FRUs in this format (e.g. by returning a \"read-only\" bool from readFRUContents() and recording the bus/address in a map to be checked against later in writeFRU()).  Ed (or others), does that seem tolerable?\n\nFigured I might as well draft up a patch for that and post it, so: https://gerrit.openbmc-project.xyz/c/openbmc/entity-manager/+/49343"
        },
        {
            "timestamp": 1638591321,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/31252/ : SUCCESS"
        },
        {
            "timestamp": 1641980863,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Uploaded patch set 4."
        },
        {
            "timestamp": 1641980874,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 4: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1641980874,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 4: -Ok-To-Test"
        },
        {
            "timestamp": 1641981157,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 4: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/35395/ : SUCCESS"
        },
        {
            "timestamp": 1642098054,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 4:\n\n(21 comments)"
        },
        {
            "timestamp": 1642117544,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 4:\n\n(18 comments)"
        },
        {
            "timestamp": 1642119115,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1642185933,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 4:\n\n(5 comments)"
        },
        {
            "timestamp": 1642207881,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 4:\n\n(4 comments)"
        },
        {
            "timestamp": 1643053053,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1644627643,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1644628201,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1644629253,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1644771582,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 4:\n\n(2 comments)"
        },
        {
            "timestamp": 1644779250,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 4:\n\n(2 comments)"
        },
        {
            "timestamp": 1644876465,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 4:\n\n(2 comments)"
        },
        {
            "timestamp": 1645068676,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1645070249,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1645227663,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        }
    ],
    "patchSets": [
        {
            "number": 1,
            "revision": "b50e57c790c01ff47bce718f524ea474d53d6478",
            "parents": [
                "5468c6e953f608331ff455fea51ce541ea2cd9f0"
            ],
            "ref": "refs/changes/41/49341/1",
            "uploader": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "createdOn": 1638584800,
            "author": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 24,
                    "deletions": 0
                },
                {
                    "file": "src/FruUtils.cpp",
                    "type": "MODIFIED",
                    "insertions": 249,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 273,
            "sizeDeletions": 1
        },
        {
            "number": 2,
            "revision": "e76689ee747f09285a797c12e991cb0b38acd047",
            "parents": [
                "5468c6e953f608331ff455fea51ce541ea2cd9f0"
            ],
            "ref": "refs/changes/41/49341/2",
            "uploader": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "createdOn": 1638585307,
            "author": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 24,
                    "deletions": 0
                },
                {
                    "file": "src/FruUtils.cpp",
                    "type": "MODIFIED",
                    "insertions": 249,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 273,
            "sizeDeletions": 1
        },
        {
            "number": 3,
            "revision": "e492a19c982c41c09dcc89dcd9ec6099690fcc98",
            "parents": [
                "dd7b8ae01bf429c27c54e29162dea61edd0e8d12"
            ],
            "ref": "refs/changes/41/49341/3",
            "uploader": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "createdOn": 1638591024,
            "author": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 25,
                    "deletions": 0
                },
                {
                    "file": "src/FruUtils.cpp",
                    "type": "MODIFIED",
                    "insertions": 251,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 276,
            "sizeDeletions": 1
        },
        {
            "number": 4,
            "revision": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
            "parents": [
                "934eb2f20fe256077dd06e8ef506afbc4d5c241a"
            ],
            "ref": "refs/changes/41/49341/4",
            "uploader": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "createdOn": 1641980863,
            "author": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "This being the case, how do you know you got the format right?"
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "There's a LinkedIn code dump that includes some code that supports the format; I grabbed the field order & size constants from here: https://github.com/linkedin/o19-bmc-firmware/blob/99678a156fd8d10b74793fb9c7b38408aa8cbe59/meta-openbmc/meta-linkedin/recipes-utils/linkedin-eeprom/files/lib/linkedin_eeprom.h"
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "This is great detail, and should be in your commit message."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ed, I'm currently looking at how to generalize this to more cleanly support multiple formats in an extensible, efficient way.\n\nThe rough idea I've got at the moment (no real implementation work yet) is to have a set of supported formats (IPMI, Tyan, LI1902, perhaps JEDEC SPD in the future) each with a \"probe\" or matching function of some sort to answer the question \"does this EEPROM look like that format\".  I think that should address (at least part of) the extensibility requirement, but there's still the question of efficiency.\n\nThe various format matchers will presumably each have their own little section of the EEPROM they'll need to inspect, some of which will be at the same offset (e.g. IPMI and LI1902 both being at the start), but some may need to look elsewhere (e.g. TYAN checks at offset zero and then has to read more at offset 0x6000).  To support that in full generality (matchers wanting to look at arbitrary locations) we could certainly let each of them issue their own reads, but then we'd be back in duplicated-I/O territory for the ones that do overlap as you pointed out here: https://gerrit.openbmc-project.xyz/c/openbmc/entity-manager/+/49341/comment/37c6bc0d_d0c4382b/\n\nSo to avoid that, we could introduce some little cache abstraction to store and regurgitate whatever bytes have already been read by an earlier matcher, perhaps as an offset:data map at some fixed granularity (blocks of 16 or 32 bytes or something, say).\n\nI'm not opposed to implementing that and can go ahead with it if needed, but it's slightly more added complexity than I had initially been expecting this to incur.  Do you have any thoughts on the appropriateness of that, or any alternative approaches to consider?"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Also, as I'm looking at the codebase and considering the degree of restructuring of existing code this may end up involving...what would you think of a Rust reimplementation of fru-device?  (Mostly kidding...but maybe like 40% serious.)"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "I suppose one alternate possibility would be to unconditionally read in the first N bytes and pass that buffer to each matcher on the expectation that many/most of them will probably be interested in some bytes at the beginning of the EEPROM, and then also let them issue their own reads for any other areas they need to look at (at *some* risk of duplication, but presumably much less)."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> each with a \"probe\n\nIn practice, the probe statement tends to conflict heavily with actually reading the eeprom, and might require significant reading to determine if the device in question is of that type (not all devices have a nice header in the first 8 bytes).  At a high level (at least in how I imagine this) I wouldn't expect a separate probe statement, I'd expect more of a\n\nif (attemptToReadIPMIFru(){\n   return;\n}\nif (attemptToReadLinkedinFru()){\n   return;\n}\n\nType logic.  (obviously if maps/arrays and loops are more appropriate feel free to use them.)\n\nEach individual function might include some kind of probe mechanic to return early.\n\nThe only advantage of the probe setup you suggest is that we can tell the difference between an invalid fru that has a header for something known, so we could print something like \"Invalid Linkedin FRU\".  Maybe that's important?\n\n\n> So to avoid that, we could introduce some little cache abstraction to store and regurgitate whatever bytes have already been read by an earlier matcher, perhaps as an offset:data map at some fixed granularity (blocks of 16 or 32 bytes or something, say).\n\nYeah, lets do this.  To simplify it, we could also just always read the eeprom linearly, and just track how far we've read into it to make the cache easier to code.  So if a \"driver\" requests bytes 20-28, but the cache contains 0-8, we would implicitly read 9-28 into the cache for completeness.  That I think simplifies the need for an offset:data map, and makes the payload just a vector of read bytes.\n\nMy my 2 cents."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "There's already several efforts to restructure FRUDevice in review;  If you're interested in helping with the restructuring, I would definitely help review, and start with those to see what those people are trying to get out of a restructuring.\n\nI'd love to entertain discussions about rust (I have some prototypes on my dev box as well) but we need to look at it holistically as a system, not in the context of RIIR, and definitely not in the context of adding linkedin FRU support."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "> To simplify it, we could also just always read the eeprom linearly, and just track how far we've read into it to make the cache easier to code.  So if a \"driver\" requests bytes 20-28, but the cache contains 0-8, we would implicitly read 9-28 into the cache for completeness.  That I think simplifies the need for an offset:data map, and makes the payload just a vector of read bytes.\n\nWouldn't that lead to reading in a lot of excess unneeded data in the Tyan case though?"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "> In practice, the probe statement tends to conflict heavily with actually reading the eeprom, and might require significant reading to determine if the device in question is of that type (not all devices have a nice header in the first 8 bytes).  At a high level (at least in how I imagine this) I wouldn't expect a separate probe statement,\n\nIf the distinction you're drawing here is between\n\n (a) having one strictly boolean function for checking for the presence of a given format and another to then go read and parse that format\n\nand\n\n (b) having a single combined function to attempt a read/parse and possibly fail\n\nthen yes, (b) certainly seems like the preferable approach.  I didn't mean to imply that I was really aiming for (a), though I see how it might've read that way (I was intending the \"probe\" terminology more in the sense that it's used in kernel drivers, i.e. \"try to set up a device of a particular type at a given address\").\n\n(If I've misunderstood and there's some other distinction you're getting at though, please correct as needed.)"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "> There's already several efforts to restructure FRUDevice in review\n\nI see https://gerrit.openbmc-project.xyz/c/openbmc/entity-manager/+/47246 as an open review and a couple other small refactorings (https://gerrit.openbmc-project.xyz/c/openbmc/entity-manager/+/50921, https://gerrit.openbmc-project.xyz/c/openbmc/entity-manager/+/50894); are there others underway that I've missed?"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> Wouldn't that lead to reading in a lot of excess unneeded data in the Tyan case though?\n\nYes, but keep in mind.... \"excess\" at this level is really not that much data (maybe 256 bytes?).  These are still eeproms that are quite small, and given that we parallelize the scan, I'm betting it won't have any impact on the speed of the scan itself.\n\n> If the distinction you're drawing here is between\n\nYes, essentially that was what I was pointing out.  With that said, if the model A works better in practice, I'm fine with that too,"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "> Yes, but keep in mind.... \"excess\" at this level is really not that much data (maybe 256 bytes?).  These are still eeproms that are quite small, and given that we parallelize the scan, I'm betting it won't have any impact on the speed of the scan itself.\n\nUnless I'm misunderstanding something, I think it would be 24KiB for the Tyan format?  It's not going to OOM the BMC, but at typical i2c transfer rates, perhaps a few solid seconds worth of heavy bus traffic..."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Yeah, I guess that's a good point......  Maybe the more complex cache is called for."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 591,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "All of this li1902 specific stuff definitively deserves its own file.  Please keep only the reasonably generic things here."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 591,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 595,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "In other places, we've used dictionaries for this kind of thing, given that dictionaries are going to be needed anyway when this gets converted to dbus APIs.  I suspect we need to stick with that."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 595,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 625,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Same thing as below.  This looks like something that should be relatively generic, and deduplicated with the existing fru code."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 635,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "This seems like a really odd test to be doing ourselves.  Can you explain the rationale for it?  Generally in specs, fields are either defined as ascii or binary.  Detecting the \"asciness\" of fru fields is not 100%, and we should be explicitly declaring a field binary, or ascii when we read it out."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 635,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "This is basically just an artifact of the lack of any formal spec for the format -- in the examples I've got on hand I've only seen ASCII text, but I don't know what \"rules\" (or lack thereof) there might be regarding encodings in general.  Given that the IPMI FRU format has provisions for specifying encodings per-field with the type/length byte I figured I'd have it use ASCII where the data looked like ASCII and just pass it through as raw binary otherwise (though there's of course some risk of inaccuracy there if data that \"should\" be binary happens to look like ASCII)."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 635,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Could we just say that they're ascii, and if they're not, fail to push the key into the dictionary?  Having fields that dynamically change type dependent on the input gets a little error prone, and if we expect them all to be ascii, and the examples we have are ascii, lets just error on non-ascii until we have a use case."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 635,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Sure, that sounds reasonable."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 637,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "This whole line is pretty confusing.  In the case where the string is too short, push back the str.size?  Can you please turn this into branches to make it more clear what's going on?"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 637,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "This looks like we're trying to invent an IPMI FRU from this fru type?  I suspect we need to abstract out the \"set fru\" methods into something we can use directly."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 637,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "The `size >= 2` check is due to the IPMI FRU specification of type code 0b11, which says \"At least two bytes of data must be present when this type is used\", so it's just arranging a fallback to the 0b00 (binary/unspecified) type code if an ASCII string isn't long enough.  I can certainly expand/comment the code a bit to clarify though (if this code or anything analogous remains in future revisions, which perhaps it won't)."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 744,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "I said this elsewhere, but I'll reiterate, we should not be inventing an IPMI FRU from a LI1920 FRU.  To do that is a little odd, and means that we probably need to abstract the \"set a field name\" method on the lower levels such that we can directly set the dictionary items, rather than converting one binary format to another, then converting it to dbus.  Please take another look at this, refactor and simplify."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 744,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "> ...we should not be inventing an IPMI FRU from a LI1920 FRU.  To do that is a little odd...\n\nEmphatically agreed, it's an awkward way of going about this -- but given that the FruDeviceManager interface's `GetRawFru` and `WriteFru` methods already expose the raw binary FRU data format via dbus, it seemed like the only option that wouldn't involve changing those APIs to use something more structured and then chasing down whatever users of those exist and updating them accordingly (which struck me as a much broader, more invasive change than seemed reasonable for this).\n\nThough perhaps we could have fru-device track which ones are of which type and just live with the constraint that those methods will only work on standard IPMI format FRUs...thoughts?\n\n(I'm assuming we don't want to have those methods just accept & return arbitrary non-IPMI FRU data, since I think that would lead to alternate-format data leaking out into things like client-side ipmitool code and such, which doesn't seem likely to lead to anything good...)"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 744,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "> Though perhaps we could have fru-device track which ones are of which type and just live with the constraint that those methods will only work on standard IPMI format FRUs...thoughts?\n\nHmm, though thinking about it a bit more I guess this approach would probably also mean that `ipmitool fru print 0` wouldn't work to retrieve baseboard FRU info, which would be unfortunate (at least for the AHE-50DC, which uses this format for its baseboard FRU eeprom)."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 744,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> FruDeviceManager interface's `GetRawFru` and `WriteFru` methods already expose the raw binary FRU data format via dbus\n\nGiven that those APIs are supposed to be exposing IPMI FRU payloads, it seems like we might need a new API for these?  I think the IPMI spec requires FRUs to follow the fru format, so if we had one that didn't, that's going to break ipmitool (which I think is what you pointed out).\n\n\n> Though perhaps we could have fru-device track which ones are of which type and just live with the constraint that those methods will only work on standard IPMI format FRUs...thoughts?\n\nOn its nose this sounds reasonable.  Lets look at what it does to the code and interfaces and go from there."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 744,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "> Given that those APIs are supposed to be exposing IPMI FRU payloads, it seems like we might need a new API for these?  I think the IPMI spec requires FRUs to follow the fru format, so if we had one that didn't, that's going to break ipmitool (which I think is what you pointed out).\n\nFrom a quick glance at the users of those methods via OpenGrok, it looks like maybe they only really exist to facilitate IPMI \"Read FRU Data\" and \"Write FRU Data\" commands?  In which case if we're going to support non-IPMI FRU data (without just doing a format translation), I'm not sure what we'd use a corresponding raw-binary-data dbus API for, exactly...\n\nIn an ideal world I'd still like to be able to use `ipmitool fru print` to retrieve baseboard FRU data on this system (hence the implementation path I took here), but I realize there's a bit of a fundamental mismatch between that operation and the non-IPMI-formatted FRU data I've got.  It seems like if that's going to be made to work, the only way to support it is by putting a format translation *somewhere*.  Am I wishing for the impossible here?"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 744,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> > Given that those APIs are supposed to be exposing IPMI FRU payloads, it seems like we might need a new API for these?  I think the IPMI spec requires FRUs to follow the fru format, so if we had one that didn't, that's going to break ipmitool (which I think is what you pointed out).\n> \n> From a quick glance at the users of those methods via OpenGrok, it looks like maybe they only really exist to facilitate IPMI \"Read FRU Data\" and \"Write FRU Data\" commands?\n\nBasically.\n\n>  In which case if we're going to support non-IPMI FRU data (without just doing a format translation), I'm not sure what we'd use a corresponding raw-binary-data dbus API for, exactly...\n\nSure, I guess that's a fair point if you don't intend on every reading/writing these in their \"raw\" form.\n\n> \n> In an ideal world I'd still like to be able to use `ipmitool fru print` to retrieve baseboard FRU data on this system (hence the implementation path I took here), but I realize there's a bit of a fundamental mismatch between that operation and the non-IPMI-formatted FRU data I've got.  It seems like if that's going to be made to work, the only way to support it is by putting a format translation *somewhere*.\n\n\nipmitool is open source and can accept patches, you could add this new fru format to it if you wanted, and not do any translation at any level.  Whether or not you do it as part of the normal IPMI fru commands is something we should probably discuss on a larger forum somewhere.\n\n>  Am I wishing for the impossible here?\n\nIn terms of translation, a little.  From where I sit it seems to be complexity for lack of wanting to modify ipmitool to support this new fru format, which doesn't seem great to me."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 745,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "nit, this would look better if you ordered the input params first, THEN the output param."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 745,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Can this be deduplicated with the other string reading functions?  It doesn't look that unique."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 745,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 747,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "We shouldn't need to clear a string before using it."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 747,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 767,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Considering this is essentially a single magic string, can we do this in one check against LI1902?  That would help to make this code more generic, similar to the tyan board."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 767,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 770,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "This is basically easctly the same check being done here: \n\nhttps://github.com/openbmc/entity-manager/blob/bd4075f74380271e58d01097cd10c6e1e2c3b92d/src/FruUtils.cpp#L616\n\nPlease come up with a generic mechanism for this, as I suspect this kind of thing is going to come up repeatedly from time to time."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 770,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 785,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "manufacturing dates almost certainly need converted to an epoch value."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 785,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Given that the approach of this patch was to convert to the IPMI format and that this field didn't seem to correspond perfectly to any of its fields I just dropped it.  It appears to be a MMDDYYYY string though; in a dictionary-based version as you suggested should that be parsed & re-formatted?"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 785,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "For some reason I thought IPMI FRUs had a manufacturing date that we turned into an EPOCH value..... Here's the code for it:\n\nhttps://github.com/openbmc/entity-manager/blob/bd4075f74380271e58d01097cd10c6e1e2c3b92d/src/FruUtils.cpp#L350\n\nLooks like we just turn it into a string though, so I was mistaken."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 793,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Should we be checking this first, as part of the \"magic\" checking so we can fail earlier in the case it doesn't match?"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 793,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 806,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "init your variables please.  Should just be a matter of adding {} to the end."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 806,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 807,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Same here."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 807,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 818,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "This function can clearly fail, but doesn't really seem to be giving any indication in the API that it failed, instead returning a default constructed struct.  Please improve that with some status code returns such that the caller can differentiate failure types."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 818,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "This was just due to the fact that its only caller (`readFRUContents()`) does the same thing on error, so this allowed that call site to just be `return readLI19FRUContents()`.  I'm not sure what `readFRUContents()` would do with a more specific error indicator other than print an error message, but that's already being done here, so I didn't see much point."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 821,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "As written, this is duplicating the actual read operation of the first 8 bytes with findFRUHeader here:\n\nhttps://github.com/openbmc/entity-manager/blob/bd4075f74380271e58d01097cd10c6e1e2c3b92d/src/FruUtils.cpp#L595\n\nFor systems that don't have one of these devices installed, that's going to cause scanning performance problems.  As part of your refactoring effort asked for above, please fix that such that the first 8 bytes are only read once, similar to how the tyan board did it."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 821,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 827,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Please remove this.  Having Frus that AREN'T LI1902 isn't an error, and shouldn't be filling up the logs."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 827,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "This function should only be called as a fallback if findFRUHeader() fails, so this message should only ever be seen for a eeprom that's not recognized as standard IPMI, Tyan format, or LI1902 (and even then only if someone goes out of their way to set the `debug` flag).  Though given the amount of rewriting it looks like this patch is going to need this logic will probably all look fairly different anyway..."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 827,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> This function should only be called as a fallback if findFRUHeader() fails, so this message should only ever be seen for a eeprom that's not recognized as standard IPMI, Tyan format, or LI1902 (and even then only if someone goes out of their way to set the `debug` flag).\n\nWhat you described happens on almost every system.  There are lots of i2c devices that look like eeproms that we ignore.\n\n\n>  Though given the amount of rewriting it looks like this patch is going to need this logic will probably all look fairly different anyway...\n\n+1"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 827,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 894,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "There's already a precedence for doing this kind of thing in the findFruHeader method.  I'd like to see this moved there such that we're keeping all the custom-board fru parsing logic in one place.  Alternatively, we could move the tyan stuff here if it looks cleaner, but I'd really like one place to look for all the \"check for custom magic string\" functions."
                },
                {
                    "file": "src/FruUtils.cpp",
                    "line": 894,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "Ack"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 25,
                    "deletions": 0
                },
                {
                    "file": "src/FruUtils.cpp",
                    "type": "MODIFIED",
                    "insertions": 251,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 276,
            "sizeDeletions": 1
        }
    ]
}