{
    "project": "openbmc/sdbusplus",
    "branch": "master",
    "id": "I11dd2b5c40b4410c88faf2934ef23e03d5b953a1",
    "number": 64536,
    "subject": "asio: Add get_property method",
    "owner": {
        "name": "Jian Zhang",
        "email": "zhangjian3032@gmail.com",
        "username": "zhangjian3032"
    },
    "url": "https://gerrit.openbmc.org/c/openbmc/sdbusplus/+/64536",
    "hashtags": [],
    "createdOn": 1688021806,
    "lastUpdated": 1701835233,
    "open": true,
    "status": "NEW",
    "comments": [
        {
            "timestamp": 1688021806,
            "reviewer": {
                "name": "Jian Zhang",
                "email": "zhangjian3032@gmail.com",
                "username": "zhangjian3032"
            },
            "message": "Uploaded patch set 1."
        },
        {
            "timestamp": 1688021835,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1688021835,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: -Ok-To-Test"
        },
        {
            "timestamp": 1688022488,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/69852/ : SUCCESS"
        },
        {
            "timestamp": 1688023012,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 1: Code-Review+1"
        },
        {
            "timestamp": 1688572957,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 1:\n\n(2 comments)"
        },
        {
            "timestamp": 1688620120,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1688661350,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 1:\n\n(2 comments)"
        },
        {
            "timestamp": 1688697880,
            "reviewer": {
                "name": "Jian Zhang",
                "email": "zhangjian3032@gmail.com",
                "username": "zhangjian3032"
            },
            "message": "Uploaded patch set 2.\n\nOutdated Votes:\n* Code-Review+1 (copy condition: \"changekind:NO_CHANGE OR changekind:NO_CODE_CHANGE OR changekind:TRIVIAL_REBASE OR is:MIN\")\n* Verified+1 (copy condition: \"changekind:NO_CHANGE OR changekind:NO_CODE_CHANGE\")\n"
        },
        {
            "timestamp": 1688697910,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1688697910,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: -Ok-To-Test"
        },
        {
            "timestamp": 1688698615,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/70372/ : SUCCESS"
        },
        {
            "timestamp": 1688700142,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1688707664,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1688760816,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1688966399,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1689005688,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 2:\n\n(2 comments)"
        },
        {
            "timestamp": 1689005971,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1690183932,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1690303258,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1690303453,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1690337301,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1690415980,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1690426798,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1692227983,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1701444744,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1701776547,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Uploaded patch set 3.\n\nOutdated Votes:\n* Verified+1 (copy condition: \"changekind:NO_CHANGE OR changekind:NO_CODE_CHANGE\")\n"
        },
        {
            "timestamp": 1701776574,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1701776574,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: -Ok-To-Test"
        },
        {
            "timestamp": 1701776847,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 3:\n\n(3 comments)"
        },
        {
            "timestamp": 1701777011,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/76813/ : SUCCESS"
        },
        {
            "timestamp": 1701797739,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1701799213,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1701805087,
            "reviewer": {
                "name": "Brad Bishop",
                "email": "bradleyb@fuzziesquirrel.com",
                "username": "bradbishop"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1701805659,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1701808310,
            "reviewer": {
                "name": "Brad Bishop",
                "email": "bradleyb@fuzziesquirrel.com",
                "username": "bradbishop"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1701835233,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        }
    ],
    "patchSets": [
        {
            "number": 1,
            "revision": "d7d27a74c3157913684f962fdefe3a5d693a6750",
            "parents": [
                "fa663aec1ec21036f972318cb9cd59b3623f7afd"
            ],
            "ref": "refs/changes/36/64536/1",
            "uploader": {
                "name": "Jian Zhang",
                "email": "zhangjian3032@gmail.com",
                "username": "zhangjian3032"
            },
            "createdOn": 1688021806,
            "author": {
                "name": "Jian Zhang",
                "email": "zhangjian3032@gmail.com",
                "username": "zhangjian3032"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "What is the utility of this?  Why would you need to get the value of a local property from within the same server?"
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "The \"asio\" code in sdbusplus hide the property value in internal callbable object, and thus the property can not be directly accessed like how \"non-asio\" code does.\nSo it has `setter` function but does not have a `getter` function.\n\nFor an asio service, it could easily set a property, but could not get it back.\nAdding the `getter` function helps in such case."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "you haven\u2019t really explained WHY a getter helps.  what is the use case where registering your own getter/setter callback attached to an internal parameter doesn\u2019t solve the problem?\n\nalso, you can \u201cget it back\u201d if you\u2019re writing your own callback functions that point to internal state parameters, which I\u2019d expect the app to be doing in this case."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "> What is the use case where registering your own getter/setter callback attached to an internal parameter doesn\u2019t solve the problem?\n\nFor a client that makes dbus calls, that's OK, it always needs to make a DBus call to get and set a property.\n\nFor a service that implements an interface, there is no such `getter` function at all.\nE.g. check below code in a service:\n\n // In some function it sets a value\n iface->set_property(propertyName, xxx);\n ...\n // In other functions it tries to get the value\n // But there is no such getter function!\n auto value = ifase->get_property(propertyName);\n \nThis patch adds such `getter`. Otherwise, the code where needs to get a property will have to \"save\" the value in other data structure."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> For a service that implements an interface, there is no such getter function at all.\n\n\nRight, the application provides its own getter, with register_property_r(), and have the callback point to your local copy of the variable.\n\nI'm assuming in your application you're using the register_property_r overload that takes PropertyType as an argument, not the overload that takes CallbackTypeGet as an argument.  The former is really only intended for parameter that won't change after the interface is instantiated.\n\nOverload that's being used right now:\nhttps://github.com/openbmc/sdbusplus/blob/fa663aec1ec21036f972318cb9cd59b3623f7afd/include/sdbusplus/asio/object_server.hpp#L402\n\nOverload that should be used to attach a reference to your parameter either through a lambda object, or std::bind_front():\nhttps://github.com/openbmc/sdbusplus/blob/fa663aec1ec21036f972318cb9cd59b3623f7afd/include/sdbusplus/asio/object_server.hpp#L434\n\n\n> // In other functions it tries to get the value\n\nThis would imply that you're trying to use the dbus interface as an abstraction for two modules to share state, which is a generalized anti-pattern.  One object should own the dbus interface state, and any communication with other modules should happen in application code without any mention of dbus.  This prevents a lot of abstraction issues.\n\nAgain, please provide the code that is using this, so we can give more concrete direction, but overall, I do not believe this getter function is worthwhile, and it prevents us from making the set_property() abstraction more efficient in the future (which was my intent)."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "> Right, the application provides its own getter, with register_property_r(), and have the callback point to your local copy of the variable.\n\nThis assumes and forces the service/application to have a **local copy** of the variable.\nThe purpose for this patch is to provide the capability for a service to not save the **local copy**.\nCompare to the non-asio sdbusplus service:\n* A service that implements a generated \"server.hpp\" get the property in its base class, and thus it does not need to save a local copy at all. It could use the variable defined in server.hpp directly, and there is **only one instance** for the property.\n* Current asio service does not have such capability, a service will have to save a local copy of a property, and make sure it is synced in the getter and setter's callbacks.\n\n> This would imply that you're trying to use the dbus interface as an abstraction for two modules to share state, which is a generalized anti-pattern.\n\nNope, my case is as simple as above, that one service implements a interface and holds a property, it is better to have both setter and getter, instead of only a setter.\n\n> Again, please provide the code that is using this, so we can give more concrete direction.\n\nThe code is already shows in the above demo, it's pretty simple.\n\n> I do not believe this getter function is worthwhile, and it prevents us from making the set_property() abstraction more efficient in the future (which was my intent).\n\nCould you elaborate how to improve the set_property() to a more efficient way? And then we could discuss how to get a more efficient get_property() as well."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Please reply with the code that does this in one of the openbmc applications.\n\n> to have a local copy of the variable.\n\nYep.  Applications having a local copy of a variable is how this was set up.  The code for adding a property directly was only for properties that realistically don't change.  You seem to imply that having a local copy of a variable is a problem, but I'm not really sure why.\n\n\nGetting an example of this in an application will help quite a bit I think.  Please provide the example, and we can go from there."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "@Vernon / @Ed - please weigh in.  I don't have a lot of opinion on the ASIO code."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Is there any example of how this would be used in a real scenario?  The pattern I would expect would be to register a getter function and have that getter sourced by whatever data you want within the applications class, not to have sdbusplus take ownership of the property, just to have it read out again.  Having multiple sources of truth is messy, and the application should know what the state of a property is within its own state, not having to rely on the dbus interface."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "still no reply to this."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "The \"sync\" API and the new \"async\" API with c++ co-routine both have the equivalent set/get property APIs.\nI do not see a reason why it's not accepted for the \"asio\" APIs."
                },
                {
                    "file": "include/sdbusplus/asio/object_server.hpp",
                    "line": 43,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Accepting by std::any is a mediocre api, because it doesn't handle errors well.  Coding errors become runtime errors instead of compile time.  We do it for get_property because of history, and because accepting by std::any is better than the template parameter that preceeded it, but still leaves a lot to be desired.\n\nIf we MUST have this feature (which I'm not sure we do) I'd much rather that the register_property interface returned an object that could be then used to interact with the property itself, and that object could be template typed the same as the property itself, rather than having to accept std::any."
                },
                {
                    "file": "include/sdbusplus/asio/object_server.hpp",
                    "line": 43,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "The \"set_property\" API uses std::any as well, this is how current set/get property APIs implemented."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 16,
                    "deletions": 0
                },
                {
                    "file": "include/sdbusplus/asio/object_server.hpp",
                    "type": "MODIFIED",
                    "insertions": 63,
                    "deletions": -9
                }
            ],
            "sizeInsertions": 79,
            "sizeDeletions": 9
        },
        {
            "number": 2,
            "revision": "d8ad1941b401fe9dc3d95c585bbbfefbb6dbbd9e",
            "parents": [
                "fa663aec1ec21036f972318cb9cd59b3623f7afd"
            ],
            "ref": "refs/changes/36/64536/2",
            "uploader": {
                "name": "Jian Zhang",
                "email": "zhangjian3032@gmail.com",
                "username": "zhangjian3032"
            },
            "createdOn": 1688697880,
            "author": {
                "name": "Jian Zhang",
                "email": "zhangjian3032@gmail.com",
                "username": "zhangjian3032"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "FYI, I've also pushed my WIP for having a \"Dbus property\" object that could accept sets, and is the reason I'm asking hard questions on this patchset.  It removes the need for std::any.  If we wanted to add get() to that it would be trivial, but I'd still like to see a use case where it makes the code clearer compared to just specifying a setter and a getter.\n\nhttps://gerrit.openbmc.org/c/openbmc/sdbusplus/+/64732"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "> https://gerrit.openbmc.org/c/openbmc/sdbusplus/+/64732\n\nIt does look trivial to add `getter` in the PropertyTag, I will probably raise proposals to add such getter if it's merged.\n\n>  I'd still like to see a use case where it makes the code clearer compared to just specifying a setter and a getter.\n\nLet's take below code snippet as an example, assuming we have an interface `com.example.my_name`, with a string property `MyName`.\n\n### Non-ASIO\nWith non-asio, the yaml generated code, we could use the properties simply by calling the getter, without any extra variables.\n```cpp\nclass MyNameManager : public MyNameInherit\n{\n  public:\n    MyNameManager(sdbusplus::bus::bus& bus, const char* objPath) :\n        MyNameInherit(bus, objPath), bus(bus)\n    {}\n    sdbusplus::bus::bus& bus;\n\n    // setter\n    std::string myName(std::string value) override\n    {\n        info(\"myName setter: {NAME}\", \"NAME\",\n             convertBMCStateToString(value));\n        return MyNameInherit::myName(value);\n    }\n\n    void foo()\n    {\n        // Need to get the property value, call the getter\n        auto name = MyNameInherit::myName();\n        info(\"My Name is {NAME}\", \"NAME\", name);\n    }\n\t// No extra variable required to hold the MyName property\n};\n\n```\n\n### ASIO without getter\nWith asio, we can not simply do that unless it uses an extra variable to save the value on set.\n```cpp\nclass MyNameManager\n{\n  public:\n    MyNameManager(sdbusplus::asio::object_server& objectServer)\n    {\n        myInterface = objectServer.add_interface(\n            \"/com/example/my_name_path\", \"com.example.my_name_manager\");\n\n        myInterface->register_property(\n            \"MyName\", std::string(\"foo\"),\n            // setter\n            [&](const std::string& req, std::string& propertyValue) {\n                info(\"MyName setter: req: {REQ}\", \"REQ\", req);\n                propertyValue = req;\n                name = req;  // Save the property to the extra variable\n                return 1;\n                });\n        myInterface->initialize();\n    }\n    void foo()\n    {\n        // Now we need to get the property\n        // It has to use the extra `name` variable\n        info(\"My Name is {NAME}\", \"NAME\", name);\n    }\n  private:\n    std::shared_ptr<sdbusplus::asio::dbus_interface> myInterface;\n    std::string name;  // We have to save the extra variable.\n};\n```\n\n### ASIO with getter\nWith asio and with this patch, we can write code similar to non-asio:\n```cpp\nclass MyNameManager\n{\n  public:\n    MyNameManager(sdbusplus::asio::object_server& objectServer)\n    {\n        myInterface = objectServer.add_interface(\n            \"/com/example/my_name_path\", \"com.example.my_name_manager\");\n\n        myInterface->register_property(\n            \"MyName\", std::string(\"foo\"),\n            // setter\n            [&](const std::string& req, std::string& propertyValue) {\n                info(\"MyName setter: req: {REQ}\", \"REQ\", req);\n                propertyValue = req;\n                return 1;\n                });\n        myInterface->initialize();\n    }\n    void foo()\n    {\n        // Now we need to get the property, call getter\n        auto name = myInterface->get_property(\"MyName\");\n        if (name)\n        {\n            info(\"My Name is {NAME}\", \"NAME\", *name);\n        }\n    }\n  private:\n    std::shared_ptr<sdbusplus::asio::dbus_interface> myInterface;\n    // No extra variable needed\n};\n\n```\n\n\nWe can see that `ASIO with getter` could get the equivalent code as yaml-generated code, without extra variable.\n\nThis makes the sdbusplus asio lib complete. Otherwise it's like half implemented."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "IMO, your \"ASIO without getter\" function is more clear, and makes the variable available in the scope, and completely avoids the complexity of set_property taking a std::any.  Also,given that get_property returns a templated type, your positive example can't compile, because:\n\nauto name = myInterface->get_property(\"MyName\");\n\nWon't compile, given there's no definition of what type it is.  As an example of how this interface can be misused.\n\n\noptional<int32_t> name = myInterface->get_property<int32_t>(\"MyName\");\n\nWould compile just fine, but would be an error, because this interface is missing all type safety.\n\nOverall, the rest of the system prefers your second example, and I think it's more clear what's going on, simpler, and has more type safety, but ultimately I'm not an sdbusplus maintainer."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Also, please link the ACTUAL gerrit change to an openbmc daemon that uses this, rather than posting hypothetical example.  If there's no users of this in the project, it just ends up being dead code."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "> Also, please link the ACTUAL gerrit change to an openbmc daemon that uses this, rather than posting hypothetical example. If there's no users of this in the project, it just ends up being dead code.\n\nsdbusplus is maintained in openbmc org but it could be used outside, it's really a c++ lib for sdbus, not only for OpenBMC.\n\n\n> auto name = myInterface->get_property(\"MyName\");\n> Won't compile, given there's no definition of what type it is. As an example of how this interface can be misused.\n> optional<int32_t> name = myInterface->get_property<int32_t>(\"MyName\");\n> Would compile just fine, but would be an error, because this interface is missing all type safety.\n\nIt's true, the real usage does require the caller to specify the type when calling `get_property<>()`. If the type is unexpected it returns a `nullopt`.\n\n> your \"ASIO without getter\" function is more clea\n\nThe point is that it **forces** the user of sdbusplus to hold **an extra copy** of every property if it wants to get it somewhere else.\nIf a service implement many interface and have many properties, it will have to store **many copies** of the values.\nWhy would a library **force** the user to do that? Why not simply provide a getter (we could eliminate the `std::any` thing with your proposed https://gerrit.openbmc.org/c/openbmc/sdbusplus/+/64732) so that the user of the library have a choice to use getter rather than making a copy?"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> > Also, please link the ACTUAL gerrit change to an openbmc daemon that uses this, rather than posting hypothetical example. If there's no users of this in the project, it just ends up being dead code.\n> \n> sdbusplus is maintained in openbmc org but it could be used outside, it's really a c++ lib for sdbus, not only for OpenBMC.\n\nFeel free to link a PR to another project.  I'd like to see how this actually makes a real example better, and so I can assess the impact.\n\n> \n> \n> > auto name = myInterface->get_property(\"MyName\");\n> > Won't compile, given there's no definition of what type it is. As an example of how this interface can be misused.\n> > optional<int32_t> name = myInterface->get_property<int32_t>(\"MyName\");\n> > Would compile just fine, but would be an error, because this interface is missing all type safety.\n> \n> It's true, the real usage does require the caller to specify the type when calling `get_property<>()`. If the type is unexpected it returns a `nullopt`.\n> \n> > your \"ASIO without getter\" function is more clea\n> \n> The point is that it **forces** the user of sdbusplus to hold **an extra copy** of every property if it wants to get it somewhere else.\n\nNot if you declare a getter and a setter.  That's the intended way to do what you're trying to do here, to declare both a getter and a setter, similar to the asio example.  In that, you don't have an \"extra\" copy of the variable at all.\n\nhttps://github.com/openbmc/sdbusplus/blob/master/example/asio-example.cpp#L227\n\n> If a service implement many interface and have many properties, it will have to store **many copies** of the values.\n> Why would a library **force** the user to do that? Why not simply provide a getter (we could eliminate the `std::any` thing with your proposed https://gerrit.openbmc.org/c/openbmc/sdbusplus/+/64732) so that the user of the library have a choice to use getter rather than making a copy?\n\nSee above.  There is a simpler, and more type safe way to accomplish what you're trying to do already.\n\n\nOverall, it's been my believe for a while that sdbusplus has supported too-many ways to do something in an identical way, and that leads to problems in maintenance where less-used codepaths can break."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "> See above. There is a simpler, and more type safe way to accomplish what you're trying to do already.\n\nIt defines a `getter` lambda but it could not be called directly within the service (from my understanding). Could you elaborate how the `getter` lambda could be called to get the property in my example?\n\n> Overall, it's been my believe for a while that sdbusplus has supported too-many ways to do something in an identical way\n\nThere is **no** way for a service to call the `getter` to get a property from asio interface, this patch set adds this function."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": ">  Could you elaborate how the getter lambda could be called to get the property in my example?\n\nWhich example?  I'm still looking for a PR to an application that would make use of this."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Lei/Jian, is there any follow up on this commit?"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "Add an example usage in example/asio-example.cpp"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 18,
                    "deletions": 0
                },
                {
                    "file": "include/sdbusplus/asio/object_server.hpp",
                    "type": "MODIFIED",
                    "insertions": 63,
                    "deletions": -9
                },
                {
                    "file": "test/bus/aio.cpp",
                    "type": "MODIFIED",
                    "insertions": 35,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 116,
            "sizeDeletions": 9
        },
        {
            "number": 3,
            "revision": "34d5d69b787e469d6a18300e64c5db804ff65d30",
            "parents": [
                "fcd80ef12095e21ba366996c167f7ba2c5d59d33"
            ],
            "ref": "refs/changes/36/64536/3",
            "uploader": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "createdOn": 1701776547,
            "author": {
                "name": "Jian Zhang",
                "email": "zhangjian3032@gmail.com",
                "username": "zhangjian3032"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Is anyone on the review list interested in maintaining the ASIO code?  I've rarely touched it, never use it, and not really that interested in maintaining it.  If no one gives critical feedback we might as well just merge this."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "I'd still like to see an example of something real actually made better by this compared to just declaring a setter/getter.  As an interface, this patchset isn't type safe, so I really don't think we should merge it as is, and having it exist on master prevents cleaning up the other non typesafe interface (set_property).  If it were made typesafe, I could see it being ok as an extension, but IMO the existing patterns IMO are better.\n\nIf there really isn't anyone that wants to maintain this, I guess I can throw my name in the ring (although I don't particularly want to maintain more thing).  It's not that much code in addition to what I already maintain."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Brad Bishop",
                        "email": "bradleyb@fuzziesquirrel.com",
                        "username": "bradbishop"
                    },
                    "message": "FWIW this sort of thing does seem to exist in other ObjectServers:\n\nhttps://docs.rs/zbus/latest/zbus/struct.ObjectServer.html#method.interface"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "I don't see a way in that example to get the current value, only the equivalent of set_property.  I see a registered callback on count(), then I see\n\niface.0 = 42;\n\nWhich I think is setting the count parameter from outside, so this would be the equivalent of set_property()\n\nThen I see registering a callback for getting notified of changes.\niface.count_changed(iface_ref.signal_context()).await?;\n\nI don't see a direct \"get the current value of this property\" method, only a registered callback.  Maybe I'm missing something?"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Brad Bishop",
                        "email": "bradleyb@fuzziesquirrel.com",
                        "username": "bradbishop"
                    },
                    "message": "> Maybe I'm missing something?\n\nI'm not sure if you are or not.  There is direct access to the struct that was registered in the first place (instance of MyIface(u32)) from the outside code, irrespective of what callbacks you register with the bindings.\n\nFor the record, I don't have any strong opinions here."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "> I don't see a way in that example to get the current value, only the equivalent of set_property. I see a registered callback on count(), then I see\n> iface.0 = 42;\n> Which I think is setting the count parameter from outside, so this would be the equivalent of set_property()\n\nAs `iface.0 = 42;` is setter, obviously the server code could use the getter to get the value directly, something like `let foo = iface.0`, is it?\n\n>  As an interface, this patchset isn't type safe, so I really don't think we should merge it as is, and having it exist on master prevents cleaning up the other non typesafe interface (set_property).\n\nWe already has the non-typesafe set_property API, why preventing a symmetric get_property API? When we are going to clean up the non typesafe code, we could do it for both setter and getter.\n\n> I'd still like to see an example of something real actually made better by this compared to just declaring a setter/getter.\n\nIt's some down stream code that I can not send upstream (yet). I have put the example usage in both example code and unit test code."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 19,
                    "deletions": 0
                },
                {
                    "file": "example/asio-example.cpp",
                    "type": "MODIFIED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "include/sdbusplus/asio/object_server.hpp",
                    "type": "MODIFIED",
                    "insertions": 63,
                    "deletions": -9
                },
                {
                    "file": "test/bus/aio.cpp",
                    "type": "MODIFIED",
                    "insertions": 35,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 130,
            "sizeDeletions": 9
        }
    ]
}