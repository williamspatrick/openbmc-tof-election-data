{
    "project": "openbmc/phosphor-dbus-interfaces",
    "branch": "master",
    "id": "Ib1622b53c93fa33a050bfd2db954c3d5619f0bb4",
    "number": 46157,
    "subject": "Update power cap interface",
    "owner": {
        "name": "Gaurav Gandhi",
        "email": "gauravgandhi@google.com",
        "username": "gauravgandhi70"
    },
    "url": "https://gerrit.openbmc-project.xyz/c/openbmc/phosphor-dbus-interfaces/+/46157",
    "commitMessage": "Update power cap interface\n\nAdd Min, Max properties which can be used by phosphor-host-ipmid\n\nSigned-off-by: Gaurav Gandhi <gauravgandhi@google.com>\nChange-Id: Ib1622b53c93fa33a050bfd2db954c3d5619f0bb4\n",
    "createdOn": 1629843429,
    "lastUpdated": 1641317926,
    "open": false,
    "status": "MERGED",
    "comments": [
        {
            "timestamp": 1629843429,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Uploaded patch set 1."
        },
        {
            "timestamp": 1629843441,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1629843821,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/24954/ : SUCCESS"
        },
        {
            "timestamp": 1629844479,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 1:\n\n(3 comments)"
        },
        {
            "timestamp": 1629844902,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Uploaded patch set 2."
        },
        {
            "timestamp": 1629844921,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1629844940,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 2:\n\n(2 comments)"
        },
        {
            "timestamp": 1629845301,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/24955/ : SUCCESS"
        },
        {
            "timestamp": 1629854068,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 2:\n\n(2 comments)\n\nIt appears that the Cap was originally added by Andrew and is possibly used as a \"Setting\" object.  I don't know if that use case is compatible with having a min/max here, so need some feedback to ensure there is no issue with adding these to Setting.  It may be as simple as updating the default YAML for some systems."
        },
        {
            "timestamp": 1629860253,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Uploaded patch set 3."
        },
        {
            "timestamp": 1629860269,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1629860290,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 2:\n\n(1 comment)\n\n> Patch Set 2:\n> \n> (2 comments)\n> \n> It appears that the Cap was originally added by Andrew and is possibly used as a \"Setting\" object.  I don't know if that use case is compatible with having a min/max here, so need some feedback to ensure there is no issue with adding these to Setting.  It may be as simple as updating the default YAML for some systems.\n\nIdea is to eventually implement a daemon which will implement Cap interface and accept values from the host. Host will pass the values over ipmi, And because phosphor-host-ipmid needs min and max limits, I am updating this interface"
        },
        {
            "timestamp": 1629860311,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1629860324,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1629860328,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3: Verified-1\n\nBuild Failed \n\nhttps://jenkins.openbmc.org/job/ci-repository/24977/ : FAILURE"
        },
        {
            "timestamp": 1629892313,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 3:\n\n> Idea is to eventually implement a daemon which will implement Cap interface and accept values from the host. Host will pass the values over ipmi, And because phosphor-host-ipmid needs min and max limits, I am updating this interface\n\nThat is _one_ particular implementation.  The *current* implementation is that these are handled by the settings daemon.  \n\nTo be honest, I don't know why you'd need a new dedicated daemon for this.  Settings should be able to be accessed by your IPMI provider.\n\nSee: \n\nmeta-ibm/recipes-phosphor/settings/phosphor-settings-read-settings-mrw-native/mrw-override-settings.yaml:    - Interface: xyz.openbmc_project.Control.Power.Cap\nmeta-phosphor/recipes-phosphor/settings/phosphor-settings-defaults/defaults.yaml:    - Interface: xyz.openbmc_project.Control.Power.Cap"
        },
        {
            "timestamp": 1629892404,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1629915875,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Uploaded patch set 4: New patch set was added with same tree, parent, and commit message as Patch Set 3."
        },
        {
            "timestamp": 1629915884,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 4: -Ok-To-Test"
        },
        {
            "timestamp": 1629915888,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 4: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1629915904,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Uploaded patch set 5."
        },
        {
            "timestamp": 1629915918,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 5: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1629915922,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 4:\n\nBuild Failed \n\nhttps://jenkins.openbmc.org/job/ci-repository/25045/ : ABORTED"
        },
        {
            "timestamp": 1629916307,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 5: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/25046/ : SUCCESS"
        },
        {
            "timestamp": 1629919767,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 5:\n\n@Andrew - Any opinions on this?"
        },
        {
            "timestamp": 1629925941,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 5:\n\n> Patch Set 3:\n> \n> > Idea is to eventually implement a daemon which will implement Cap interface and accept values from the host. Host will pass the values over ipmi, And because phosphor-host-ipmid needs min and max limits, I am updating this interface\n> \n> That is _one_ particular implementation.  The *current* implementation is that these are handled by the settings daemon.  \n> \n> To be honest, I don't know why you'd need a new dedicated daemon for this.  Settings should be able to be accessed by your IPMI provider.\n> \n> See: \n> \n\nWith settings daemon, I need to add another daemon which will actually talk to the hardware. We wanted to avoid that by creating a daemon which will directly communicate with the ipmi as well as the hardware.\n\n> meta-ibm/recipes-phosphor/settings/phosphor-settings-read-settings-mrw-native/mrw-override-settings.yaml:    - Interface: xyz.openbmc_project.Control.Power.Cap\n> meta-phosphor/recipes-phosphor/settings/phosphor-settings-defaults/defaults.yaml:    - Interface: xyz.openbmc_project.Control.Power.Cap\n\nHow will host communicate with the settings daemon over ipmi? Using set_sensor_dbus_state_simple?https://github.com/openbmc/phosphor-host-ipmid/blob/d1bd8c48c0ae67a1f7fba91b0705a4d5aca027fc/ipmisensor.cpp#L219"
        },
        {
            "timestamp": 1629941727,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> With settings daemon, I need to add another daemon which will actually talk to the hardware. We wanted to avoid that by creating a daemon which will directly communicate with the ipmi as well as the hardware.\n\nI'm not sure avoiding the settings daemon really saves you much, but you can surely implement this either way.\n\nThe IPMI provider should be accessing dbus interfaces.  It doesn't care which daemon is hosting this object.  Note that it isn't this daemon communicating with IPMI, but rather IPMI communicating with the daemon.\n\nI would have expected an implementation of the IPMI provider already existed for interacting with this object, because I thought it was part of the DCMI spec.  My recollection, which could be wrong, is that the openpower-occ-control then looks at the setting daemon to push the Power.Cap values to hardware (I do see this interface being used in that repository).\n\nIf you implement this all in one daemon, you have to host the dbus object rather than simply being a client and you have to deal with persistence.  Letting the setting daemon do the dbus hosting and persistence lets it do the few things it is already good at and then your hardware-oriented daemon simply performs a dbus client access (just like IPMI and openpower-occ-control already do) and pushes to the hardware as appropriate.  \n\n> How will host communicate with the settings daemon over ipmi? Using set_sensor_dbus_state_simple?https://github.com/openbmc/phosphor-host-ipmid/blob/d1bd8c48c0ae67a1f7fba91b0705a4d5aca027fc/ipmisensor.cpp#L219\n\nI don't think this is related to sensors.  Usually each setting object has some custom dbus code in the IPMI provider side because the implementations are kind of scattered.  I think this is part of DCMI.\n\nhttps://github.com/openbmc/phosphor-host-ipmid/blob/master/dcmihandler.cpp#L26"
        },
        {
            "timestamp": 1630005028,
            "reviewer": {
                "name": "Andrew Geissler",
                "email": "geissonator@yahoo.com",
                "username": "geissonator"
            },
            "message": "Patch Set 5:\n\n> Patch Set 2:\n> \n> (1 comment)\n> \n> > Patch Set 2:\n> > \n> > (2 comments)\n> > \n> > It appears that the Cap was originally added by Andrew and is possibly used as a \"Setting\" object.  I don't know if that use case is compatible with having a min/max here, so need some feedback to ensure there is no issue with adding these to Setting.  It may be as simple as updating the default YAML for some systems.\n> \n> Idea is to eventually implement a daemon which will implement Cap interface and accept values from the host. Host will pass the values over ipmi, And because phosphor-host-ipmid needs min and max limits, I am updating this interface\n\nIt seems like we're adjusting a PDI interface to accommodate an external interface (IPMI) and have no intention of really using these new properties? That seems to go against the idea that PDI is independent of external interfaces like IPMI and Redfish. I don't think it really affects anything since our current code will not look at these new properties, but feels a bit off. I added our power management expert, Chris, to see if he has any other thoughts."
        },
        {
            "timestamp": 1630008132,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 5:\n\n> Patch Set 3:\n> \n> > Idea is to eventually implement a daemon which will implement Cap interface and accept values from the host. Host will pass the values over ipmi, And because phosphor-host-ipmid needs min and max limits, I am updating this interface\n> \n> That is _one_ particular implementation.  The *current* implementation is that these are handled by the settings daemon.  \n> \n> To be honest, I don't know why you'd need a new dedicated daemon for this.  Settings should be able to be accessed by your IPMI provider.\n\nIn practice, there are lots of servers where the BMC doesn't \"own\" the power cap value, but instead it's owned by some other piece of hardware, and the BMC is just a conduit.  To propagate error codes properly, it's important that the implementation doesn't blindly accept any value (for example, a power cap of 1W would be a problem and should return an error code).\n\nOn Intel servers, in general the power cap is owned by Management Engine, on AMD servers there's something similar.\n\nHence why this needs to be owned by a separate daemon, ideally the one in charge of talking to the \"other controller\".  \n\n> \n> See: \n> \n> meta-ibm/recipes-phosphor/settings/phosphor-settings-read-settings-mrw-native/mrw-override-settings.yaml:    - Interface: xyz.openbmc_project.Control.Power.Cap\n> meta-phosphor/recipes-phosphor/settings/phosphor-settings-defaults/defaults.yaml:    - Interface: xyz.openbmc_project.Control.Power.Cap"
        },
        {
            "timestamp": 1630008415,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> \n> > Patch Set 2:\n> > \n> > (1 comment)\n> > \n> > > Patch Set 2:\n> > > \n> > > (2 comments)\n> > > \n> > > It appears that the Cap was originally added by Andrew and is possibly used as a \"Setting\" object.  I don't know if that use case is compatible with having a min/max here, so need some feedback to ensure there is no issue with adding these to Setting.  It may be as simple as updating the default YAML for some systems.\n> > \n> > Idea is to eventually implement a daemon which will implement Cap interface and accept values from the host. Host will pass the values over ipmi, And because phosphor-host-ipmid needs min and max limits, I am updating this interface\n> \n> It seems like we're adjusting a PDI interface to accommodate an external interface (IPMI) and have no intention of really using these new properties?\n\nFor what it's worth, Redfish has very similar interfaces, so it's not \"just\" for IPMI.  This whole patchset is very...very similar to when we added MaxValue and MinValue to the sensor interface.  Yes, it allows IPMI to build the SDR, but we'll probably map it to Redfish as well at some point under the @AllowedValues decorator, even if it's less useful in that context.\n\n> That seems to go against the idea that PDI is independent of external interfaces like IPMI and Redfish. I don't think it really affects anything since our current code will not look at these new properties, but feels a bit off. I added our power management expert, Chris, to see if he has any other thoughts.\n\nI think PDI is still interface independent here, we're just moving \"business\" logic lower down the stack so we can deduplicate it, which overall I think is a good thing."
        },
        {
            "timestamp": 1630008484,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 5:\n\n> Patch Set 2:\n> \n> (1 comment)\n> \n> > Patch Set 2:\n> > \n> > (2 comments)\n> > \n> > It appears that the Cap was originally added by Andrew and is possibly used as a \"Setting\" object.  I don't know if that use case is compatible with having a min/max here, so need some feedback to ensure there is no issue with adding these to Setting.  It may be as simple as updating the default YAML for some systems.\n> \n> Idea is to eventually implement a daemon which will implement Cap interface and accept values from the host. Host will pass the values over ipmi, And because phosphor-host-ipmid needs min and max limits, I am updating this interface\n\nKeep in mind, the way you've written this, I'd expect updates to anyplace in the codebase that references PowerCap.  Ideally those updates would be at least in review before this new interface merged."
        },
        {
            "timestamp": 1630010544,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 5:\n\n> > To be honest, I don't know why you'd need a new dedicated daemon for this.  Settings should be able to be accessed by your IPMI provider.\n\n> Hence why this needs to be owned by a separate daemon, ideally the one in charge of talking to the \"other controller\".  \n\nUnderstood.  What I wrote probably didn't come out 100% correct.  IBM's implementation that I referenced also has the openpower-occ-control application.  I don't recall how much of a daemon that is or only started in certain conditions.\n\nI meant \"a new dedicated daemon to host the dbus objects\"."
        },
        {
            "timestamp": 1630011510,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> \n> > > To be honest, I don't know why you'd need a new dedicated daemon for this.  Settings should be able to be accessed by your IPMI provider.\n> \n> > Hence why this needs to be owned by a separate daemon, ideally the one in charge of talking to the \"other controller\".  \n> \n> Understood.  What I wrote probably didn't come out 100% correct.  IBM's implementation that I referenced also has the openpower-occ-control application.  I don't recall how much of a daemon that is or only started in certain conditions.\n> \n> I meant \"a new dedicated daemon to host the dbus objects\".\n\nAh, yes, a new dedicated daemon JUST for dbus objects would be bad.  In Gauravs case he's working on a new daemon to support a particular kind of CPU, so the daemon would be the \"Fubar CPU daemon\", nor a duplicate of the settings daemon."
        },
        {
            "timestamp": 1630012044,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> \n> > Patch Set 2:\n> > \n> > (1 comment)\n> > \n> > > Patch Set 2:\n> > > \n> > > (2 comments)\n> > > \n> > > It appears that the Cap was originally added by Andrew and is possibly used as a \"Setting\" object.  I don't know if that use case is compatible with having a min/max here, so need some feedback to ensure there is no issue with adding these to Setting.  It may be as simple as updating the default YAML for some systems.\n> > \n> > Idea is to eventually implement a daemon which will implement Cap interface and accept values from the host. Host will pass the values over ipmi, And because phosphor-host-ipmid needs min and max limits, I am updating this interface\n> \n> Keep in mind, the way you've written this, I'd expect updates to anyplace in the codebase that references PowerCap.  Ideally those updates would be at least in review before this new interface merged.\n\nAs I mentioned earlier, even though I am adding 2 more properties to the interface, as long as the existing implementation do not need Min, Max values , I wont have to update existing APIs. I think Andrew also commented the same. Andrew's comment -> ``` I don't think it really affects anything since our current code will not look at these new properties, but feels a bit off.```"
        },
        {
            "timestamp": 1630016838,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> \n> > Patch Set 5:\n> > \n> > > > To be honest, I don't know why you'd need a new dedicated daemon for this.  Settings should be able to be accessed by your IPMI provider.\n> > \n> > > Hence why this needs to be owned by a separate daemon, ideally the one in charge of talking to the \"other controller\".  \n> > \n> > Understood.  What I wrote probably didn't come out 100% correct.  IBM's implementation that I referenced also has the openpower-occ-control application.  I don't recall how much of a daemon that is or only started in certain conditions.\n> > \n> > I meant \"a new dedicated daemon to host the dbus objects\".\n> \n> Ah, yes, a new dedicated daemon JUST for dbus objects would be bad.  In Gauravs case he's working on a new daemon to support a particular kind of CPU, so the daemon would be the \"Fubar CPU daemon\", nor a duplicate of the settings daemon.\n\nThanks Ed for the clarification. Here is the summary of the implementation,\n\n1. Update the power-cap interface with min max value, So that the power_cap value can be exposed as dbus-sdr.\n2. Create a new power_cap daemon with which phosphor-host-ipmid will communicate. This daemon will also Communicate with the hardware to do the actual power-capping. We wont be relying on settings daemon in this plan. \n3. Another reason behind exposing power cap value as dbus sdr is this will allow host to control individual component in the system (if needed). We can expose different components in the system as different sdr entries. But AFAIK with settings daemon host will be able to control power only at system level and not at individual component level"
        },
        {
            "timestamp": 1630019890,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> \n> > Patch Set 5:\n> > \n> > > Patch Set 2:\n> > > \n> > > (1 comment)\n> > > \n> > > > Patch Set 2:\n> > > > \n> > > > (2 comments)\n> > > > \n> > > > It appears that the Cap was originally added by Andrew and is possibly used as a \"Setting\" object.  I don't know if that use case is compatible with having a min/max here, so need some feedback to ensure there is no issue with adding these to Setting.  It may be as simple as updating the default YAML for some systems.\n> > > \n> > > Idea is to eventually implement a daemon which will implement Cap interface and accept values from the host. Host will pass the values over ipmi, And because phosphor-host-ipmid needs min and max limits, I am updating this interface\n> > \n> > Keep in mind, the way you've written this, I'd expect updates to anyplace in the codebase that references PowerCap.  Ideally those updates would be at least in review before this new interface merged.\n> \n> As I mentioned earlier, even though I am adding 2 more properties to the interface, as long as the existing implementation do not need Min, Max values , I wont have to update existing APIs. I think Andrew also commented the same. Andrew's comment -> ``` I don't think it really affects anything since our current code will not look at these new properties, but feels a bit off.```\n\nUnfortunately, that's not how dbus interfaces work.  At a minimum it's a documentation problem if we suddenly have backend implementations that disobey the documented interface, and in practice, some implementations actually require that things be convertible to a struct.\n\nWith that said, I suspect this isn't that much work on your part to find the existing ones.  Some will likely be handled automatically when you add this new yaml file along with the defaults, and I'm pretty sure redfish already doesn't enforce struct-correctness, so the merges should be easy for you to to do."
        },
        {
            "timestamp": 1630020283,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> \n> > Patch Set 5:\n> > \n> > > Patch Set 5:\n> > > \n> > > > > To be honest, I don't know why you'd need a new dedicated daemon for this.  Settings should be able to be accessed by your IPMI provider.\n> > > \n> > > > Hence why this needs to be owned by a separate daemon, ideally the one in charge of talking to the \"other controller\".  \n> > > \n> > > Understood.  What I wrote probably didn't come out 100% correct.  IBM's implementation that I referenced also has the openpower-occ-control application.  I don't recall how much of a daemon that is or only started in certain conditions.\n> > > \n> > > I meant \"a new dedicated daemon to host the dbus objects\".\n> > \n> > Ah, yes, a new dedicated daemon JUST for dbus objects would be bad.  In Gauravs case he's working on a new daemon to support a particular kind of CPU, so the daemon would be the \"Fubar CPU daemon\", nor a duplicate of the settings daemon.\n> \n> Thanks Ed for the clarification. Here is the summary of the implementation,\n> \n> 1. Update the power-cap interface with min max value, So that the power_cap value can be exposed as dbus-sdr.\n\nAdd, \"and update the existing power_cap daemons with sane versions of these new values.\"  (0 and max_int) is likely fine for the existing daemons.\n\n> 2. Create a new power_cap daemon with which phosphor-host-ipmid will communicate. This daemon will also Communicate with the hardware to do the actual power-capping. We wont be relying on settings daemon in this plan. \n> 3. Another reason behind exposing power cap value as dbus sdr is this will allow host to control individual component in the system (if needed). We can expose different components in the system as different sdr entries. But AFAIK with settings daemon host will be able to control power only at system level and not at individual component level\n\nThat's not really true, this could be solved with the settings daemon and a lot of code, but I dislike that that removes the error code path if the device in question fails, so we don't really need to go down that road."
        },
        {
            "timestamp": 1630089105,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 5:\n\n> 1. Update the power-cap interface with min max value, So that the power_cap value can be exposed as dbus-sdr.\n\nWhat does \"dbus-sdr\" mean in this context (I don't even recognize it in any context)?  There are Sensor.Value interfaces, but that isn't what this interface is.\n\n> 2. Create a new power_cap daemon with which phosphor-host-ipmid will communicate. This daemon will also Communicate with the hardware to do the actual power-capping. We wont be relying on settings daemon in this plan. \n\nSure.  You're free to implement the dbus interface in your own power capping daemon.  Different daemons could even implement different instances of the interface so that you have capping on different entities.  Just be sure that \"with which phosphor-host-ipmid will communicate\" isn't some hard-coded service name; use mapper.  ipmid really shouldn't know what daemon it is talking to.\n\n> 3. Another reason behind exposing power cap value as dbus sdr is this will allow host to control individual component in the system (if needed). We can expose different components in the system as different sdr entries. But AFAIK with settings daemon host will be able to control power only at system level and not at individual component level\n\nAgain I don't know what \"dbus sdr\" is.  Before you modify the IPMI SDR handling code to map this interface to an SDR, you should probably look into the existing IPMI-DCMI handlers.  My recollection is that this interface was originally defined as a place for the data from some of the DCMI commands to go.  You should check that this handler can't simply be extended to do what you want in this case. \n\nIf it can't be extended within the context of DCMI, and you go the route of creating new SDRs for these interfaces, you'll need to be careful that you don't break the existing DCMI code or machines expecting to use that.  (I'm expecting this fits into the \"dynamic SDR\" code which will automatically create SDRs whenever it sees certain interfaces and that may be an issue for the existing system power cap via DCMI implementation.)"
        },
        {
            "timestamp": 1630089634,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> \n> > 1. Update the power-cap interface with min max value, So that the power_cap value can be exposed as dbus-sdr.\n> \n> What does \"dbus-sdr\" mean in this context (I don't even recognize it in any context)?  There are Sensor.Value interfaces, but that isn't what this interface is.\n> \n> > 2. Create a new power_cap daemon with which phosphor-host-ipmid will communicate. This daemon will also Communicate with the hardware to do the actual power-capping. We wont be relying on settings daemon in this plan. \n> \n> Sure.  You're free to implement the dbus interface in your own power capping daemon.  Different daemons could even implement different instances of the interface so that you have capping on different entities.  Just be sure that \"with which phosphor-host-ipmid will communicate\" isn't some hard-coded service name; use mapper.  ipmid really shouldn't know what daemon it is talking to.\n> \n> > 3. Another reason behind exposing power cap value as dbus sdr is this will allow host to control individual component in the system (if needed). We can expose different components in the system as different sdr entries. But AFAIK with settings daemon host will be able to control power only at system level and not at individual component level\n> \n> Again I don't know what \"dbus sdr\" is.  Before you modify the IPMI SDR handling code to map this interface to an SDR, you should probably look into the existing IPMI-DCMI handlers.  My recollection is that this interface was originally defined as a place for the data from some of the DCMI commands to go.  You should check that this handler can't simply be extended to do what you want in this case. \n> \n> If it can't be extended within the context of DCMI, and you go the route of creating new SDRs for these interfaces, you'll need to be careful that you don't break the existing DCMI code or machines expecting to use that.  (I'm expecting this fits into the \"dynamic SDR\" code which will automatically create SDRs whenever it sees certain interfaces and that may be an issue for the existing system power cap via DCMI implementation.)\n\nin context, I'm assuming he means the ipmi-dynamic option in in ipmid;"
        },
        {
            "timestamp": 1630100350,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> \n> > 1. Update the power-cap interface with min max value, So that the power_cap value can be exposed as dbus-sdr.\n> \n> What does \"dbus-sdr\" mean in this context (I don't even recognize it in any context)?  There are Sensor.Value interfaces, but that isn't what this interface is.\n> \n> > 2. Create a new power_cap daemon with which phosphor-host-ipmid will communicate. This daemon will also Communicate with the hardware to do the actual power-capping. We wont be relying on settings daemon in this plan. \n> \n> Sure.  You're free to implement the dbus interface in your own power capping daemon.  Different daemons could even implement different instances of the interface so that you have capping on different entities.  Just be sure that \"with which phosphor-host-ipmid will communicate\" isn't some hard-coded service name; use mapper.  ipmid really shouldn't know what daemon it is talking to.\n> \n> > 3. Another reason behind exposing power cap value as dbus sdr is this will allow host to control individual component in the system (if needed). We can expose different components in the system as different sdr entries. But AFAIK with settings daemon host will be able to control power only at system level and not at individual component level\n> \n> Again I don't know what \"dbus sdr\" is.  Before you modify the IPMI SDR handling code to map this interface to an SDR, you should probably look into the existing IPMI-DCMI handlers.  My recollection is that this interface was originally defined as a place for the data from some of the DCMI commands to go.  You should check that this handler can't simply be extended to do what you want in this case. \n> \nsorry for the confusion. Yes, I meant Power cap value will be exposed as IPMI-SDR entry and will be accessed using this code path under dbus-sdr (https://github.com/openbmc/phosphor-host-ipmid/blob/d1bd8c48c0ae67a1f7fba91b0705a4d5aca027fc/dbus-sdr/sensorcommands.cpp#L17)\n\n\n> If it can't be extended within the context of DCMI, and you go the route of creating new SDRs for these interfaces, you'll need to be careful that you don't break the existing DCMI code or machines expecting to use that.  (I'm expecting this fits into the \"dynamic SDR\" code which will automatically create SDRs whenever it sees certain interfaces and that may be an issue for the existing system power cap via DCMI implementation.)\n\n\nHave a question about dcmi handlers? Is the IPMI-DCMI implementation tied to the settings daemon? Do we have to use settings daemon if we use the IPMI-DCMI handlers.  https://github.com/openbmc/phosphor-host-ipmid/blob/d1bd8c48c0ae67a1f7fba91b0705a4d5aca027fc/dcmihandler.cpp#L77"
        },
        {
            "timestamp": 1630187705,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 5:\n\n> > If it can't be extended within the context of DCMI, and you go the route of creating new SDRs for these interfaces, you'll need to be careful that you don't break the existing DCMI code or machines expecting to use that.  (I'm expecting this fits into the \"dynamic SDR\" code which will automatically create SDRs whenever it sees certain interfaces and that may be an issue for the existing system power cap via DCMI implementation.)\n> \n> \n> Have a question about dcmi handlers? Is the IPMI-DCMI implementation tied to the settings daemon? Do we have to use settings daemon if we use the IPMI-DCMI handlers.  https://github.com/openbmc/phosphor-host-ipmid/blob/d1bd8c48c0ae67a1f7fba91b0705a4d5aca027fc/dcmihandler.cpp#L77\n\nIt appears that the current implementation of the DCMI handlers use a static path / service name to attempt to find the object they're looking for.  This is probably wrong on the part of that implementation.  If you need to fix it in order to be able to utilize the DCMI handlers for your (different) implementation, I see that as a good thing."
        },
        {
            "timestamp": 1630347054,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 5:\n\n> Patch Set 5:\n> \n> > > If it can't be extended within the context of DCMI, and you go the route of creating new SDRs for these interfaces, you'll need to be careful that you don't break the existing DCMI code or machines expecting to use that.  (I'm expecting this fits into the \"dynamic SDR\" code which will automatically create SDRs whenever it sees certain interfaces and that may be an issue for the existing system power cap via DCMI implementation.)\n> > \n> > \n> > Have a question about dcmi handlers? Is the IPMI-DCMI implementation tied to the settings daemon? Do we have to use settings daemon if we use the IPMI-DCMI handlers.  https://github.com/openbmc/phosphor-host-ipmid/blob/d1bd8c48c0ae67a1f7fba91b0705a4d5aca027fc/dcmihandler.cpp#L77\n> \n> It appears that the current implementation of the DCMI handlers use a static path / service name to attempt to find the object they're looking for.  This is probably wrong on the part of that implementation.  If you need to fix it in order to be able to utilize the DCMI handlers for your (different) implementation, I see that as a good thing.\n\n\nFor my implementation, using IPMI-SDR path will make more sense instead of changing DCMI code to accomodate my daemon. \n\n> > > If it can't be extended within the context of DCMI, and you go the route of creating new SDRs for these interfaces, you'll need to be careful that you don't break the existing DCMI code or machines expecting to use that.  (I'm expecting this fits into the \"dynamic SDR\" code which will automatically create SDRs whenever it sees certain interfaces and that may be an issue for the existing system power cap via DCMI implementation.)\n\nTo avoid breaking other targets by the change in IPMI SDR, I can add compiler flag for PowerCap interface related code in IPMI SDR path"
        },
        {
            "timestamp": 1630360116,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Uploaded patch set 6: Patch Set 5 was rebased."
        },
        {
            "timestamp": 1630360127,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 6: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1630360505,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 6: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/25351/ : SUCCESS"
        },
        {
            "timestamp": 1630430804,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 6:\n\n> Patch Set 5:\n> \n> > Patch Set 5:\n> > \n> > > > If it can't be extended within the context of DCMI, and you go the route of creating new SDRs for these interfaces, you'll need to be careful that you don't break the existing DCMI code or machines expecting to use that.  (I'm expecting this fits into the \"dynamic SDR\" code which will automatically create SDRs whenever it sees certain interfaces and that may be an issue for the existing system power cap via DCMI implementation.)\n> > > \n> > > \n> > > Have a question about dcmi handlers? Is the IPMI-DCMI implementation tied to the settings daemon? Do we have to use settings daemon if we use the IPMI-DCMI handlers.  https://github.com/openbmc/phosphor-host-ipmid/blob/d1bd8c48c0ae67a1f7fba91b0705a4d5aca027fc/dcmihandler.cpp#L77\n> > \n> > It appears that the current implementation of the DCMI handlers use a static path / service name to attempt to find the object they're looking for.  This is probably wrong on the part of that implementation.  If you need to fix it in order to be able to utilize the DCMI handlers for your (different) implementation, I see that as a good thing.\n> \n> \n> For my implementation, using IPMI-SDR path will make more sense instead of changing DCMI code to accomodate my daemon. \n> \n> > > > If it can't be extended within the context of DCMI, and you go the route of creating new SDRs for these interfaces, you'll need to be careful that you don't break the existing DCMI code or machines expecting to use that.  (I'm expecting this fits into the \"dynamic SDR\" code which will automatically create SDRs whenever it sees certain interfaces and that may be an issue for the existing system power cap via DCMI implementation.)\n> \n> To avoid breaking other targets by the change in IPMI SDR, I can add compiler flag for PowerCap interface related code in IPMI SDR path\n\nIs this approach ok? If yes, can anyone of the reviewer approve the review. Thanks!"
        },
        {
            "timestamp": 1630434858,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 6:\n\n> For my implementation, using IPMI-SDR path will make more sense instead of changing DCMI code to accomodate my daemon. \n\nThis is ultimately outside the scope of this review, but can you elaborate why?\n\n> To avoid breaking other targets by the change in IPMI SDR, I can add compiler flag for PowerCap interface related code in IPMI SDR path\n\nI'd prefer we refrain from making too many feature compile flags, unless those are enabled by default.  We're running into too many cases where code is \"good\" in the repository and then fails on some machine that has the compile flag enabled.  Alternatively you can make a runtime config that enables this feature on this machine (maybe something triggered by EM?)."
        },
        {
            "timestamp": 1630434888,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 6:\n\n> Is this approach ok? If yes, can anyone of the reviewer approve the review. Thanks!\n\nHas there been confirmation this doesn't break the existing Settings implementations by adding new properties to them?"
        },
        {
            "timestamp": 1630435053,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 6:\n\n> Patch Set 6:\n> \n> > Is this approach ok? If yes, can anyone of the reviewer approve the review. Thanks!\n> \n> Has there been confirmation this doesn't break the existing Settings implementations by adding new properties to them?\n\nI will look into it and upadte here"
        },
        {
            "timestamp": 1630446353,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 6:\n\n> Patch Set 6:\n> \n> > For my implementation, using IPMI-SDR path will make more sense instead of changing DCMI code to accomodate my daemon. \n> \n> This is ultimately outside the scope of this review, but can you elaborate why?\n> \n- As Ed mentioned, we want to keep the interface and hardware communication in a single daemon. If we go DCMI route it will either involve changing DCMI code or to use `settings + power_cap` daemon\n- Also IIUC, DCMI is used for system wide power control. If there are multiple power-control components in the system, using EM + IPMI-SDR will be easier.\n- In our internal implementation, we have good support for writing SDRs from host side.\n\n> > To avoid breaking other targets by the change in IPMI SDR, I can add compiler flag for PowerCap interface related code in IPMI SDR path\n> \n> I'd prefer we refrain from making too many feature compile flags, unless those are enabled by default.  We're running into too many cases where code is \"good\" in the repository and then fails on some machine that has the compile flag enabled.  Alternatively you can make a runtime config that enables this feature on this machine (maybe something triggered by EM?)."
        },
        {
            "timestamp": 1630446730,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 6:\n\n> - As Ed mentioned, we want to keep the interface and hardware communication in a single daemon. If we go DCMI route it will either involve changing DCMI code or to use `settings + power_cap` daemon\n\nLike I said before, changing the DCMI code to use mapper is the right thing to do anyhow.  The fact that it is tied to a particular service name is a bug.  So this reason isn't particularly valid.\n\n> - Also IIUC, DCMI is used for system wide power control. If there are multiple power-control components in the system, using EM + IPMI-SDR will be easier.\n> - In our internal implementation, we have good support for writing SDRs from host side.\n\nI would be surprised if it is any harder to write a DCMI command compared to a SDR.  I don't know enough about DCMI to know if it can control power-control on multiple entities.\n\nYou're obviously welcome to do whatever you want to do on your system, but it seems odd to me to use SDRs for power capping and thus it likely will be foreign to most others as well.  Unless we document it well it seems like it's going to be confusing later on.\n\nIt seems like you have your reasons though.  I wanted to make sure that \"I don't want to fix DCMI\" wasn't the reason."
        },
        {
            "timestamp": 1630699372,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 6:\n\nPower cap is used in phosphor-settingsd and openpower-occ-control. \nI dont think this change breaks anything is these 2 places.\nhttps://github.com/openbmc/openpower-occ-control/blob/25613624cee19b8009f72cf30229d68e1fa7aa0a/powercap.cpp#L162\n\nAdded Deepak and Vishwanatha to the review (Maintainers of settingsd)"
        },
        {
            "timestamp": 1630700305,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 6:\n\n> Patch Set 6:\n> \n> > - As Ed mentioned, we want to keep the interface and hardware communication in a single daemon. If we go DCMI route it will either involve changing DCMI code or to use `settings + power_cap` daemon\n> \n> Like I said before, changing the DCMI code to use mapper is the right thing to do anyhow.  The fact that it is tied to a particular service name is a bug.  So this reason isn't particularly valid.\n> \n> > - Also IIUC, DCMI is used for system wide power control. If there are multiple power-control components in the system, using EM + IPMI-SDR will be easier.\n> > - In our internal implementation, we have good support for writing SDRs from host side.\n> \n> I would be surprised if it is any harder to write a DCMI command compared to a SDR.  I don't know enough about DCMI to know if it can control power-control on multiple entities.\n> \n> You're obviously welcome to do whatever you want to do on your system, but it seems odd to me to use SDRs for power capping and thus it likely will be foreign to most others as well.  Unless we document it well it seems like it's going to be confusing later on.\n\n@Patick, Where can we document the change in the interface and its intended use?"
        },
        {
            "timestamp": 1631118521,
            "reviewer": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "message": "Patch Set 6:\n\nPing"
        },
        {
            "timestamp": 1640220161,
            "reviewer": {
                "name": "Jason Ling",
                "email": "jasonling@google.com",
                "username": "jclaz"
            },
            "message": "Patch Set 6: Code-Review+1"
        },
        {
            "timestamp": 1640263535,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 6:\n\n@Matt, can you weigh in on this from IBM's perspective?  I think you know well who currently uses these Power.Cap interfaces."
        },
        {
            "timestamp": 1641316059,
            "reviewer": {
                "name": "Matt Spinler",
                "email": "spinler@us.ibm.com",
                "username": "spinler"
            },
            "message": "Patch Set 6: Code-Review+1\n\n(1 comment)"
        },
        {
            "timestamp": 1641316195,
            "reviewer": {
                "name": "Chris Cain",
                "email": "cjcain@us.ibm.com",
                "username": "cjcain"
            },
            "message": "Patch Set 6: Code-Review+1"
        },
        {
            "timestamp": 1641317923,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 6: Code-Review+2"
        },
        {
            "timestamp": 1641317926,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Change has been successfully rebased and submitted as ed708de3a629531dc2fdb8e70946fb24e112d617"
        }
    ],
    "patchSets": [
        {
            "number": 1,
            "revision": "2e11cb1342fdf62e785e9b238717577a952a0921",
            "parents": [
                "6f5241692eec25e7c90b7cfcb39940e8b8cde702"
            ],
            "ref": "refs/changes/57/46157/1",
            "uploader": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "createdOn": 1629843429,
            "author": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/COMMIT_MSG",
                    "line": 10,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "What is dynamic IPMI?  More details needed here.\n\nOne important piece of detail: considering you're changing an existing API, do you plan on fixing all the existing implementations of this API?  I'm guessing it's only a couple patchsets, but just something to be aware of for you."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 10,
                    "reviewer": {
                        "name": "Gaurav Gandhi",
                        "email": "gauravgandhi@google.com",
                        "username": "gauravgandhi70"
                    },
                    "message": "it should be phosphor-host-ipmid \n\nIIUC, even though I am adding 2 more properties to the interface, as long as the existing implementation do not need Min, Max values , I wont have to update existing APIs"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "line": 19,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Seems like a typo?"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "line": 19,
                    "reviewer": {
                        "name": "Gaurav Gandhi",
                        "email": "gauravgandhi@google.com",
                        "username": "gauravgandhi70"
                    },
                    "message": "Done"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "line": 23,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Presumably this would be PowerCap to match the casing of the property name?"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "line": 23,
                    "reviewer": {
                        "name": "Gaurav Gandhi",
                        "email": "gauravgandhi@google.com",
                        "username": "gauravgandhi70"
                    },
                    "message": "Done"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 12,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "type": "MODIFIED",
                    "insertions": 8,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 8,
            "sizeDeletions": 0
        },
        {
            "number": 2,
            "revision": "4dc9d0ed68c0e7d225ef7b5a42dc123c14685e4e",
            "parents": [
                "6f5241692eec25e7c90b7cfcb39940e8b8cde702"
            ],
            "ref": "refs/changes/57/46157/2",
            "uploader": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "createdOn": 1629844902,
            "author": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "line": 18,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Please add a default for these.  0 / max_int for min/max?"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "line": 18,
                    "reviewer": {
                        "name": "Gaurav Gandhi",
                        "email": "gauravgandhi@google.com",
                        "username": "gauravgandhi70"
                    },
                    "message": "Done"
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "line": 19,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "I suspect the polarity is wrong here?  \"MinPowerCapValue\" says \"Maximum\" in the description."
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "line": 19,
                    "reviewer": {
                        "name": "Gaurav Gandhi",
                        "email": "gauravgandhi@google.com",
                        "username": "gauravgandhi70"
                    },
                    "message": "Done"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 12,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "type": "MODIFIED",
                    "insertions": 8,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 8,
            "sizeDeletions": 0
        },
        {
            "number": 3,
            "revision": "27d81bac203a5db6cd1bfd4a7d9f7d1dc208d4f5",
            "parents": [
                "6f5241692eec25e7c90b7cfcb39940e8b8cde702"
            ],
            "ref": "refs/changes/57/46157/3",
            "uploader": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "createdOn": 1629860253,
            "author": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "line": 24,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Sorry, this is 'maxint' in sdbusplus and not 'max_int' like I wrote in my previous comment:\n\ndocs/interface.md:    * 'maxint' (case-insensitive)\ntools/sdbusplus/property.py:                if self.defaultValue.lower() == \"maxint\":"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 12,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "type": "MODIFIED",
                    "insertions": 10,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 10,
            "sizeDeletions": 0
        },
        {
            "number": 4,
            "revision": "a5086ee807b2da895de211509815ee4bd6346491",
            "parents": [
                "6f5241692eec25e7c90b7cfcb39940e8b8cde702"
            ],
            "ref": "refs/changes/57/46157/4",
            "uploader": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "createdOn": 1629915875,
            "author": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "kind": "NO_CHANGE",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 12,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "type": "MODIFIED",
                    "insertions": 10,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 10,
            "sizeDeletions": 0
        },
        {
            "number": 5,
            "revision": "d6e27dcfb44cec946c8a641cae47f2c39f55ce53",
            "parents": [
                "6f5241692eec25e7c90b7cfcb39940e8b8cde702"
            ],
            "ref": "refs/changes/57/46157/5",
            "uploader": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "createdOn": 1629915904,
            "author": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 12,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "type": "MODIFIED",
                    "insertions": 10,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 10,
            "sizeDeletions": 0
        },
        {
            "number": 6,
            "revision": "bb29ea15e8a0cdaf11259c7e586328209bc82b8d",
            "parents": [
                "3e9aa3b284d54a047e694b0eb4195b60396830d3"
            ],
            "ref": "refs/changes/57/46157/6",
            "uploader": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "createdOn": 1630360116,
            "author": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "kind": "TRIVIAL_REBASE",
            "comments": [
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Matt Spinler",
                        "email": "spinler@us.ibm.com",
                        "username": "spinler"
                    },
                    "message": "Looks good to me.  I think we also have upcoming work where we'll need to deal with dynamically set min/maxes, so this looks like a step in the right direction."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 12,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "type": "MODIFIED",
                    "insertions": 10,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 10,
            "sizeDeletions": 0
        },
        {
            "number": 7,
            "revision": "ed708de3a629531dc2fdb8e70946fb24e112d617",
            "parents": [
                "4f703341d9f9b1bf873d3aa93255573e9eb44bfa"
            ],
            "ref": "refs/changes/57/46157/7",
            "uploader": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "createdOn": 1641317926,
            "author": {
                "name": "Gaurav Gandhi",
                "email": "gauravgandhi@google.com",
                "username": "gauravgandhi70"
            },
            "kind": "TRIVIAL_REBASE",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 12,
                    "deletions": 0
                },
                {
                    "file": "yaml/xyz/openbmc_project/Control/Power/Cap.interface.yaml",
                    "type": "MODIFIED",
                    "insertions": 10,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 10,
            "sizeDeletions": 0
        }
    ]
}