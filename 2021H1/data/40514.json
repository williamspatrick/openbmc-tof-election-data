{
    "project": "openbmc/docs",
    "branch": "master",
    "id": "Ia7b7e51c7528b08941c2811b94f4775c51031efb",
    "number": 40514,
    "subject": "mctp: Add initial kernel MCTP design definition",
    "owner": {
        "name": "Jeremy Kerr",
        "email": "jk@ozlabs.org",
        "username": "jk-ozlabs"
    },
    "url": "https://gerrit.openbmc-project.xyz/c/openbmc/docs/+/40514",
    "commitMessage": "mctp: Add initial kernel MCTP design definition\n\nCovering network & interface representation, sockets API implementation\nand configuration interface.\n\nSigned-off-by: Jeremy Kerr <jk@codeconstruct.com.au>\nChange-Id: Ia7b7e51c7528b08941c2811b94f4775c51031efb\n",
    "createdOn": 1613032626,
    "lastUpdated": 1615269362,
    "open": false,
    "status": "MERGED",
    "comments": [
        {
            "timestamp": 1613032626,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 1."
        },
        {
            "timestamp": 1613032771,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 1:\n\nHey all, this is the first cut of an in-kernel MCTP design. Let me know if you have any comments/queries/etc.\n\nCheers!"
        },
        {
            "timestamp": 1613089861,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 1:\n\n(6 comments)\n\nNice work!"
        },
        {
            "timestamp": 1613101021,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(5 comments)"
        },
        {
            "timestamp": 1613101170,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)\n\nThanks for putting this design up!"
        },
        {
            "timestamp": 1613101341,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1613104501,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 1:\n\n(13 comments)\n\nThanks for the reviews! A few replies to comments; some TODOs for me to update in the design. New version coming shortly."
        },
        {
            "timestamp": 1613108328,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 2."
        },
        {
            "timestamp": 1613108344,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 1:\n\n(8 comments)"
        },
        {
            "timestamp": 1613121303,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 2: Code-Review+1\n\n(2 comments)"
        },
        {
            "timestamp": 1613127675,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 2: Code-Review+1\n\nThanks for adding the section about mctpd."
        },
        {
            "timestamp": 1613543748,
            "reviewer": {
                "name": "Joel Stanley",
                "email": "joel@jms.id.au",
                "username": "shenki"
            },
            "message": "Patch Set 2:\n\n(3 comments)"
        },
        {
            "timestamp": 1613546299,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 2:\n\n(3 comments)"
        },
        {
            "timestamp": 1613547242,
            "reviewer": {
                "name": "Joel Stanley",
                "email": "joel@jms.id.au",
                "username": "shenki"
            },
            "message": "Patch Set 2:\n\n(3 comments)"
        },
        {
            "timestamp": 1613557826,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1613608725,
            "reviewer": {
                "name": "Joel Stanley",
                "email": "joel@jms.id.au",
                "username": "shenki"
            },
            "message": "Patch Set 2: Code-Review+1\n\n(1 comment)"
        },
        {
            "timestamp": 1613698756,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1613698771,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 3."
        },
        {
            "timestamp": 1613699870,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 3:\n\nHi all,\n\nPatchset 3 pushed; this fixes an issue with tag allocation behaviour.\n\nI've also shifted to including the message type byte in TX/RX buffers. The potential for variance in type and IC implementations for higher-level protocols means that it's not really feasible for the kernel to handle these. This cascades to moving the type spec from the socket() protocol argument to struct sockaddr_mctp.\n\nI've also made some changes based on recent review, and a few minor clarifications & fixes.\n\nThanks!"
        },
        {
            "timestamp": 1613715327,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 3:\n\n(9 comments)"
        },
        {
            "timestamp": 1613716355,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1613722985,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 4."
        },
        {
            "timestamp": 1613723024,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 4:\n\n(8 comments)\n\nThanks for the review; responses inline, and some updates in patchset 4."
        },
        {
            "timestamp": 1613728171,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 4:\n\n(12 comments)"
        },
        {
            "timestamp": 1613933656,
            "reviewer": {
                "name": "Iwona Winiarska",
                "email": "iwona.winiarska@intel.com",
                "username": "iklm"
            },
            "message": "Patch Set 4:\n\n(8 comments)"
        },
        {
            "timestamp": 1613967150,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 4:\n\n(13 comments)\n\nThanks for the reviews all; PS5 coming, which incorporates feedback from these. Let me know if you have any follow-ups from that."
        },
        {
            "timestamp": 1613967224,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 5."
        },
        {
            "timestamp": 1613985248,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 5:\n\n(12 comments)\n\nOverall this looks good to me, and ok to clarify it in separate commit too. \nNote: \nFollowing things needs to be planned as well. \n\n1. Support for SPDM & secure Message type.\ni.e. SPDM daemon can handle the message types, but it would be better for the SPDM to configure the session details to the kernel, such that kernel can use the same for further transmit / receive of the secure MCTP messages (This will ease up the load). \n\n2. NULL EID clarifications or MCTP Message communication with Null EID communication (Don't find any issue, as long as the physical interface device address is clarified - you already provided a way)."
        },
        {
            "timestamp": 1613987360,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 5:\n\n(9 comments)"
        },
        {
            "timestamp": 1614038679,
            "reviewer": {
                "name": "Iwona Winiarska",
                "email": "iwona.winiarska@intel.com",
                "username": "iklm"
            },
            "message": "Patch Set 5:\n\n(6 comments)"
        },
        {
            "timestamp": 1614055833,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1614057918,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 6."
        },
        {
            "timestamp": 1614057962,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 6:\n\n(8 comments)\n\nThanks for the continued reviews, all. I've pushed PS5 with some updates, and replied to comments."
        },
        {
            "timestamp": 1614059574,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 6:\n\n(1 comment)"
        },
        {
            "timestamp": 1614115012,
            "reviewer": {
                "name": "Iwona Winiarska",
                "email": "iwona.winiarska@intel.com",
                "username": "iklm"
            },
            "message": "Patch Set 6:\n\n(1 comment)\n\nIt's looks like patch set 6 reverted some changes from patch set 5."
        },
        {
            "timestamp": 1614124798,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 6:\n\n(1 comment)"
        },
        {
            "timestamp": 1614134125,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 6:\n\n> It's looks like patch set 6 reverted some changes from patch set 5.\n\nD'oh, that's just me pushing from an out-of-date tree. PS7 coming with no changes other than addressing this."
        },
        {
            "timestamp": 1614134134,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 7."
        },
        {
            "timestamp": 1614136240,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 7:\n\n(1 comment)"
        },
        {
            "timestamp": 1614207374,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 7:\n\n(1 comment)"
        },
        {
            "timestamp": 1614211364,
            "reviewer": {
                "name": "Iwona Winiarska",
                "email": "iwona.winiarska@intel.com",
                "username": "iklm"
            },
            "message": "Patch Set 7:\n\n(3 comments)"
        },
        {
            "timestamp": 1614215728,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 7:\n\n(1 comment)"
        },
        {
            "timestamp": 1614219118,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 7:\n\n(1 comment)"
        },
        {
            "timestamp": 1614220034,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 8."
        },
        {
            "timestamp": 1614234990,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 8:\n\n(3 comments)"
        },
        {
            "timestamp": 1614238940,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 8:\n\n(3 comments)"
        },
        {
            "timestamp": 1614244450,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 8:\n\n(2 comments)"
        },
        {
            "timestamp": 1614303611,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 9."
        },
        {
            "timestamp": 1614313760,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 9:\n\n(6 comments)\n\nI think we're getting there! I've decided to write up a forwards-compatibility concern I've had low-key nagging me about the tag value for bind(). It's good bikeshed fodder. Other than that I'd be happy to submit it as is."
        },
        {
            "timestamp": 1614320740,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 9:\n\n(4 comments)\n\nThanks for the comments, PS10 coming right up."
        },
        {
            "timestamp": 1614320758,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 10."
        },
        {
            "timestamp": 1614330483,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 10:\n\n(2 comments)"
        },
        {
            "timestamp": 1614334587,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 10:\n\n(1 comment)"
        },
        {
            "timestamp": 1614334630,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 10:\n\n(1 comment)"
        },
        {
            "timestamp": 1614565578,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 11."
        },
        {
            "timestamp": 1614565638,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 11:\n\n(1 comment)"
        },
        {
            "timestamp": 1614569974,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 11: Code-Review+1"
        },
        {
            "timestamp": 1614815036,
            "reviewer": {
                "name": "Iwona Winiarska",
                "email": "iwona.winiarska@intel.com",
                "username": "iklm"
            },
            "message": "Patch Set 11: Code-Review+1"
        },
        {
            "timestamp": 1614822591,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 11:\n\n(1 comment)"
        },
        {
            "timestamp": 1614824553,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Uploaded patch set 12."
        },
        {
            "timestamp": 1614824601,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 12:\n\n(1 comment)"
        },
        {
            "timestamp": 1614825780,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 12: Code-Review+1"
        },
        {
            "timestamp": 1614850187,
            "reviewer": {
                "name": "Iwona Winiarska",
                "email": "iwona.winiarska@intel.com",
                "username": "iklm"
            },
            "message": "Patch Set 12: Code-Review+1"
        },
        {
            "timestamp": 1614859601,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 12: Code-Review+1\n\n(7 comments)\n\nThere are few nit comments / discussions required, but i still prefer this review to merged, and as part of implementational discussion, to address those and update this document separately."
        },
        {
            "timestamp": 1614865194,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 12:\n\n(7 comments)"
        },
        {
            "timestamp": 1614917553,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 12:\n\n(4 comments)\n\nThanks for the reviews, Richard, I appreciate the time! Andrew has covered most of the comments, just a few replies inline.\n\nIf there's any tweaks we need as a result, I think the best approach is for a future change, as there's no fundamental issues as yet."
        },
        {
            "timestamp": 1615159265,
            "reviewer": {
                "name": "Rui Zhang",
                "email": "ruizhan@google.com",
                "username": "ruiz-go"
            },
            "message": "Patch Set 12: Code-Review+1\n\nNice work, Jeremy!"
        },
        {
            "timestamp": 1615193297,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 12:\n\n(7 comments)"
        },
        {
            "timestamp": 1615250350,
            "reviewer": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "message": "Patch Set 12:\n\nLooks like we're OK to submit - any objections?"
        },
        {
            "timestamp": 1615265180,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 12:\n\n> Patch Set 12:\n> \n> Looks like we're OK to submit - any objections?\n\nYes Jeremy, Please merge the same."
        },
        {
            "timestamp": 1615269352,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 12: Code-Review+2\n\nLooks like this has a good set of feedback. I did not review directly but the team seems to have reached a fine consensus. Merging as is."
        },
        {
            "timestamp": 1615269358,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 12: Verified+1"
        },
        {
            "timestamp": 1615269362,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Change has been successfully merged by Patrick Williams"
        }
    ],
    "patchSets": [
        {
            "number": 1,
            "revision": "da77a8a2d94a93dfb5f46420727d94aeda157c7a",
            "parents": [
                "514ea474b4d09c503ed39f6b3298436732b7c90e"
            ],
            "ref": "refs/changes/14/40514/1",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1613032626,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 64,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Would be possible to attach a local (loopback) test unit to this as well?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 64,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yep, that's why I've added 'likely' there, to allow for non-hardware-backed interfaces, like lookback."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 64,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 66,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Why is this needed and is this related to the MCTP EID?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 66,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "All net devices have an system-unique index, and may be used in addressing data elsewhere (see struct sockaddr_mctp_ext here, and struct sockaddr_ll). It's unrelated to the EID."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 70,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Why are both required?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 70,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Andrew has raised this a little in his comment, and I'll add a section in the alternatives for this. Basically, a UUID is required by the spec, but fairly difficult to handle for inclusion in every `struct sockaddr_mctp`, so I'm proposing an integer to allow references to a particular network.\n\nIf that creates problems though, we can look at using UUIDs directly. It'll mean that we overrun the size of `struct sockaddr`, but I think that might be OK."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 70,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "I've added wording on this to the Alternatives section, but let me know if that doesn't address your concern."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 97,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Section 7 of DSP0236 says:\n\n> MCTP is designed to be able to transfer multiple Message Types in an interleaved manner using the same protocol. MCTP Message Types identified using a Message Type number. The use of the message type number is similar to a well-known port number in Internet Protocol. It identifies MCTP Messages that are all associated with a particular specification.\n\nI think we should include an \"Alternatives Considered\" section that discusses why we're not using a port-based representation."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 97,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Should MCTP_PROTO_ANY used for MCTP VDM messages, or for some other purpose?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 97,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yep, any application that sends/receives messages that the kernel does not have a protocol handler will need to use MCTP_PROTO_ANY, otherwise the socket() call would fail. This would include vendor-defined message formats."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 97,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yep, good plan."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 97,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 388,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Solid nit-pick: This should be `addr.smctp_addr.s_addr = 9;` according to your earlier struct definitions."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 388,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Good catch, and brings up a decent design question on whether or not we have s_addr as its own type, or just put the uint8_t directly in struct sockaddr_mctp. There's slightly more precedence for the former, but both do exist in other protocol implementations."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 388,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 433,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Again with .s_addr?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 433,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 433,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 491,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "The example should probably use connect() as discussed elsewhere."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 491,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "In this case, we're only sending one broadcast message, so there's no benefit to connect(). I will add a comment to indicate that for other cases you'd probably want connect() too."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 491,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 491,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 572,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Maybe I need to re-read, but I'm not following how MCTP discovery (Section 8.14 of DSP0236) would occur - what is expected out of userspace? For eg consider a scenario where several devices (endpoints and/or bridges) are connected to a BMC - how does userspace go about discovering if these are MCTP-devices, and then assigning EIDs to them? I understand some of that has to be done by a userspace daemon, but it would be nice to have an example section/flow on that same in this document on MCTP discovery."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 572,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "The entire control protocol would be handled by userspace, yes. The kernel does not have any knowledge of EID pools, or EID allocations to other machines - only the routing table. This is covered briefly at line 50.\n\nThe facilities are present to enable a userspace process access to the relevant MCTP stack data though; a control message implementation would use MCTP_ADDR_EXT for low-level addressing data, and would be updating the route table through the netlink interface. I'll add an overview of a proposed userspace implementation to this document."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 572,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 583,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "The network UUID gets a brief mention earlier, and it appears to not be what we're using for `smctp_network`. Can you talk about the trade-offs between using a mapping and not? It feels like ergonomics and UX vs implementation concepts that aren't part of the spec and the added mapping between kernel network IDs and UUIDs.\n\nProbably another thing for the Alternatives Considered section?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 583,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yep, sounds good, I'll add that."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 583,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 660,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Have you considered whether/where we should store device UUIDs?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 660,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Is this how for eg an SMBus device address would be populated? Would you be able to provide binding specific examples for this configuration in the utilities section below?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 660,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "The bus-physical address goes there, yes. The method of populating it is covered in the next paragraph, or are you after other details? None of that is really binding-specific, other than that the binding provides that information."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 660,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yup. None of the transport-level addressing requires a UUID, so I'm fine to leave that to the userspace control protocol implementation. Unless you have other requirements on this?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 660,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Nope, no requirements. Was just curious."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 681,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "This command is typically sent to the bus-owner (which is usually the BMC)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 681,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yep - in fact the spec requires it to be sent to the bus owner.\n\nI'm not restricting this design to BMC implementations - it may be used for bridges, simple endpoints, etc, some of which may not be the bus owner."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 736,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 738,
            "sizeDeletions": 1
        },
        {
            "number": 2,
            "revision": "06605e87cdeac828de59bc93356c78bd44487a2d",
            "parents": [
                "514ea474b4d09c503ed39f6b3298436732b7c90e"
            ],
            "ref": "refs/changes/14/40514/2",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1613108328,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 5,
                    "reviewer": {
                        "name": "Joel Stanley",
                        "email": "joel@jms.id.au",
                        "username": "shenki"
                    },
                    "message": "This is the first time I've reviewed a design document that includes images using gerrit. It's not a good experience.\n\nShould we have a text link at the top of documents \"read the current version of this doc here\" and links to https://github.com/openbmc/docs/blob/master/designs/mctp.md?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 5,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "But this document doesn't have any images \ud83d\ude0a\n\nI'm not sure that would help in the most useful case though, where the proposed change actually adds (or alters) the image, as that won't be reflected in the \"current version\" link. I suspect it's just something we'd have to deal with as a consequence of using gerrit for review."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 5,
                    "reviewer": {
                        "name": "Joel Stanley",
                        "email": "joel@jms.id.au",
                        "username": "shenki"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 18,
                    "reviewer": {
                        "name": "Joel Stanley",
                        "email": "joel@jms.id.au",
                        "username": "shenki"
                    },
                    "message": "Can you remind us what an EID is in this doc?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 18,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Good call, I'll introduce the acronym on first usage."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 18,
                    "reviewer": {
                        "name": "Joel Stanley",
                        "email": "joel@jms.id.au",
                        "username": "shenki"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 26,
                    "reviewer": {
                        "name": "Joel Stanley",
                        "email": "joel@jms.id.au",
                        "username": "shenki"
                    },
                    "message": "Having read the document, I understand the socket interface for mctp messages, and I realise that the most common use of the socket API is talking to network devices. I am missing the bit that links mctp to network devices.\n\nMy confusion comes about because I thought we were generally talking about sending mctp over devices other than network (Ethernet) devices? Does this mean we will have network drivers that instead of Ethernet are backed by eg a LPC device?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 26,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "> Having read the document, I understand the socket interface for mctp messages, and I realise that the most common use of the socket API is talking to network devices.\n\nSort of - there are many protocol families that the socket API supports - AF_INET and AF_INET6 being the most common, but there's a whole bunch more that aren't related to the kind of \"networks\" you're referring to, like Unix-domain sockets (AF_UNIX), CAN bus (AF_CAN), bluetooth (AF_BLUETOOTH) and the kernel-internal netlink messaging (AF_NETLINK).\n\nHere we'd introduce a new address/protocol family, AF_MCTP.\n\n> I am missing the bit that links mctp to network devices.\n\nThat kinda depends on what you're calling a \"network device\"; we're still complying with that here in that the MCTP networks will be represented by a `struct net_device`.\n\nHowever, that's distinct from the implication that these will be the kind of network devices that carry IP/ethernet/etc packets; `struct net_device`s are used for non-\"networky\" endpoints too; bluetooth, CAN, etc.\n\n> My confusion comes about because I thought we were generally talking about sending mctp over devices other than network (Ethernet) devices? Does this mean we will have network drivers that instead of Ethernet are backed by eg a LPC device?\n\nThe MCTP devices mentioned here won't be in the same set as your traditional network devices; much like your bluetooth endpoints (eg \"hci0\") don't appear in those sets either.\n\nThis spec doesn't define any interaction between ethernet/ip/etc-style networks and MCTP networks."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 26,
                    "reviewer": {
                        "name": "Joel Stanley",
                        "email": "joel@jms.id.au",
                        "username": "shenki"
                    },
                    "message": "> > My confusion comes about because I thought we were generally talking about sending mctp over devices other than network (Ethernet) devices? Does this mean we will have network drivers that instead of Ethernet are backed by eg a LPC device?\n> \n> The MCTP devices mentioned here won't be in the same set as your traditional network devices; much like your bluetooth endpoints (eg \"hci0\") don't appear in those sets either.\n> \n> This spec doesn't define any interaction between ethernet/ip/etc-style networks and MCTP networks.\n\nThanks for the explanation.\n\nDo you mean this to say that you expect AF_MCTP to work (and be used) over any struct net_device, or is it intended for your specific lpc/pcie/pigeon interfaces?\n\nI think you could clarify if you're proposing/designing those drivers in this document, or if you wish to keep this just about the mctp address/protocol family? (What struct net_device do you plan to test with?)"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 26,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "> Do you mean this to say that you expect AF_MCTP to work (and be used) over any struct net_device, or is it intended for your specific lpc/pcie/pigeon interfaces?\n\nYes, the latter; we are only able to use AF_MCTP sockets to communicate to MCTP-specific netdevices.\n\n[I say that now, but it's entirely possible that someone wants an MCTP-over-{ethernet,ip,whatever} implementation in future. In that case, there'd still be a MCTP-specific netdevice to represent the tunnel; we wouldn't be leaking \"actual\" network devices into the set of MCTP-specific ones]\n\n> I think you could clarify if you're proposing/designing those drivers in this document, or if you wish to keep this just about the mctp address/protocol family? (What struct net_device do you plan to test with?)\n\nYep, that sounds good to clarify; I'll add a little about the interface implementations. I do want to focus on the sockets API here, but that interface context would definitely help. I'll add that in the next patchset.\n\n(The first net_device would be a MCTP loopback interface; I suspect serial and i2c bindings would be the next. Let's see if we can convince Andrew to do an astlpc one \ud83d\ude04)"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 26,
                    "reviewer": {
                        "name": "Joel Stanley",
                        "email": "joel@jms.id.au",
                        "username": "shenki"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 630,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "aaaaand this cannot work for certain protocols working on top of MCTP. New patchset coming."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 801,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 803,
            "sizeDeletions": 1
        },
        {
            "number": 3,
            "revision": "7214b38515619e8c4f947a4682674d1071905654",
            "parents": [
                "514ea474b4d09c503ed39f6b3298436732b7c90e"
            ],
            "ref": "refs/changes/14/40514/3",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1613698771,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 125,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "smctp"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 125,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "you'd think I'd have learnt to type that by now \ud83d\ude0a thanks, fixed."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 130,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Define it before use? :)"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 130,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yeah, I think it's more important to introduce the `struct sockaddr_mctp` first (as it's the focus here), rather than have this document be compile-able. Happy to change though."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 130,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 296,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Can you clarify this sentence?\n\nSo the tag allocated on connect() won't be dropped until close() or another connect() as I understand it.\n\nWhat's the behaviour of the tag allocated for the sendto()/sendmsg() after connect? I think you're proposing it's retained until another sendto()/sendmsg(), so we're accumulating tags in the set associated with the socket in the manner that's suggested by `setsockopt(..., MCTP_TAG_CONTROL, ...)` without calling `setsockopt()`?\n\nHow does `setsockopt(..., MCTP_TAG_CONTROL, ...)` behave in the connect()-then-(sendto()/sendmsg()) case? I guess it only applies to the tag allocated with the most recent sendto()/sendmsg() call? This is partially a question about whether we should explicitly include the tag we want to control in the struct associated with MCTP_TAG_CONTROL. However, we would have to extract that information using getsockname() in order to provided it back to setsockopt(), so maybe that's not a good idea?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 296,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "My intention for any sendto after connect (using a different dest EID) is to be the same case as when no connect() was called earlier: the sendto disregards the tag allocated by connect, and also does not invalidate it.\n\nLike the non-connected sendto-case, any tag allocated here would also be subject to the same invalidation logic, either on timeout or by a further sendto.\n\nI think the `MCTP_TAG_CONTROL` sockopt might have caused some confusion there, which I'll address below."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 296,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> Like the non-connected sendto-case, any tag allocated here would also be subject to the same invalidation logic, either on timeout or by a further sendto.\n\nRight, the behaviour in the connected sendto-case was what I was trying to wrap my head around.\n\n> \n> I think the `MCTP_TAG_CONTROL` sockopt might have caused some confusion there, which I'll address below.\n\nThanks."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 400,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Ah wait! I think I was tripped up on the interpretation of this sentence with its use of \"previous\". I read it as ordering setsockopt() after sendmsg(), but that's not the intent at all. Instead the expected sequence is:\n\n sock = socket(...);\n setsockopt(..., MCTP_TAG_CONTROL, ...);\n sendmsg(...);\n sendmsg(...);\n\nand for all sendmsg() calls the tags are accumulated against the socket."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 400,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 590,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Should we be setting a timeout via setsockopt(..., MCTP_TAG_CONTROL, ...) so that the broadcast tag can be released without close()?\n\nActually, do we have a way to learn that a tag configured to expire via MCTP_TAG_CONTROL has in fact expired?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 590,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> Should we be setting a timeout via setsockopt(..., MCTP_TAG_CONTROL, ...) so that the broadcast tag can be released without close()?\n\nNo, PS4 clarifies there's a default (longish) timeout.\n\n> \n> Actually, do we have a way to learn that a tag configured to expire via MCTP_TAG_CONTROL has in fact expired?\n\nThis is unnecessary as userspace should be aware of the required timeouts and use appropriate APIs to enforce them."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 655,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I find the use of 'endpoint' and 'source address' unclear here. DSP0236 defines the message terminus as the (Message Tag, Tag Owner, Source Endpoint ID) tuple in 8.5. To use DSP0236-style terminology, by 'endpoint' do you mean 'Destination Endpoint ID' and 'source address' to mean 'Source Endpoint ID'?\n\nAlso given that the smctp_tag member of struct sockaddr_mctp includes the TO bit, without thinking too much it feels unclear whether the use of 'tag' here includes the TO bit (in the manner of the message terminus definition). The following sentence suggests it's excluded. Maybe using 'tag value' in the tuple description is an improvement?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 655,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "yeah, just me being lazy and not explicitly including TO there. I'll fix that up."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 664,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "even to a destination that we connect()ed to prior to sendto()? Or just another non-connected sendto()?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 664,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "this paragraph only covers the sendto() behaviour, not connect()ed sockets."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 664,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 665,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "... if set by `setsockopt(sock, 0, MCTP_TAG_CONTROL, ...);`"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 665,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "not in this case; the timeout always applies (but may be modified by MCTP_TAG_CONTROL). I'll make that more explicit in the doc."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 665,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 834,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Broken line wrap here.\n\nHowever, we're still considering the idea of protocols to handle the message-type/integrity-check data, right? Is that worth mentioning here?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 834,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "> Broken line wrap here.\n\nCaused by the unclosed bracket. Is this the first time vim cindent mode has been useful for a markdown doc? \ud83d\ude04\n\n> However, we're still considering the idea of protocols to handle the message-type/integrity-check data, right? Is that worth mentioning here?\n\nYep, definitely, I'll add that."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 892,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I think it's a good idea to provide explicit examples here, e.g:\n\n* MCTP broadcasts\n* NVMe repeat last message"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 892,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Good point, will add."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 892,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Ack"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 894,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 896,
            "sizeDeletions": 1
        },
        {
            "number": 4,
            "revision": "2a4411590d12f1acaf7afe1763760af41e0ac84b",
            "parents": [
                "514ea474b4d09c503ed39f6b3298436732b7c90e"
            ],
            "ref": "refs/changes/14/40514/4",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1613722985,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 26,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Better to remove \"(non-bridged)\" here (I believe your intention is to say that different networks bridging is not allowed).\n\nBut inside the distinct network there can be bridge too (inside that network system)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 26,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "how about I change this to \"(ie., non-bridged)\" ?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 29,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Each network can have multiple physical interfaces too. \n\nI meant, BMC to PCIe Add-on controller can have I2C, and Add-on-controller FW can have it's own Network to query lot of information internally, and can have I2C, Serial, I3C etc."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 29,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> Each network can have multiple physical interfaces too. \n> \n\nThis is covered by the bullet on line 23 right?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 32,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "We do consider the possibility of acting as a bridge.\nI'm aware that MCTP bridge == router, and this matches \"customizable routing configurations within a network\", but it's worth spelling this out explicitly here."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 32,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yep, good point, I'll be explicit about the bridging too."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 32,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Between network bridging is not allowed. Only inside that network it is allowed."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 32,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Richard, I'm reading this part of the document as our actual use cases, so I don't think we should include the \"between network bridging is not allowed\" statement here, unless we have a strong requirement for keeping this inside the kernel (do we?).\n\nDo we even have enough knowledge inside the kernel to prevent userspace from creating potentially invalid routing configurations?\nBecause I don't think we do, and I don't thing we need to. I think it's similar to allowing userspace to assign a potentially invalid (not assigned by actual bus owner, and not part of \"static\" assignment bus owner point of view) EID to our NIC.\nIn this design, kernel side is just responsible for transport (delivering correct messages to correct sockets, routing) and abstracting away the medium-specific differences. We can't validate anything, since we don't implement control protocol. And I do believe this is completely fine (and similar to other in-kernel network protocols), as long as we only allow network configuration to be done by \"trusted\" userspace (think root, or CAP_NET_ADMIN)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 33,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "From the above, I infer that Infrastructure configuration for the following will be supported and expect it should be our goal.\n1. MCTP device acting like a static / dynamic Endpoint\n2. MCTP device acting like B.O and using the programmable EID Pool, or EID pool queried from Topmost B.O.\n(In this providing mechanism to detect new device presence or reset using physical interface logic or through MCTP protocol logic (discovery)).\n3. MCTP device acting as Topmost B.O.\n4. MCTP device working in multiple physical interfaces & providing Bridging functionality within that network\n5. MCTP device in multiple network (multiple sub-system)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 33,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Yes, all of these cases should be supported."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 33,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 56,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "We don't include discovery code in-kernel, right? We just leave it up to the userspace (as described in \"MCTP Control Protocol implementation\" and \"Neighbour and routing implementation\" sections).\nPerhaps you just mean endpoints with static EID here? It's worth spelling it out explicitly."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 56,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yes, that's correct - discovery would be implemented in mctpd. I'll include the 'static' qualifier there."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 56,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "How about handling all MCTP control through MCTPD process in first phase & in later phase for better optimization simple commands can be responded (say responding GetEID / GetMCTP message types) etc. with options for MCTPD to configure it in kernel.\n\nI see following is specified to be covered in Kernel\n\n1. MCTP packets assembly / disassembly and accordingly forwarding / receiving to/from user space based on Message Type. \n2. MCTP bridge, and forwarding the packet directly in kernel\n3. Kernel providing configuration facility such that MCTPD process / configuration is sent to Kernel (related to network, Endpoint or Bridge-B.O (or Topmost) - using static EID / EID Pool / dynamic query etc.) with multiple network.\n\nAny way for Peer-to-peer setting static EID configuration is fine and none of the MCTP control packet message needs to be handled?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 56,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> How about handling all MCTP control through MCTPD process in first phase & in later phase for better optimization simple commands can be responded (say responding GetEID / GetMCTP message types) etc. with options for MCTPD to configure it in kernel.\n\nI'd want to see evidence of needing the lower latency before pushing more complexity into the kernel."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 56,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yes, we're not excluding an in-kernel control protocol implementation, I just don't cover it here, nor do I see a need for it just yet.\n\nWe can certainly add a new design for that in future, if the need arises."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 56,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Let's keep the kernel side responsibilities as small as possible for the initial submission. Thanks for addressing my comment about static EIDs."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 114,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "We operate directly at the transport layer (L3), and yet we expose the type (L4) both in the address and in the packet. If we include IC bit in the address, we could drop message type byte (with IC bit) from the messages exposed to userspace. The integrity check at the end is problematic. We're still not separating the layers clearly (because it's not fully defined in L4 and depends on L5 - we'd need to have knowledge of all L5 protocols in kernel in order to compute the integrity... and as you already mentioned elsewhere in this document - we don't want to do that), but at least we're only leaking the \"trailer\" part of L4 and we won't need to check whether first byte of every sent message matches what's in the address.\n\nIncluding a drawing as reference for further comments:\n \n+---------------------------------------------------+\n|              medium specific header (L2)          |\n+---------------------------------------------------+\n|               transport header (L3)               |\n+-------------+-------------------------------------+\n|msg type (L4)|     message (L5)                    |\n+-------------+                      +--------------+\n|                                    | msg IC (L4)  |\n+------------------------------------+--------------+\n|            medium specific trailer (L2)           |\n+---------------------------------------------------+"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 114,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "I've been considering a lot of options here; as you've mentioned, there's a bit of difficulty here in that there's a bit of cross-layer dependencies as defined in the spec. I like your diagram, thanks for that!\n\nI would really prefer for the kernel to strip the message type byte, as it's redundant if we're also including it in the addressing information, and slightly more onerous for the applications to have to handle it themselves.\n\nDespite this though, I don't think that the other options are an improvement. If we're stripping the msg type byte, but not the IC, then the kernel interface is half-L3, half-L4.\n\nSo, having the kernel/userspace boundary correspond to the L3/L4 boundary seems to be the neatest approach. This has the advantage of corresponding to how the L5 specs are written - they all include the message type & IC bytes in their message descriptions.\n\nKeep in mind too that the message type specification may be larger than a byte; the vendor-defined types will be up to 5 bytes long. If we can avoid splitting those up, that would be slightly better.\n\nIf we do find a neat way to strip the message-type byte, I'd be keen to adopt it, but all my approaches so far have just involved a whole lot of layering-violations!\n\nMy intention for allowing the kernel to work on the layer-4 data is by adding specific protocol support, via the 'protocol' option to socket(), allowing L4-specific message handling, which may handle the type and IC as required for that protocol. Those implementations aren't covered by this though, so I don't want to specify too much there."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 114,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Ack (we can go back to this during implementation)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 125,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "I understand that we need to expose tag owner bit to the userspace, but what's the requirement for exposing the tag value?\nYou mention that \"If the `MCTP_TAG_OWNER` bit is set in this field, the `MCTP_TAG_VALUE`\nbits are ignored, and will be set by the kernel.\".\nWhat's the point of populating it on the receive side? In other words - how is userspace expected to use this information?\nDo we have a use case where both sides are using TO=0 and using TAGs to match requests and responses? Or is it something else entirely?\nIf it's not needed, perhaps we could keep this limited to tag-owner bit?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 125,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "> I understand that we need to expose tag owner bit to the userspace, but what's the requirement for exposing the tag value?\n> What's the point of populating it on the receive side? In other words - how is userspace expected to use this information?\n\nUserspace needs to specify the tag value of an outgoing TO=0 message.\n\nConsider a responder, performing a recvmsg() to receive incoming requests. Those request messages will have TO=1, and a tag value generated by the remote peer.\n\nThe responder is required to use the same tag value in the response; so it will pass the incoming tag value, but with TO=0, to the sendmsg() call to transmit the reply. The kernel will transmit this message with the TO and tag value as-is.\n\nEssentially, we need some way for userspace to provide an outgoing TO=0 value, which comes from the original request. So, the struct sockaddr_mctp needs to provide this on the receive side.\n\nBecause there may be multiple requests in-flight, the kernel cannot handle the outgoing tag values automatically; only userspace has the knowledge of which responses correspond to which requests.\n\n> Do we have a use case where both sides are using TO=0 and using TAGs to match requests and responses?\n\nThe tag value needs to come from somewhere, so I can't see how both sides using TO=0 would be possible...\n\n> If it's not needed, perhaps we could keep this limited to tag-owner bit?\n\nI can't see a way to avoid needing it."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 125,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Thanks for the explanation. I thought about using ordering - but that doesn't make sense, we don't strictly require response for each request."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 179,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "nit: typo smctp_addr"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 179,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 185,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Are we also going to only send messages with TO bit clear (responses) through the bound socket?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 185,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Not necessarily; it's still possible to send TO=1 messages through that bound socket. This will elicit the same behaviour as any other TO=1 transmit.\n\n[it doesn't sound like a fantastic idea, but no specific reason for the kernel to forbid it]"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 185,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 199,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "I understand the need for *ANY* on network and source address, but what's the use case for *ANY* type?\n\nIt feels like we're trying to fit all of the MCTP layers inside a single protocol.\nIf we're implementing MCTP L4 - we should leave \"MCTP_TYPE_ANY\" to clients that operate directly on L3, similar to how there's no \"TCP/UDP wildcard\" for listening on all ports.\nI guess in our case a catch-all type would also mean implementing SOCK_RAW? Or we could also express that using protocol field?\n\nFor example:\n    struct sockaddr_mctp addr;\n\n    int sd = socket(AF_MCTP, SOCK_DGRAM, 0);\n    addr.smctp_network = MCTP_NET_ANY;\n    addr.smctp_addr.s_addr = MCTP_ADDR_ANY;\n    addr.smctp_type = MCTP_TYPE_ANY;\n    int rc = bind(sd, (struct sockaddr *)&addr, sizeof(addr));\n\nCould become:\n    struct sockaddr_mctp addr;\n\n    int sd = socket(AF_MCTP, SOCK_DGRAM, MCTPPROTO_L3);\n    /* Or socket(AF_MCTP, SOCK_RAW, 0) */\n    addr.smctp_network = MCTP_NET_ANY;\n    addr.smctp_addr.s_addr = MCTP_ADDR_ANY;\n    /* This would be ignored by the kernel: addr.smctp_type = MCTP_TYPE_ANY; */\n    int rc = bind(sd, (struct sockaddr *)&addr, sizeof(addr));\n\nThe userspace would need to deal with handling the full transport (L3) header. And we can also require CAP_NET_RAW, similar to IP protocol."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 199,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "A potential use-case for the ANY type is to allow a single application to handle all MCTP traffic. I wouldn't encourage the design, but some folks may find it useful.\n\nMy original intention for SOCK_RAW was for packet-level headers, but that's probably better handled by a packet socket instead.\n\nWe could instead do this with SOCK_RAW, yes; I'm OK with either option, and happy to remove the ANY type. In fact, it may be better to remove the ANY type regardless, until we have a solid use-case."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 199,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Iwona, in that case how we will specify the needed TYPE? With any full match is possible, but what about restricted. Say PLDM daemon want to monitor only PLDM message types, how that can be specified here? we need to specify smctp_type. \nThe only question is are we plan to map it to the bit position so that multiple combination is possible (Even though not sure, who will use it like that)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 199,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Jeremy, best way of not encouraging such design would be to not include it in the first place ;) (but keeping things open for extension - if someone *really* requires this). On the other hand, if we add this now and then we realize that we don't want it - we may not be able to remove it (because someone is already using it without *really* requiring it, but removing it would break their application, and we don't want to break user applications).\n\nRichard, we won't. The concept of TYPE is not defined for lower layers - it's only defined for L4 and above (see my diagram in the previous comments).\n\nMy suggestion was just related to the \"MCTP_TYPE_ANY\" special wildcard value.\nI do believe that kernel-API should be designed based on specific use cases. I can see a use case for using sockets operating on lower layer - I can't see a use case for doing MCTP_TYPE_ANY.\n\nIf PLDM daemon wants to monitor only PLDM message types - it's going to just use:\nsocket(AF_MCTP, SOCK_DGRAM, 0), and pass MCTP_TYPE_PLDM as type.\nIf PLDM daemon wants to capture every possible message type - it's going to operate on the lower layer (where the concept of message type doesn't exist).\nIf you want to handle multiple types - you create multiple sockets and bind each one to different type."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 199,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yeah, I'm OK with that approach. I'll remove the facility to bind on MCTP_TYPE_ANY for now, we can add it later if we find it's necessary.\n\nYour suggestion of opening the socket on a lower layer has other implications though; as that may mean you don't get message reassembly or kernel tag handling."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 230,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "how about communication in which EID is not set yet. In that case, how the device will be differentiated?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 230,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I think this should be covered by `MCTP_ADDR_EXT`?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "What if it's not set?\nSay we're doing a \"connect()\" with tag owner bit cleared and send a message.\nWhat do we use to get this message on the receive side?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Like the send functions, specifying a tag value with TO=0 will use the tag value as-is.\n\nI'll add this case in the text."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Hm... imagine the situation when one process calls bind() and another one calls connect() (or just uses sendmsg() directly):\n\nProcess A - \"bind() side\"\n    addr.smctp_family = AF_MCTP;\n    addr.smctp_network = 0;\n    addr.smctp_addr.s_addr = 8;\n    addr.smctp_type = MCTP_TYPE_ECHO;\nProcess B - \"connect() side\"\n    addr.smctp_family = AF_MCTP;\n    addr.smctp_network = 0;\n    addr.smctp_addr.s_addr = 8;\n    addr.smctp_type = MCTP_TYPE_ECHO;\n    addr.smctp_tag = <guess_a_value - it's just 3 bits, shouldn't be too hard>;\n\nProcess B is free to create a socket and connect it to endpoint 8. Since its TO is 0, it's free to \"guess\" a tag value that is going to be used as a response by process A and send messages to endpoint 8 using it. Endpoint 8 will get the message from process B, and will interpret it as a response to its message (which was delivered to process A).\n\nIs that a problem? Or just something we have to accept? Or perhaps this can't happen?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Let's assume these processes are using different sockets, i.e. haven't shared the socket somehow (fork or fd-passing).\n\nI think we could fix this with the same correlation table we use to track TO=0 responses for a connect()ed socket: For bind() sockets, receipt of a TO=1 message has happen before the TO=0 response is sent. For all sockets, we can error out calls to send*() for messages with TO=0 if the socket has no appropriate terminus record with TO=1 for the provided tag. This would prevent transmission of the bogus message in your example.\n\nThoughts?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "I'm assuming that for your case here, these processes are on the same machine, and process B is  (potentially maliciously) attempting to receive messages that should be going to process A. Is that correct?\n\nIn that case, we're still OK. Sending a TO=0 message does not establish any local mapping for the TO=1 pair of that tag to the socket. Only when a tag is allocated by the kernel (through a TO=1 connect or send) do we set up an mapping for the corresponding TO=0 pair (to allow a socket to receive the response).\n\n----\n\nIf my assumption about your case is incorrect, and these processes are on different machines, and want to communicate, then that's not going to work. You mention:\n\n> Since its TO is 0, it's free to \"guess\" a tag value that is going to be used as a response by process A and send messages to endpoint 8 using it\n\nbut it's not free to guess a tag value; if TO=0, that indicates that the tag value came from the peer.\n\nIn this case, the kernel will drop the incoming packet, as it has TO=0, but the tag does not match an existing valid tag value for that destination. From DSP0236, section 8.6:\n\n> Individual packets are dropped (silently discarded) by an endpoint under the following conditions.\n> [...]\n> * A message with TO bit = 0 was received, indicating that the destination endpoint was the originator of the tag value, but the destination endpoint did not originate that value, or is no longer expecting it."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Andrew's response arrived after I'd started my own, now I see what the potential issue is, as potentially duplicated responses for the receiving endpoint.\n\nWhile this is somewhat of a limitation of the MCTP protocol; in that the tag space is super small, I do like the idea of preventing TO=0 message transmission where no TO=1 message has been received prior to that."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Yes, this is about the case where two processes on the same machine are using different sockets and one of them is acting \"maliciously\".\nAnd yes - preventing TO=0 message transmission where no TO=1 message has been received makes sense.\nBut (and please correct me if I'm wrong) the only way to receive a TO=1 message is to create a socket and use bind(), right?\nIn other words - the process already has a way to send a response (TO=0 message), and that's using the socket that has been \"bound\". Why do we want to allow using a separate, completely unrelated and not \"bound\" socket on which we're going to use connect() with TO=0 (or allow using sendmsg() with TO=0 on a socket that's not \"bound\")?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> But (and please correct me if I'm wrong) the only way to receive a TO=1 message is to create a socket and use bind(), right?\n\nRight, that's my understanding.\n\n> In other words - the process already has a way to send a response (TO=0 message), and that's using the socket that has been \"bound\". Why do we want to allow using a separate, completely unrelated and not \"bound\" socket on which we're going to use connect() with TO=0 (or allow using sendmsg() with TO=0 on a socket that's not \"bound\")?\n\nSo what you're suggesting is that the bind() state of a socket is enough to accept or reject send*() calls with TO=0?\n\nJeremy: Does bind() constrain the message type for send*() calls? I don't think even connect() constrains the message type for subsequent send{to,msg}() calls on the same socket? My understanding is we require that the provided struct sockaddr_mctp smctp_type value matches the bottom 7 bits of the message type byte in the message buffer, right?\n\nI think Iwona's suggestion could work so long as we specify that bind() will give EADDRINUSE if multiple applications attempt to bind to the same message type (do we want allow SO_REUSEPORT?), _and_ that bound sockets constrain to send{to,msg}() to the bound message type.\n\nHowever, it does leave a class of errors on the table, namely that any bound socket can send a TO=0 message to a terminus from which we haven't received a TO=1 message. Further, without constraining bound sockets to the one message type, not filtering send*() by TO=1 terminus IDs associated with the socket means (malicious) process B could work around the constraint by just first binding the socket to an arbitrary message type.\n\nSo I still think filtering send*() calls based on the terminus set associated with the socket might be a good idea."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "> But (and please correct me if I'm wrong) the only way to receive a TO=1 message is to create a socket and use bind(), right?\n\nYes, I think that's a sensible call. My original intention was to *not* prohibit TO=0 transmission for arbitrary tag values (perhaps the tag value was discovered through some other out-of-band mechanism), but that does cause the problems you've outlined above.\n\nSo I'm happy to prohibit sending where the TO=0 tag value does not match an existing terminus, or depending on the bind() state - the choice of which depends on the outcomes of the discussion below. We could relax that later if really necessary.\n\n> > In other words - the process already has a way to send a response (TO=0 message), and that's using the socket that has been \"bound\". Why do we want to allow using a separate, completely unrelated and not \"bound\" socket on which we're going to use connect() with TO=0 (or allow using sendmsg() with TO=0 on a socket that's not \"bound\")?\n> \n> So what you're suggesting is that the bind() state of a socket is enough to accept or reject send*() calls with TO=0?\n\n[just clarifying here; by \"bound\" I assume you're referring to an explicit bind() call, rather than the implicit \"binding\" to the TO=0 terminus that happens when you send a TO=1 message]\n\n> Jeremy: Does bind() constrain the message type for send*() calls?\n\nNot currently, but that would make sense to do. Here's the summary so far:\n\n - the only way that an application will have a valid TO=0 tag value is by receiving a TO=1 message\n - the only way to receive a TO=1 message is to bind()\n\nSo, as Iwona is suggesting, we can disallow TO=0 transmission if the socket has not been explicitly bound (thorough bind()) to the appropriate message type. Unless I've missed something?\n\n> My understanding is we require that the provided struct sockaddr_mctp smctp_type value matches the bottom 7 bits of the message type byte in the message buffer, right?\n\nThat's correct.\n\n> I think Iwona's suggestion could work so long as we specify that bind() will give EADDRINUSE if multiple applications attempt to bind to the same message type (do we want allow SO_REUSEPORT?), _and_ that bound sockets constrain to send{to,msg}() to the bound message type.\n\nYep, both of those are sensible.\n\n`SO_REUSEPORT` is fine; it requires separate processes to have the same euid.\n\nAlong those lines, we may also want to prohibit a single socket from *ever* sending multiple types, to keep the requirements somewhat consistent for requester-type sockets too.\n\n> \n> However, it does leave a class of errors on the table, namely that any bound socket can send a TO=0 message to a terminus from which we haven't received a TO=1 message. Further, without constraining bound sockets to the one message type, not filtering send*() by TO=1 terminus IDs associated with the socket means (malicious) process B could work around the constraint by just first binding the socket to an arbitrary message type.\n\nIt sounds like we've met all of those preconditions anyway?\n\nI'm happy to start out restrictive, and we may want to rework during development if we find more use-cases.\n \n> So I still think filtering send*() calls based on the terminus set associated with the socket might be a good idea.\n\nThe \"you can't send TO=0 without bind()\" is a little easier to describe to users :D"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> The \"you can't send TO=0 without bind()\" is a little easier to describe to users :D\n\nWell, a description of my proposal to filter based on the terminus correlation set might be:\n\n\"Sockets will only receive responses to requests they have sent (TO=1). Bound sockets may only respond (TO=0) to requests they have received\".\n\nI don't think that's particularly complex. Also I feel constraining socket behaviour to meet this criteria gives an implementation of the intuitive behaviour while also mitigating against abusive or buggy usage patterns (responding to an incorrect terminus)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Yeah - this covers the usage model without too much details of \"how\" we actually want to achieve it. But shouldn't we drop the \"bound\"?\n\n\"Sockets will only receive responses to requests they have sent (TO=1) and may only respond (TO=0) to requests they have received\""
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Yeah, that works for me."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 236,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "> \"Sockets will only receive responses to requests they have sent (TO=1) and may only respond (TO=0) to requests they have received\"\n\nI like it! I'll add that to a new patchset.\n\nWe'll still need to work out the exact (kernel-internal) implementation, but I think that will be best done when we have the base socket support done."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 263,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "thought this will do the substitution to the MCTP message type, so @266 is redundant right? or is it limited only to filtering?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 263,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "The current thought is to later add more `protocol` options for the socket() call which would include manipulating the message to check the IC and strip the type byte based on the protocol. Conflicting values for addr.smctp_type and the first byte of the message for socket(AF_MCTP, SOCK_DGRAM, 0) is an error."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 266,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "nit: You should probably just use MCTP_TYPE_ECHO here ;) Unless this is a \"negative\" example that's going to return -EPROTO on sendto()."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 266,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Ah, good catch! This isn't supposed to be a negative example, I'll fix this up."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 266,
                    "reviewer": {
                        "name": "Iwona Winiarska",
                        "email": "iwona.winiarska@intel.com",
                        "username": "iklm"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 294,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Maybe \"The `connect()` address and tag\", which will help out with my next comment"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 294,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Good call, changed."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 298,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "So as it stands this mostly reiterates the previous sentence. To address my questions on in PS3 I think it would be more useful if it said something like your reply to my comment:\n\n\"The tag allocated through a call to `sendto()` or `sendmsg()` on a connected socket is subject to the same invalidation logic as on an unconnected socket: It is expired either by timeout or by a subsequent `sendto()`.\""
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 298,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "That's much better, thanks."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 352,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "You meant to say for the current sent packet. So, if we do multiple commands are sent, with TagOwner set, then in order to know the tagValue, getsockname() needs to be called after each send()"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 352,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Yeah I think this needs some clarification. Another straw-person idea is only allowing it for connected sockets?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 352,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "The semantics are a bit tricky here; getsockname() is for retrieving the local address, getpeername() is for retrieving the remote address.\n\ngetsockname() can retrieve the address used for a bind() - which, in our case does not include any tag allocation. getpeername() would be for that. I'll clarify here."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 384,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "to be used in case of NULL EID right?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 384,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Yes"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 402,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "what do you think about removing \"previous\" here? It caused me some confusion when reading PS3."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 402,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Ah yes, I was planning this and it slipped through. Deleted."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 404,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Not clear when this is required.\nI meant once response with multiple MCTP Packets(SOM to EOM - i.e. Proper MCTP message response), is received then the tag value can be cleaned and reused as per the timeout. Why do we expect to hold it, even after receiving the response?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 404,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "See the discussion on line 922 onwards."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 404,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yes, as Andrew has indicated.\n\nIn short, we cannot release the tag value on receiving a response."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 624,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Thanks for adding the timeout handling."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 624,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 685,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I still think this should be something like ('destination EID', 'source EID', ...) for consistent language and to differentiate from other types of address like physical addresses.\n\nI also asked about the TO bit, but I wasn't necessarily advocating for it's inclusion, was just asking whether you intended it to be. So now I have to ask whether we need to capture the TO bit? We don't need to correlate for a responder, so it seems to me it's implicit that the tag-owner value is always 1?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 685,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Yep, good call, I'll adjust the terms there to be consistent.\n\nI think it's better to include tag-owner in that set there; even though it may not exist in the kernel data structure for these mappings, we do need to match TO on the incoming packets."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 685,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Ack"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 936,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 938,
            "sizeDeletions": 1
        },
        {
            "number": 5,
            "revision": "e71528b58306546b49813fb6c93f460cb2045450",
            "parents": [
                "514ea474b4d09c503ed39f6b3298436732b7c90e"
            ],
            "ref": "refs/changes/14/40514/5",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1613967224,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 938,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 940,
            "sizeDeletions": 1
        },
        {
            "number": 6,
            "revision": "2385b8d770157398edbc52169ae212ba1bf9b509",
            "parents": [
                "514ea474b4d09c503ed39f6b3298436732b7c90e"
            ],
            "ref": "refs/changes/14/40514/6",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1614057918,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 939,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 941,
            "sizeDeletions": 1
        },
        {
            "number": 7,
            "revision": "973dba01c3982cd01071ab0f20a42cdc0414e398",
            "parents": [
                "514ea474b4d09c503ed39f6b3298436732b7c90e"
            ],
            "ref": "refs/changes/14/40514/7",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1614134134,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 941,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 943,
            "sizeDeletions": 1
        },
        {
            "number": 8,
            "revision": "5a8788f5dc2a17ebc4321942a388db9b05dad9c1",
            "parents": [
                "bac8940ea96db6928748089e2b7e9d65fa659120"
            ],
            "ref": "refs/changes/14/40514/8",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1614220034,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 242,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Does this need to be changed with the discussion on PS4 around how sockets deal with the TO bit? When would we use connect() with TO=0? I think the tag provided to connect() needs to be checked against the terminus set associated with the socket().\n\nconnect()ing in order to send a response on a socket on which we've also called bind() seems heavy-handed when send{to,msg}() exist, but maybe we shouldn't preclude it? I think allowing it requires that the subsequent send*() calls be provided with the same tag and TO in their metadata (i.e. we error out calls that don't meet that requirement)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 242,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "I don't think there's a great use-case for connect(TO=0). As you say, we'd need to have bind()-ed previously, and recvmsg()-ed a message to establish a peer terminus. After that point, the only benefit of connect() is allowing send() & write() over sendmsg/sendto. recv() and read() are still out, because you may be receiving other terminus' packets as a result of the original bind().\n\nSo, perhaps we should disallow it. Any objections to that?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 242,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Nah, I'm happy with disallowing it."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 430,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Is it worth clarifying here that if this isn't what you're doing, you should just use connect() to get a \"permanent\" tag allocation?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 430,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "This is a fairly complex section; I'd rather leave that detail in line 717 at the risk of making things potentially more confusing here."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 430,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 863,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "smctp_type"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 863,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Ack. `struct sockaddr_mctp` was my intention here, will fix for PS9."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 947,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 949,
            "sizeDeletions": 1
        },
        {
            "number": 9,
            "revision": "be569760f949b4f7efd6e6249faed6e4d333ead5",
            "parents": [
                "bac8940ea96db6928748089e2b7e9d65fa659120"
            ],
            "ref": "refs/changes/14/40514/9",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1614303611,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 180,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "So I've had a nagging, low-key nervous feeling about the kernel ignoring the tag value. I think it would be good for forwards-compatibility to require userspace set it to a specific value. The question is what value? I have a proposal below.\n\nbind() is basically \"make the socket give me packets that match these properties\", which is a reflection of connect()'s \"I will send packets on this socket with these properties\". In our case, bind() will match inbound packets on the network, EID and message type properties.\n\nSeparately, the result of bind() is that we receive messages with TO=1 on the socket, which we cannot do if the socket has not had bind() invoked on it. Working backwards through the hand-wavy definition of bind() above, it's effectively case for bind() that TO=1 is a match criteria for packets.\n\nSo I'm proposing that we require userspace to set the following in struct sockaddr_mctp for bind():\n\n addr.smctp_tag = MCTP_TAG_OWNER;\n\nReflecting some of the wording for connect(), the documentation might say:\n\n> The `smctp_tag` value will configure the tags accepted from the remote side of this socket. The only valid value is `MCTP_TAG_OWNER`, which will result in remotely \"owned\" tags being routed to this socket. See the [Tag behaviour for transmitted messages](#tag-behaviour-for-transmitted-messages) section for more details. If the `MCTP_TAG_OWNER` bit is not set, `bind()` will fail with an errno of `EINVAL`."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 180,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "As discussed - I agree here; even though there's no harm in ignoring the value now, we may run into trouble for forward compat. I'm OK with requiring a specific value, and `MCTP_TAG_OWNER` is certainly the most sensible, in that it somewhat matches the incoming tag-owner spec.\n\nI'll add your working (with a few changes to integrate into the surrounding paragraphs) to the doc, thanks for that."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 330,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "We can only receive messages if the socket has had bind() called on it, it might be worth adding that to the example?\n\nhttps://twitter.com/reillyeon/status/1190100469370126337?s=20 and all"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 330,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "There's also no socket() call, so this wouldn't work at all. My intention was just to illustrate each syscall on its own.\n\nWe have the full examples below, which would make better copypasta."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 330,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> We have the full examples below, which would make better copypasta.\n\nYeah, this was another unwritten thought that crossed my mind. All good."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 359,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "`MCTP_TAG_OWNER` is required for connect() now, so maybe this can go away?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 359,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 483,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Wait, are we still using this macro? It isn't defined above, but maybe if it is still on the cards it's what we should be passing to connect()/bind()?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 483,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Nope, we only have TAG_OWNER now, fixing this."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 534,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "If we take up my suggestion above this needs to be fixed."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 534,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 596,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Again, need to decide which way we go here (MCTP_TAG_OWNER vs MCTP_TAG_OWNER_ANY)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 596,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Ack"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 946,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 948,
            "sizeDeletions": 1
        },
        {
            "number": 10,
            "revision": "59dc06ecdeb295c83fc442e3bca089a398d70af7",
            "parents": [
                "bac8940ea96db6928748089e2b7e9d65fa659120"
            ],
            "ref": "refs/changes/14/40514/10",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1614320758,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 248,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "It looks like this reverted to the state it was in on PS8. PS9 disallowed connect(TO=0) which I still think is the correct behaviour?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 248,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Good catch. Have fixed this (and only this) in PS11."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 952,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 954,
            "sizeDeletions": 1
        },
        {
            "number": 11,
            "revision": "51a0491f00a54c01845ea5fce0a1137c2357ae91",
            "parents": [
                "bac8940ea96db6928748089e2b7e9d65fa659120"
            ],
            "ref": "refs/changes/14/40514/11",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1614565578,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 173,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I was skimming over the doc again when I realised we're missing the following from the example here:\n\n addr.smctp_tag = MCTP_TAG_OWNER;"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 173,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "d'oh! good catch, fixed in PS12."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 951,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 953,
            "sizeDeletions": 1
        },
        {
            "number": 12,
            "revision": "f0ca2e418c0b4669d3a759775f654343f0b9e504",
            "parents": [
                "bac8940ea96db6928748089e2b7e9d65fa659120"
            ],
            "ref": "refs/changes/14/40514/12",
            "uploader": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "createdOn": 1614824553,
            "author": {
                "name": "Jeremy Kerr",
                "email": "jk@ozlabs.org",
                "username": "jk-ozlabs"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 200,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Better to clarify\nAs responder, even with specific local EID, NULL EID & BROADCAST EID will be accepted, but not others.\n\nAs requester, MCTP_ADDR_ANY can send to multiple and with specific EID, NULL & BROADCAST EID possibility?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 200,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I don't think MCTP_ADDR_ANY makes sense for requesters."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 200,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "As a requester how the first GetEID / SetEID command can be sent esp, for NULL EID."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 697,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Tag behavior for received messages section\n1. Need to explicitly state that TO=1 with any tag value will be accepted\n2. With TO=0, Tag value must match unexpired tag, else the MCTP Message packet will be silently dropped."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 697,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> 1. Need to explicitly state that TO=1 with any tag value will be accepted\n\nDo you think we need more than what's already mentioned in the bind() documentation above?\n\n> 2. With TO=0, Tag value must match unexpired tag, else the MCTP Message packet will be silently dropped.\n\nGood catch. It doesn't seem like this case is discussed in the text? Jeremy and I had spoken about it, and from my records:\n\n> [2:24 PM] jk-: if the TO=0 tag doesn't exist, we'd ESOMETHING\n\nSo it's not quite a silent drop, the caller would at least learn that something had gone wrong."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 697,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "we have section for Transmitted, my point is to document it for receive side.\n\nSilent drop is allowed from specification point of it."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 710,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "shouldn't be.\nExample, Requester sends request to 2 different EID's. It can send to both and await for its response. The MsgTag will be different for each different destination EID and tracked separately and shouldn't expire due to next request."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 710,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "What you're asking for is handled by the `MCTP_TAG_CONTROL` sockopt documented above. As I understand it, if you set the socket to retain tags it will do so like you've requested. It's just not the default behaviour because asynchronous use of the socket isn't the \"easy\" use-case in the spirit of the \"Configuration should be simple for a straightforward MCTP endpoint\" guideline from the \"Requirements for a kernel implementation\" section above."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 710,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "I am not quite clear, you meant to say when kernel is requested to send a new message to the new destination EID, then old tag value needs to expire?\n\nExpiring Msg tag is allowed only with any one of the following cases\n1. If response with the msg tag is received (exception is discussed NVMe-MI and if yes this scenario needs to retain but it seems NVMe-MI will use ROR bit - Will confirm it though)\n2. timeout \n3. user space application which sent the tag is no longer needs the same.\n\nIt can't expire the msg tag, just because new request is sent to new destination EID."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 739,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Where this is specified in DSP0236. This has not been clearly specified in the specification, and my understanding is to use the physical address mapping with MsgTag in this case (Say with NULL EID / Broadcast EID).\nNote: For Broadcast EID usage MCTP Control type can track the same using Instance ID and same logic must apply for other MCTP message types too."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 739,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "The key part is avoiding layering violations while correctly associating assembled messages with sockets.\n\nThe current design doesn't put any general knowledge of MCTP control packets into the kernel, and as such the Instance ID is opaque. The message terminus is used to associate packets to a specific assembly, and a message terminus is defined as the \"MCTP Source Endpoint ID, Tag Owner bit value, and Message Tag value\" (3.2.40). Given that the terminus is the way to uniquely identify a message we also use it to perform correlation to sockets for message delivery to userspace.\n\nWe have various MCTP control message classes that we need to cater to, including Broadcast Request (11.1.1). If we send a Broadcast Request class message we lose the MCTP Source Endpoint as a useful message-correlation value for the socket (we must correlate responses from multiple endpoints to the socket as a result of the Broadcast Request). This leaves us with just Tag Owner and Message Tag Value as the means to correlate the response message to the socket, and therefore we need the Tag Value to be (locally) unique so as not to mistakenly deliver unrelated responses.\n\n> my understanding is to use the physical address mapping with MsgTag in this case\n\nCan you expand on how this helps resolve the message-to-socket correlation problem? All packets we receive must necessarily be physically addressed to us. We don't know what physical addresses will respond a-priori when transmitting a Broadcast Request, so we can't prime the socket metadata with the set of physical addresses we expect to receive responses from.\n\n> For Broadcast EID usage MCTP Control type can track the same using Instance ID and same logic must apply for other MCTP message types too.\n\nThis requires we implement processing of MCTP control messages in the kernel for some message-to-socket correlation, which is something I'd certainly like to avoid."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 739,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "This is a consequence of behaviour defined by DSP0236, section 8.5:\n\n> The following fields (and only these fields) are collectively used to identify the packets that belong to a given message for the purpose of message assembly on a particular destination endpoint\n> * Msg Tag (Message Tag)\n> * TO (Tag Owner)\n> * Source Endpoint ID\n\n[emphasis on \"only\" as written in the spec]\n\nThe definition of \"message terminus\" (Section 3.4) in the spec also includes only these fields.\n\nWe'd be violating the spec if we start including other data for this (like phys address or payload-specific fields). The phys address approach also doesn't work for bindings that have no physical addresses.\n\nSo, if we have a situation where the peer EID is a special value (ie, broadcast, or NULL), the message tag must be unique across all potential responses, for a particular local EID, otherwise there is no way to uniquely identify the local message terminus. \n\nIt could be argued that this is only for message reassembly, and we should leave the message-to-socket correlation to userspace, but then the design that we're left with makes it no longer possible to implement sockets in a secure manner at all, where messages must be forwarded to multiple processes."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 739,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Just to make sure we are all the same page. \n\nNote: We need to rely on EID for the MsgTag tracking, and the logic is not to deviate from it.\nWhat i meant to say is in this following condition.\n1. Sending messages to Null EID, in this case, as per Spec, the MsgTag needs to be tracked, but when there are multiple devices in the bus, and not to run out of Msg Tag we can rely on physical address when EID is NULL, during the initialization phase of the platform (Condition may happen, when Topmost B.O is not available during this time etc.). This is not violation of Spec, as we will be able to track it individually(i.e. we are still in compliance with the spec). \n\n2. Related to Broadcast EID --> Again this is special EID, so far mainly used only in Control message type (Note: Some protocol type can still use it, but not seen anything so far). Even in Control ID, the request & response are tracked using Instance ID. i.e. There is no spec requirement which states that Broadcast EID message must be sent to all the devices with same MsgTag (Also, this is only applicable, when physical layer support address less transfer)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 782,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "This must be avoided from security point of it. We don't want to end up doing a different mapping. In short, Physical to EID mapping must be determined through MCTP Control message types."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 782,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I think you're interpreting that more broadly than its intent. It's not the general case, but rather a case specifically for mapping the bus owner. This is described by paragraphs 3 and 4 in 9.1.5 (in DSP0236 1.3.1):\n\n> An endpoint that needs to originate a \"connection\" to another MCTP endpoint does need to know what physical address should be used for messages to be delivered to that endpoint. To get this information, it needs to query the bus owner for it. An endpoint knows the physical address of the bus owner because it saved that information when it got its EID assignment.\n\nParticularly the last sentence above. If we're going to collect the physical address, we might as well populate the route table with the bus owner's EID as well.\n\n> \n> The Resolve Endpoint ID command requests a bus owner to return the physical address that is to be used to route packets to a given EID. (This is essentially the MCTP equivalent of the ARP protocol that is used to translate IP addresses to physical addresses.) The address that is returned in the Resolve Endpoint ID command response will either be the actual physical address for the device implementing the endpoint, or it will be the physical address for the bridge to be used to route packets to the desired endpoint.\n\nThis is the bit that you care about, and is taken care of by the next bullet point below:"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 782,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "> This must be avoided from security point of it\n\nI disagree. What's your proposed attack vector here? Keep in mind that if it's possible to poison the neighbour information through this mechanism, then it's also possible to do the same through a control message response.\n\nThis is also allowed by the spec, see the second paragraph of 9.1.5.\n\n[We could implement a control mechanism to disable this behaviour, but I don't see a use-case for that at present]"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 782,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "With SPDM now in picture, physical-to-Eid mapping must happen only through MCTP Control or with SPDM (more secure way).\nWhat i understand from this line, even with BMC as a Bus owner, if any device just issues a request to BMC (Say GetEID) to BMC, with it's own EID in the picture, then kernel mapping that will be a problem.\n\nConsider a device went to reset and uses it's old EID, which is retired and used for other device, now what kernel will do ? \nProper logic will be MCTP control detecting the same, and performing a proper SetEID with NULL EID."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 914,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "This will be against DSP0236. i.e. when MCTP packets needs to be assembled it will be based on tag value, and hence the next successive MCTP message, must be with different tag value (else any one packet drop) may cause confusion."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 914,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Well, technically reply packets are assembled into messages correlating on the terminus recorded in each packet, which includes the source (remote) EID. So there's no ambiguity with the limitation that you only have one outstanding message per endpoint. However, for the MCTP control protocol, section 11.6.2 explicitly states that you may not have more than one outstanding request per endpoint, so this implementation requirement in-fact wouldn't be a limitation for the *MCTP control protocol*.\n\n*Other* protocols may not have this limitation though, so maybe it's a good idea to have an extra bullet point in the list below?"
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 914,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "DSP0236 doesn't require different tags for subsequent messages, I don't see this as violating the spec. If I'm incorrect though, could you point me to where in the spec you're referencing?\n\nYes, we need to ensure that the tag can uniquely identify interleaved messages while in-flight, but there are no restrictions that I can see otherwise."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 914,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Message Tag + Source EID + TO will be used to identify the MCTP message uniquely. In other words, the subsequent message needs to be different to support interleave for different message types.\nNote: source endpoint can interleave the response and can respond in out of order, hence \n\n\"A source endpoint is allowed to interleave packets from multiple messages to the same destination endpoint concurrently, provided that each of the\nmessages has a unique message tag.\" \n\n\nNote: As this was considered as alternative (My intention is to document this as further limitations to indicate about interleave support will be difficult).\n\nScenario where this option will cause confusion:\n1. B.O sends a MCTP message (multiple MCTP packets with EOM message dropped in physical medium)\n2. Now the same MCTP message can be retried or new MCTP message can be sent out. The device must know the same which is possible using new Msg Tag.\n\n(Pkt sequence is used to differentiate multiple MCTP packets, and MsgTag with source EID, TO will be used to determine Messages)."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 950,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "I am not sure, how the response must be handled here. Do you know whether NVMe-MI must send the final reply with TO bit set and Message type body to differentiate it (Say in terms of control Message type we have Datagram bit)\n\nFor all other Message types (Except NVMe-MI), it would be better to expire the MsgTag after the proper message (assembled) is received."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 950,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "There's still the case of the Broadcast Request message class described below. Ignoring NVMe unfortunately doesn't make this proposal feasible."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 950,
                    "reviewer": {
                        "name": "Jeremy Kerr",
                        "email": "jk@ozlabs.org",
                        "username": "jk-ozlabs"
                    },
                    "message": "Implementing immediate tag expiry on a reply requires us to assume that *all* upper-layer protocols have a 1:1 request-to-reply correlation, *including all future protocols*.\n\nI'm not willing to make that guarantee, especially given that we have one counterexample already. And as Andrew says, this also applies to broadcasts."
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "line": 950,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "I didn't got a chance to check any of the existing NVMe-MI device yet, but in NVMe-MI specification, they are not relying the TO to determine the Request / Response and NVMe-MI message type internally uses ROR bit to determine the same.\n\nThe problem with not expiring the  Msg Tag value is, it requires all message type to expire the same. \nRegarding the future protocols, MCTP doesn't have any partial response other than the NVMe-MI. Will raise this in PMCI-DMTF and get back with apt data."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp-kernel.md",
                    "type": "ADDED",
                    "insertions": 952,
                    "deletions": 0
                },
                {
                    "file": "designs/mctp/mctp.md",
                    "type": "MODIFIED",
                    "insertions": 2,
                    "deletions": -1
                }
            ],
            "sizeInsertions": 954,
            "sizeDeletions": 1
        }
    ]
}