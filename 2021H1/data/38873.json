{
    "project": "openbmc/dbus-sensors",
    "branch": "master",
    "id": "Ia061f849b0f434812f822ed1902c8964d4c64b45",
    "number": 38873,
    "subject": "Add check for min/max received from hwmon files",
    "owner": {
        "name": "Wojciech Dembinski",
        "email": "wojciech.dembinski@intel.com",
        "username": "wdembinski"
    },
    "url": "https://gerrit.openbmc-project.xyz/c/openbmc/dbus-sensors/+/38873",
    "commitMessage": "Add check for min/max received from hwmon files\n\nWhen hwmon reports incorrect min/max values or CPU Sensor cannot access\nreadings, it shall keep the last known good readings and not update\nDBus with incorrect values.\nThis patch adds min < max verification check for the values received\nfrom hwmon and removes check for power on/off in the case of a read\nfailure.\n\nTested manually on a physical platform, test cases cover incorrect\nmax/min values and failing access to hwmon files.\nSDR over IPMI can be fully received in the case of error.\n\nSigned-off-by: Wojciech Dembinski <wojciech.dembinski@intel.com>\nChange-Id: Ia061f849b0f434812f822ed1902c8964d4c64b45\n",
    "createdOn": 1607420123,
    "lastUpdated": 1610616197,
    "open": false,
    "status": "ABANDONED",
    "comments": [
        {
            "timestamp": 1607420123,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Uploaded patch set 1."
        },
        {
            "timestamp": 1607420138,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 1:\n\nUser not approved, see admin, no CI"
        },
        {
            "timestamp": 1607426928,
            "reviewer": {
                "name": "Zbigniew Kurzynski",
                "email": "zbigniew.kurzynski@intel.com",
                "username": "zkurzyns"
            },
            "message": "Patch Set 1:\n\n(5 comments)"
        },
        {
            "timestamp": 1607446618,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Uploaded patch set 2."
        },
        {
            "timestamp": 1607446629,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2:\n\nUser not approved, see admin, no CI"
        },
        {
            "timestamp": 1607456472,
            "reviewer": {
                "name": "Zhikui Ren",
                "email": "zhikui.ren@intel.com",
                "username": "ZhikuiRen"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1607456977,
            "reviewer": {
                "name": "Zhikui Ren",
                "email": "zhikui.ren@intel.com",
                "username": "ZhikuiRen"
            },
            "message": "Patch Set 2:\n\n(2 comments)"
        },
        {
            "timestamp": 1607522752,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Patch Set 2:\n\n(7 comments)"
        },
        {
            "timestamp": 1607621476,
            "reviewer": {
                "name": "Zhikui Ren",
                "email": "zhikui.ren@intel.com",
                "username": "ZhikuiRen"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1607960075,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Uploaded patch set 3."
        },
        {
            "timestamp": 1607960086,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 3:\n\nUser not approved, see admin, no CI"
        },
        {
            "timestamp": 1608284161,
            "reviewer": {
                "name": "Zbigniew Kurzynski",
                "email": "zbigniew.kurzynski@intel.com",
                "username": "zkurzyns"
            },
            "message": "Patch Set 3: Code-Review+1"
        },
        {
            "timestamp": 1608287319,
            "reviewer": {
                "name": "Zbigniew Kurzynski",
                "email": "zbigniew.kurzynski@intel.com",
                "username": "zkurzyns"
            },
            "message": "Uploaded patch set 4."
        },
        {
            "timestamp": 1608287330,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 4: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1608287479,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 4: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/10104/ : SUCCESS"
        },
        {
            "timestamp": 1608287723,
            "reviewer": {
                "name": "Zbigniew Lukwinski",
                "email": "zbigniew.lukwinski@linux.intel.com",
                "username": "zlukwins"
            },
            "message": "Patch Set 4: Code-Review+1"
        },
        {
            "timestamp": 1608287843,
            "reviewer": {
                "name": "Zbigniew Kurzynski",
                "email": "zbigniew.kurzynski@intel.com",
                "username": "zkurzyns"
            },
            "message": "Patch Set 4: Code-Review+1"
        },
        {
            "timestamp": 1608288707,
            "reviewer": {
                "name": "Adam Krzywaniak",
                "email": "adam.krzywaniak@intel.com",
                "username": "akrzywan"
            },
            "message": "Patch Set 4: Code-Review+1"
        },
        {
            "timestamp": 1608307063,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 4:\n\n(4 comments)"
        },
        {
            "timestamp": 1608307297,
            "reviewer": {
                "name": "Krzysztof Grobelny",
                "email": "krzysztof.grobelny@intel.com",
                "username": "krzysztof-i"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1608308745,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1609775510,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Uploaded patch set 5."
        },
        {
            "timestamp": 1609775529,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 5:\n\nUser not approved, see admin, no CI"
        },
        {
            "timestamp": 1609776261,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Patch Set 5:\n\n(3 comments)"
        },
        {
            "timestamp": 1609838190,
            "reviewer": {
                "name": "Zbigniew Lukwinski",
                "email": "zbigniew.lukwinski@linux.intel.com",
                "username": "zlukwins"
            },
            "message": "Uploaded patch set 6."
        },
        {
            "timestamp": 1609838202,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 6: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1609838273,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 6: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/10495/ : SUCCESS"
        },
        {
            "timestamp": 1609876591,
            "reviewer": {
                "name": "Zhikui Ren",
                "email": "zhikui.ren@intel.com",
                "username": "ZhikuiRen"
            },
            "message": "Patch Set 6:\n\n(3 comments)"
        },
        {
            "timestamp": 1610010177,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Patch Set 6:\n\n(1 comment)"
        },
        {
            "timestamp": 1610045811,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Uploaded patch set 7."
        },
        {
            "timestamp": 1610045822,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 7: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1610045932,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 7: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/10628/ : SUCCESS"
        },
        {
            "timestamp": 1610046100,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Patch Set 7:\n\nAfter quick discussion with Zhikui Ren and Team, decided to remove isPowerOn() check and keep last good readings on DBus instead of updating with NaN, 0 or other default value.\n\"1. these limits don't change that often \n 2. failure to read is rare and temporary \n 3. there is no extra corrective action can be taken or need to be taken for such failure except re-try again\".\nThat way ipmitool sdr read will work in all cases, min < max, failed reading, power off."
        },
        {
            "timestamp": 1610129372,
            "reviewer": {
                "name": "Zbigniew Lukwinski",
                "email": "zbigniew.lukwinski@linux.intel.com",
                "username": "zlukwins"
            },
            "message": "Patch Set 7:\n\nPlease run clang formatter"
        },
        {
            "timestamp": 1610144938,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 7:\n\n(2 comments)\n\n> Patch Set 7:\n> \n> After quick discussion with Zhikui Ren and Team, decided to remove isPowerOn() check and keep last good readings on DBus instead of updating with NaN, 0 or other default value.\n\nYou've deleted the code to publish NAN when the power is off on first boot.\n\nI really suspect we need to separate these into two commits.\n1. not updating dbus when we get \"bad\" values.\n2. Changing the power on policy.\n\nEach has some subtleties that needs its own testing.\n\n> \"1. these limits don't change that often\n>  2. failure to read is rare and temporary\n\nWhen we fail to read, shouldn't we be getting an error code back?\n\n>  3. there is no extra corrective action can be taken or need to be taken for such failure except re-try again\".\n> That way ipmitool sdr read will work in all cases, min < max, failed reading, power off."
        },
        {
            "timestamp": 1610145215,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 7:\n\n(3 comments)"
        },
        {
            "timestamp": 1610288736,
            "reviewer": {
                "name": "Saravanan Palanisamy",
                "email": "saravanan.palanisamy@linux.intel.com",
                "username": "saravanan-palanisamy"
            },
            "message": "Removed reviewer Saravanan Palanisamy."
        },
        {
            "timestamp": 1610382172,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Patch Set 7:\n\n(3 comments)\n\n> Patch Set 7:\n> \n> (2 comments)\n> \n> > Patch Set 7:\n> > \n> > After quick discussion with Zhikui Ren and Team, decided to remove isPowerOn() check and keep last good readings on DBus instead of updating with NaN, 0 or other default value.\n> \n> You've deleted the code to publish NAN when the power is off on first boot.\n> \n> I really suspect we need to separate these into two commits.\n> 1. not updating dbus when we get \"bad\" values.\n> 2. Changing the power on policy.\n> \n> Each has some subtleties that needs its own testing.\n> \n> > \"1. these limits don't change that often\n> >  2. failure to read is rare and temporary\n> \n> When we fail to read, shouldn't we be getting an error code back?\n> \n> >  3. there is no extra corrective action can be taken or need to be taken for such failure except re-try again\".\n> > That way ipmitool sdr read will work in all cases, min < max, failed reading, power off.\n\nAgree that error case should respond with a proper error code. However I don't think that this property is the right \"channel\" to signal a problem. That one property on DBus should contain only reading values. If we want to signal errors with error codes, it should be done by an additional \"reading status\" property to separate logical function/meaning of these properties and their uses."
        },
        {
            "timestamp": 1610389947,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 7:\n\n(2 comments)\n\n> Patch Set 7:\n> \n> (3 comments)\n> \n> > Patch Set 7:\n> > \n> > (2 comments)\n> > \n> > > Patch Set 7:\n> > > \n> > > After quick discussion with Zhikui Ren and Team, decided to remove isPowerOn() check and keep last good readings on DBus instead of updating with NaN, 0 or other default value.\n> > \n> > You've deleted the code to publish NAN when the power is off on first boot.\n> > \n> > I really suspect we need to separate these into two commits.\n> > 1. not updating dbus when we get \"bad\" values.\n> > 2. Changing the power on policy.\n> > \n> > Each has some subtleties that needs its own testing.\n> > \n> > > \"1. these limits don't change that often\n> > >  2. failure to read is rare and temporary\n> > \n> > When we fail to read, shouldn't we be getting an error code back?\n> > \n> > >  3. there is no extra corrective action can be taken or need to be taken for such failure except re-try again\".\n> > > That way ipmitool sdr read will work in all cases, min < max, failed reading, power off.\n> \n> Agree that error case should respond with a proper error code. However I don't think that this property is the right \"channel\" to signal a problem. That one property on DBus should contain only reading values. If we want to signal errors with error codes, it should be done by an additional \"reading status\" property to separate logical function/meaning of these properties and their uses.\n\nFeel free to propose something different, but this is not the right forum to propose a \"reading status\" API."
        },
        {
            "timestamp": 1610459930,
            "reviewer": {
                "name": "Zbigniew Lukwinski",
                "email": "zbigniew.lukwinski@linux.intel.com",
                "username": "zlukwins"
            },
            "message": "Patch Set 7:\n\n> Patch Set 7:\n> \n> (2 comments)\n> \n> > Patch Set 7:\n> > \n> > (3 comments)\n> > \n> > > Patch Set 7:\n> > > \n> > > (2 comments)\n> > > \n> > > > Patch Set 7:\n> > > > \n> > > > After quick discussion with Zhikui Ren and Team, decided to remove isPowerOn() check and keep last good readings on DBus instead of updating with NaN, 0 or other default value.\n> > > \n> > > You've deleted the code to publish NAN when the power is off on first boot.\n> > > \n> > > I really suspect we need to separate these into two commits.\n> > > 1. not updating dbus when we get \"bad\" values.\n> > > 2. Changing the power on policy.\n> > > \n> > > Each has some subtleties that needs its own testing.\n> > > \n> > > > \"1. these limits don't change that often\n> > > >  2. failure to read is rare and temporary\n> > > \n> > > When we fail to read, shouldn't we be getting an error code back?\n> > > \n> > > >  3. there is no extra corrective action can be taken or need to be taken for such failure except re-try again\".\n> > > > That way ipmitool sdr read will work in all cases, min < max, failed reading, power off.\n> > \n> > Agree that error case should respond with a proper error code. However I don't think that this property is the right \"channel\" to signal a problem. That one property on DBus should contain only reading values. If we want to signal errors with error codes, it should be done by an additional \"reading status\" property to separate logical function/meaning of these properties and their uses.\n> \n> Feel free to propose something different, but this is not the right forum to propose a \"reading status\" API.\n\nHi,\nWe trust the driver. Issue here is rather about the hardware which provides odd data, e.g. max value = 0. And this could happened because of wrong hardware configuration (jumpers, straps, etc.)\nI don't think driver should event try to correct such data. In this case we have hwmon driver which is pretty straightforward - reads data from CPU over PECI and provides this data to the sysfs. I am not sure whether we should add any logic here to correct data.\nWe thought cpusensor is good place for catching such cases and do to propagate it because of the type of sensor we have here. All of that here is about power capping sensor(s) which behaves with different way other sensors do. In case other sensor 'Value' is the reading from the hardware and 'MinValue/MaxValue' are hardcode to the -127/128 (recently change to 0/511). But here 'MinValue/MaxValue' are taken from hardware as well. I think catching here incorrect values for MinValue/MaxValue would put capping sensor implementation (from DBus perspective) closer the original concept for MinValue/MaxValue (which could never be incorrect).\nBut maybe we should stop here for a moment and check whether capping sensor implementation is done with the right way. Maybe there should be three different sensors: capping, capping min, capping max?\nEd, what do you think?\n\nAnyway I think both SDR IPMI commands handlers and ipmitool implementation shall be modified as well. Because right now it assumes MinValue/MaxValues shall be always valid. I mean there is a validation for that stuff in SDR IPMI commands handlers but in case it fails bad things happen."
        },
        {
            "timestamp": 1610469020,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 7:\n\n> Patch Set 7:\n> \n> > Patch Set 7:\n> > \n> > (2 comments)\n> > \n> > > Patch Set 7:\n> > > \n> > > (3 comments)\n> > > \n> > > > Patch Set 7:\n> > > > \n> > > > (2 comments)\n> > > > \n> > > > > Patch Set 7:\n> > > > > \n> > > > > After quick discussion with Zhikui Ren and Team, decided to remove isPowerOn() check and keep last good readings on DBus instead of updating with NaN, 0 or other default value.\n> > > > \n> > > > You've deleted the code to publish NAN when the power is off on first boot.\n> > > > \n> > > > I really suspect we need to separate these into two commits.\n> > > > 1. not updating dbus when we get \"bad\" values.\n> > > > 2. Changing the power on policy.\n> > > > \n> > > > Each has some subtleties that needs its own testing.\n> > > > \n> > > > > \"1. these limits don't change that often\n> > > > >  2. failure to read is rare and temporary\n> > > > \n> > > > When we fail to read, shouldn't we be getting an error code back?\n> > > > \n> > > > >  3. there is no extra corrective action can be taken or need to be taken for such failure except re-try again\".\n> > > > > That way ipmitool sdr read will work in all cases, min < max, failed reading, power off.\n> > > \n> > > Agree that error case should respond with a proper error code. However I don't think that this property is the right \"channel\" to signal a problem. That one property on DBus should contain only reading values. If we want to signal errors with error codes, it should be done by an additional \"reading status\" property to separate logical function/meaning of these properties and their uses.\n> > \n> > Feel free to propose something different, but this is not the right forum to propose a \"reading status\" API.\n> \n> Hi,\n> We trust the driver. Issue here is rather about the hardware which provides odd data, e.g. max value = 0. And this could happened because of wrong hardware configuration (jumpers, straps, etc.)\n> I don't think driver should event try to correct such data. In this case we have hwmon driver which is pretty straightforward - reads data from CPU over PECI and provides this data to the sysfs. I am not sure whether we should add any logic here to correct data.\n\nIf the driver is providing odd data, something is broken, and the driver should be fixed.\n\n> We thought cpusensor is good place for catching such cases and do to propagate it because of the type of sensor we have here.\n\nThe problem becomes that then we start adding lots of error conditions to cpusensor, and they get minimal reviews because it's not part of the kernel.  Having error handling in the kernel is better.\n\n> All of that here is about power capping sensor(s) which behaves with different way other sensors do. In case other sensor 'Value' is the reading from the hardware and 'MinValue/MaxValue' are hardcode to the -127/128 (recently change to 0/511). But here 'MinValue/MaxValue' are taken from hardware as well. \n\nPart of me wonders if we need to roll that back.  Having a flexible MinValue/MaxValue seems to be causing more problems than it's worth.  I need to think about that more, but the core of the problem here is that the SDR is now based on data read outside the BMC, which, as you point out means it can change over time.  The added precision on this one sensor doesn't really seem worth it for the added complexity in error handling.\n\n> I think catching here incorrect values for MinValue/MaxValue would put capping sensor implementation (from DBus perspective) closer the original concept for MinValue/MaxValue (which could never be incorrect).\n\nAgreed, we should catch incorrect values....somewhere in here.  I suspect the driver is the better place to do it, otherwise, how do we know the difference between a valid value that looks odd in some contexts, and an actually bad value.\n\n> But maybe we should stop here for a moment and check whether capping sensor implementation is done with the right way. Maybe there should be three different sensors: capping, capping min, capping max?\n> Ed, what do you think?\n\n\nThat doesn't seem right.  \"capping min\" and \"capping max\" are not sensors.  For power cap, we already have an interface for tthat not based on sensors.\n\n> \n> Anyway I think both SDR IPMI commands handlers and ipmitool implementation shall be modified as well. Because right now it assumes MinValue/MaxValues shall be always valid. I mean there is a validation for that stuff in SDR IPMI commands handlers but in case it fails bad things happen.\n\nThat's the way it should be.  MinValue/MaxValue should always be valid, otherwise there's no way to generate a reasonable SDR.  IMO we should not be changing the IPMI SDR handlers in that way."
        },
        {
            "timestamp": 1610550313,
            "reviewer": {
                "name": "Zbigniew Lukwinski",
                "email": "zbigniew.lukwinski@linux.intel.com",
                "username": "zlukwins"
            },
            "message": "Patch Set 7:\n\n> Patch Set 7:\n> \n> > Patch Set 7:\n> > \n> > > Patch Set 7:\n> > > \n> > > (2 comments)\n> > > \n> > > > Patch Set 7:\n> > > > \n> > > > (3 comments)\n> > > > \n> > > > > Patch Set 7:\n> > > > > \n> > > > > (2 comments)\n> > > > > \n> > > > > > Patch Set 7:\n> > > > > > \n> > > > > > After quick discussion with Zhikui Ren and Team, decided to remove isPowerOn() check and keep last good readings on DBus instead of updating with NaN, 0 or other default value.\n> > > > > \n> > > > > You've deleted the code to publish NAN when the power is off on first boot.\n> > > > > \n> > > > > I really suspect we need to separate these into two commits.\n> > > > > 1. not updating dbus when we get \"bad\" values.\n> > > > > 2. Changing the power on policy.\n> > > > > \n> > > > > Each has some subtleties that needs its own testing.\n> > > > > \n> > > > > > \"1. these limits don't change that often\n> > > > > >  2. failure to read is rare and temporary\n> > > > > \n> > > > > When we fail to read, shouldn't we be getting an error code back?\n> > > > > \n> > > > > >  3. there is no extra corrective action can be taken or need to be taken for such failure except re-try again\".\n> > > > > > That way ipmitool sdr read will work in all cases, min < max, failed reading, power off.\n> > > > \n> > > > Agree that error case should respond with a proper error code. However I don't think that this property is the right \"channel\" to signal a problem. That one property on DBus should contain only reading values. If we want to signal errors with error codes, it should be done by an additional \"reading status\" property to separate logical function/meaning of these properties and their uses.\n> > > \n> > > Feel free to propose something different, but this is not the right forum to propose a \"reading status\" API.\n> > \n> > Hi,\n> > We trust the driver. Issue here is rather about the hardware which provides odd data, e.g. max value = 0. And this could happened because of wrong hardware configuration (jumpers, straps, etc.)\n> > I don't think driver should event try to correct such data. In this case we have hwmon driver which is pretty straightforward - reads data from CPU over PECI and provides this data to the sysfs. I am not sure whether we should add any logic here to correct data.\n> \n> If the driver is providing odd data, something is broken, and the driver should be fixed.\n\nOk, so we consider catching 'wrong' values already in the driver and try to handle them there.\n\n> \n> > We thought cpusensor is good place for catching such cases and do to propagate it because of the type of sensor we have here.\n> \n> The problem becomes that then we start adding lots of error conditions to cpusensor, and they get minimal reviews because it's not part of the kernel.  Having error handling in the kernel is better.\n> \n> > All of that here is about power capping sensor(s) which behaves with different way other sensors do. In case other sensor 'Value' is the reading from the hardware and 'MinValue/MaxValue' are hardcode to the -127/128 (recently change to 0/511). But here 'MinValue/MaxValue' are taken from hardware as well. \n> \n> Part of me wonders if we need to roll that back.  Having a flexible MinValue/MaxValue seems to be causing more problems than it's worth.  I need to think about that more, but the core of the problem here is that the SDR is now based on data read outside the BMC, which, as you point out means it can change over time.  The added precision on this one sensor doesn't really seem worth it for the added complexity in error handling.\n> \n\nMakes sense to me. So will prepare a patch about reverting 'flexible' MinValue/MaxValue for power cap.\n\n> > I think catching here incorrect values for MinValue/MaxValue would put capping sensor implementation (from DBus perspective) closer the original concept for MinValue/MaxValue (which could never be incorrect).\n> \n> Agreed, we should catch incorrect values....somewhere in here.  I suspect the driver is the better place to do it, otherwise, how do we know the difference between a valid value that looks odd in some contexts, and an actually bad value.\n> \n> > But maybe we should stop here for a moment and check whether capping sensor implementation is done with the right way. Maybe there should be three different sensors: capping, capping min, capping max?\n> > Ed, what do you think?\n> \n> \n> That doesn't seem right.  \"capping min\" and \"capping max\" are not sensors.  For power cap, we already have an interface for tthat not based on sensors.\n> \n\nWhat interface you mean?\n\n> > \n> > Anyway I think both SDR IPMI commands handlers and ipmitool implementation shall be modified as well. Because right now it assumes MinValue/MaxValues shall be always valid. I mean there is a validation for that stuff in SDR IPMI commands handlers but in case it fails bad things happen.\n> \n> That's the way it should be.  MinValue/MaxValue should always be valid, otherwise there's no way to generate a reasonable SDR.  IMO we should not be changing the IPMI SDR handlers in that way."
        },
        {
            "timestamp": 1610586178,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 7:\n\n> Patch Set 7:\n> \n> > Patch Set 7:\n> > \n> > > Patch Set 7:\n> > > \n> > > > Patch Set 7:\n> > > > \n> > > > (2 comments)\n> > > > \n> > > > > Patch Set 7:\n> > > > > \n> > > > > (3 comments)\n> > > > > \n> > > > > > Patch Set 7:\n> > > > > > \n> > > > > > (2 comments)\n> > > > > > \n> > > > > > > Patch Set 7:\n> > > > > > > \n> > > > > > > After quick discussion with Zhikui Ren and Team, decided to remove isPowerOn() check and keep last good readings on DBus instead of updating with NaN, 0 or other default value.\n> > > > > > \n> > > > > > You've deleted the code to publish NAN when the power is off on first boot.\n> > > > > > \n> > > > > > I really suspect we need to separate these into two commits.\n> > > > > > 1. not updating dbus when we get \"bad\" values.\n> > > > > > 2. Changing the power on policy.\n> > > > > > \n> > > > > > Each has some subtleties that needs its own testing.\n> > > > > > \n> > > > > > > \"1. these limits don't change that often\n> > > > > > >  2. failure to read is rare and temporary\n> > > > > > \n> > > > > > When we fail to read, shouldn't we be getting an error code back?\n> > > > > > \n> > > > > > >  3. there is no extra corrective action can be taken or need to be taken for such failure except re-try again\".\n> > > > > > > That way ipmitool sdr read will work in all cases, min < max, failed reading, power off.\n> > > > > \n> > > > > Agree that error case should respond with a proper error code. However I don't think that this property is the right \"channel\" to signal a problem. That one property on DBus should contain only reading values. If we want to signal errors with error codes, it should be done by an additional \"reading status\" property to separate logical function/meaning of these properties and their uses.\n> > > > \n> > > > Feel free to propose something different, but this is not the right forum to propose a \"reading status\" API.\n> > > \n> > > Hi,\n> > > We trust the driver. Issue here is rather about the hardware which provides odd data, e.g. max value = 0. And this could happened because of wrong hardware configuration (jumpers, straps, etc.)\n> > > I don't think driver should event try to correct such data. In this case we have hwmon driver which is pretty straightforward - reads data from CPU over PECI and provides this data to the sysfs. I am not sure whether we should add any logic here to correct data.\n> > \n> > If the driver is providing odd data, something is broken, and the driver should be fixed.\n> \n> Ok, so we consider catching 'wrong' values already in the driver and try to handle them there.\n> \n> > \n> > > We thought cpusensor is good place for catching such cases and do to propagate it because of the type of sensor we have here.\n> > \n> > The problem becomes that then we start adding lots of error conditions to cpusensor, and they get minimal reviews because it's not part of the kernel.  Having error handling in the kernel is better.\n> > \n> > > All of that here is about power capping sensor(s) which behaves with different way other sensors do. In case other sensor 'Value' is the reading from the hardware and 'MinValue/MaxValue' are hardcode to the -127/128 (recently change to 0/511). But here 'MinValue/MaxValue' are taken from hardware as well. \n> > \n> > Part of me wonders if we need to roll that back.  Having a flexible MinValue/MaxValue seems to be causing more problems than it's worth.  I need to think about that more, but the core of the problem here is that the SDR is now based on data read outside the BMC, which, as you point out means it can change over time.  The added precision on this one sensor doesn't really seem worth it for the added complexity in error handling.\n> > \n> \n> Makes sense to me. So will prepare a patch about reverting 'flexible' MinValue/MaxValue for power cap.\n\nCool.  I think that's the right path forward.\n\n> \n> > > I think catching here incorrect values for MinValue/MaxValue would put capping sensor implementation (from DBus perspective) closer the original concept for MinValue/MaxValue (which could never be incorrect).\n> > \n> > Agreed, we should catch incorrect values....somewhere in here.  I suspect the driver is the better place to do it, otherwise, how do we know the difference between a valid value that looks odd in some contexts, and an actually bad value.\n> > \n> > > But maybe we should stop here for a moment and check whether capping sensor implementation is done with the right way. Maybe there should be three different sensors: capping, capping min, capping max?\n> > > Ed, what do you think?\n> > \n> > \n> > That doesn't seem right.  \"capping min\" and \"capping max\" are not sensors.  For power cap, we already have an interface for tthat not based on sensors.\n> > \n> \n> What interface you mean?\n\nhttps://github.com/openbmc/phosphor-dbus-interfaces/blob/32304979b404c24e32f195d08c667e65b9b34695/xyz/openbmc_project/Control/Power/Cap.interface.yaml\n\n> \n> > > \n> > > Anyway I think both SDR IPMI commands handlers and ipmitool implementation shall be modified as well. Because right now it assumes MinValue/MaxValues shall be always valid. I mean there is a validation for that stuff in SDR IPMI commands handlers but in case it fails bad things happen.\n> > \n> > That's the way it should be.  MinValue/MaxValue should always be valid, otherwise there's no way to generate a reasonable SDR.  IMO we should not be changing the IPMI SDR handlers in that way."
        },
        {
            "timestamp": 1610611345,
            "reviewer": {
                "name": "Zbigniew Lukwinski",
                "email": "zbigniew.lukwinski@linux.intel.com",
                "username": "zlukwins"
            },
            "message": "Patch Set 7:\n\n> Patch Set 7:\n> \n> > Patch Set 7:\n> > \n> > > Patch Set 7:\n> > > \n> > > > Patch Set 7:\n> > > > \n> > > > > Patch Set 7:\n> > > > > \n> > > > > (2 comments)\n> > > > > \n> > > > > > Patch Set 7:\n> > > > > > \n> > > > > > (3 comments)\n> > > > > > \n> > > > > > > Patch Set 7:\n> > > > > > > \n> > > > > > > (2 comments)\n> > > > > > > \n> > > > > > > > Patch Set 7:\n> > > > > > > > \n> > > > > > > > After quick discussion with Zhikui Ren and Team, decided to remove isPowerOn() check and keep last good readings on DBus instead of updating with NaN, 0 or other default value.\n> > > > > > > \n> > > > > > > You've deleted the code to publish NAN when the power is off on first boot.\n> > > > > > > \n> > > > > > > I really suspect we need to separate these into two commits.\n> > > > > > > 1. not updating dbus when we get \"bad\" values.\n> > > > > > > 2. Changing the power on policy.\n> > > > > > > \n> > > > > > > Each has some subtleties that needs its own testing.\n> > > > > > > \n> > > > > > > > \"1. these limits don't change that often\n> > > > > > > >  2. failure to read is rare and temporary\n> > > > > > > \n> > > > > > > When we fail to read, shouldn't we be getting an error code back?\n> > > > > > > \n> > > > > > > >  3. there is no extra corrective action can be taken or need to be taken for such failure except re-try again\".\n> > > > > > > > That way ipmitool sdr read will work in all cases, min < max, failed reading, power off.\n> > > > > > \n> > > > > > Agree that error case should respond with a proper error code. However I don't think that this property is the right \"channel\" to signal a problem. That one property on DBus should contain only reading values. If we want to signal errors with error codes, it should be done by an additional \"reading status\" property to separate logical function/meaning of these properties and their uses.\n> > > > > \n> > > > > Feel free to propose something different, but this is not the right forum to propose a \"reading status\" API.\n> > > > \n> > > > Hi,\n> > > > We trust the driver. Issue here is rather about the hardware which provides odd data, e.g. max value = 0. And this could happened because of wrong hardware configuration (jumpers, straps, etc.)\n> > > > I don't think driver should event try to correct such data. In this case we have hwmon driver which is pretty straightforward - reads data from CPU over PECI and provides this data to the sysfs. I am not sure whether we should add any logic here to correct data.\n> > > \n> > > If the driver is providing odd data, something is broken, and the driver should be fixed.\n> > \n> > Ok, so we consider catching 'wrong' values already in the driver and try to handle them there.\n> > \n> > > \n> > > > We thought cpusensor is good place for catching such cases and do to propagate it because of the type of sensor we have here.\n> > > \n> > > The problem becomes that then we start adding lots of error conditions to cpusensor, and they get minimal reviews because it's not part of the kernel.  Having error handling in the kernel is better.\n> > > \n> > > > All of that here is about power capping sensor(s) which behaves with different way other sensors do. In case other sensor 'Value' is the reading from the hardware and 'MinValue/MaxValue' are hardcode to the -127/128 (recently change to 0/511). But here 'MinValue/MaxValue' are taken from hardware as well. \n> > > \n> > > Part of me wonders if we need to roll that back.  Having a flexible MinValue/MaxValue seems to be causing more problems than it's worth.  I need to think about that more, but the core of the problem here is that the SDR is now based on data read outside the BMC, which, as you point out means it can change over time.  The added precision on this one sensor doesn't really seem worth it for the added complexity in error handling.\n> > > \n> > \n> > Makes sense to me. So will prepare a patch about reverting 'flexible' MinValue/MaxValue for power cap.\n> \n> Cool.  I think that's the right path forward.\n> \n> > \n> > > > I think catching here incorrect values for MinValue/MaxValue would put capping sensor implementation (from DBus perspective) closer the original concept for MinValue/MaxValue (which could never be incorrect).\n> > > \n> > > Agreed, we should catch incorrect values....somewhere in here.  I suspect the driver is the better place to do it, otherwise, how do we know the difference between a valid value that looks odd in some contexts, and an actually bad value.\n> > > \n> > > > But maybe we should stop here for a moment and check whether capping sensor implementation is done with the right way. Maybe there should be three different sensors: capping, capping min, capping max?\n> > > > Ed, what do you think?\n> > > \n> > > \n> > > That doesn't seem right.  \"capping min\" and \"capping max\" are not sensors.  For power cap, we already have an interface for tthat not based on sensors.\n> > > \n> > \n> > What interface you mean?\n> \n> https://github.com/openbmc/phosphor-dbus-interfaces/blob/32304979b404c24e32f195d08c667e65b9b34695/xyz/openbmc_project/Control/Power/Cap.interface.yaml\n> \n> > \n> > > > \n> > > > Anyway I think both SDR IPMI commands handlers and ipmitool implementation shall be modified as well. Because right now it assumes MinValue/MaxValues shall be always valid. I mean there is a validation for that stuff in SDR IPMI commands handlers but in case it fails bad things happen.\n> > > \n> > > That's the way it should be.  MinValue/MaxValue should always be valid, otherwise there's no way to generate a reasonable SDR.  IMO we should not be changing the IPMI SDR handlers in that way.\n\nGoing to abandon this patch.\nThanks!"
        },
        {
            "timestamp": 1610616197,
            "reviewer": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "message": "Abandoned\n\nWe're going to revert previous change which introduced \"flexible\" min/max values in the CPUSensor."
        }
    ],
    "patchSets": [
        {
            "number": 1,
            "revision": "a2a216352df98db90b036d295a9207f3be3388a9",
            "parents": [
                "832a2c604956a2e37da9acedb32ebc8f6d9abae1"
            ],
            "ref": "refs/changes/73/38873/1",
            "uploader": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "createdOn": 1607420123,
            "author": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/COMMIT_MSG",
                    "line": 7,
                    "reviewer": {
                        "name": "Zbigniew Kurzynski",
                        "email": "zbigniew.kurzynski@intel.com",
                        "username": "zkurzyns"
                    },
                    "message": "Can we replace the `PECI` with `hwmon files` in this commit message?\nThe min/max values are taken from hwmon files and it doesn't matter which interface is used by the hwmon underneath."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 7,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Done"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 149,
                    "reviewer": {
                        "name": "Zbigniew Kurzynski",
                        "email": "zbigniew.kurzynski@intel.com",
                        "username": "zkurzyns"
                    },
                    "message": "Can we just use double, it seems that optional properties and not used here and it introduce unnecessary level of complication here.\nThen we can just do:\n\n   if (auto tmp = readFile(attrPath, CPUSensor::sensorScaleFactor))\n   {\n      newValue = *tmp;\n   } else {\n      newValue = std::numeric_limits<double>::quiet_NaN();\n   }"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 149,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Done"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 155,
                    "reviewer": {
                        "name": "Zbigniew Kurzynski",
                        "email": "zbigniew.kurzynski@intel.com",
                        "username": "zkurzyns"
                    },
                    "message": "Declare it as std::reference_wrapper<std::optional<double>> or just std::reference_wrapper<double> if you decide to not use the optional."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 155,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Done"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 188,
                    "reviewer": {
                        "name": "Zbigniew Kurzynski",
                        "email": "zbigniew.kurzynski@intel.com",
                        "username": "zkurzyns"
                    },
                    "message": "do not print this error message, this function is called in a loop and in case of permanent problem it will flood the journal with this message."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 188,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Done"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 189,
                    "reviewer": {
                        "name": "Zbigniew Kurzynski",
                        "email": "zbigniew.kurzynski@intel.com",
                        "username": "zkurzyns"
                    },
                    "message": "Can we use the std::any_of here? It will be more easier to understand it and the flag readFailed will not be needed at all."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 189,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Done"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 18,
                    "deletions": 0
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "type": "MODIFIED",
                    "insertions": 30,
                    "deletions": -27
                }
            ],
            "sizeInsertions": 30,
            "sizeDeletions": 27
        },
        {
            "number": 2,
            "revision": "323d79d9d3f54daf0a73e359f01393742553d24a",
            "parents": [
                "832a2c604956a2e37da9acedb32ebc8f6d9abae1"
            ],
            "ref": "refs/changes/73/38873/2",
            "uploader": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "createdOn": 1607446618,
            "author": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/COMMIT_MSG",
                    "line": 15,
                    "reviewer": {
                        "name": "Zhikui Ren",
                        "email": "zhikui.ren@intel.com",
                        "username": "ZhikuiRen"
                    },
                    "message": "Existing code does check for errors from hwmon files. \nWhat was causing SDR over IPMI fail? Is it the fact that the threshold value can be set to NaN and/or min can be greater than max?"
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 15,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Yes, when min >= max or they are equal to NaN, SDR fails. It should be also addressed in the ipmitool."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 203,
                    "reviewer": {
                        "name": "Zhikui Ren",
                        "email": "zhikui.ren@intel.com",
                        "username": "ZhikuiRen"
                    },
                    "message": "initialize the property with default min and max\nif (!isNan && newMin < newMax) \n        updateProperty(...)"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 203,
                    "reviewer": {
                        "name": "Zhikui Ren",
                        "email": "zhikui.ren@intel.com",
                        "username": "ZhikuiRen"
                    },
                    "message": "Reason is that I don't think we want to overwrite previous valid readings by the default min and max."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 203,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Wouldn't be better to change these values to some known defaults to signal a problem? \n...but that's also okay to not update with defaults and report previous values."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 203,
                    "reviewer": {
                        "name": "Zhikui Ren",
                        "email": "zhikui.ren@intel.com",
                        "username": "ZhikuiRen"
                    },
                    "message": "I think min and max don't change that often, if valid values have been read and it failed to read once, it is probably ok to just keep the existing value. Ideally, if it consistently fails for a certain number of time, maybe there is something wrong and good to flag it. But I am not sure it worth the complication here."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 18,
                    "deletions": 0
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "type": "MODIFIED",
                    "insertions": 35,
                    "deletions": -24
                }
            ],
            "sizeInsertions": 35,
            "sizeDeletions": 24
        },
        {
            "number": 3,
            "revision": "b6a48e52a78cfe988c25430f92bacbce7d209185",
            "parents": [
                "832a2c604956a2e37da9acedb32ebc8f6d9abae1"
            ],
            "ref": "refs/changes/73/38873/3",
            "uploader": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "createdOn": 1607960075,
            "author": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 18,
                    "deletions": 0
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "type": "MODIFIED",
                    "insertions": 32,
                    "deletions": -24
                }
            ],
            "sizeInsertions": 32,
            "sizeDeletions": 24
        },
        {
            "number": 4,
            "revision": "9c317e36665f26128a45576a9636d6ecea8848f7",
            "parents": [
                "832a2c604956a2e37da9acedb32ebc8f6d9abae1"
            ],
            "ref": "refs/changes/73/38873/4",
            "uploader": {
                "name": "Zbigniew Kurzynski",
                "email": "zbigniew.kurzynski@intel.com",
                "username": "zkurzyns"
            },
            "createdOn": 1608287319,
            "author": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 181,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "You've completely dropped this check.  Was that intentional?"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 181,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Thank you Ed for catching this. Yeah, I missed that check."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 149,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Initialize your variables."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 149,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Done"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 188,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "I suspect this needs to be !std::isfinite"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 199,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "The use of the lambda and std::any_of significantly complicates what looks to be a simple \"loop over elements and find ones not nand\"  Please write it as a simple loop."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 199,
                    "reviewer": {
                        "name": "Krzysztof Grobelny",
                        "email": "krzysztof.grobelny@intel.com",
                        "username": "krzysztof-i"
                    },
                    "message": "Wasn't algorithms like std::any_of intended to replace \"simple loop over elements\"."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 199,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Yes, for the cases where it makes code simpler, and more correct.  This does not appear to be one of those cases, as it seems to lengthen and make the code significantly more complex, as such, I'm having trouble reviewing it for correctness.\n\nTo be clear, I have no problem with std::algorithms if it makes the code more clear, but this does not appear to be one of those cases."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 18,
                    "deletions": 0
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "type": "MODIFIED",
                    "insertions": 31,
                    "deletions": -24
                }
            ],
            "sizeInsertions": 31,
            "sizeDeletions": 24
        },
        {
            "number": 5,
            "revision": "26cf3c8c2b3e94ef10c3b5664f2c9c7f7146d783",
            "parents": [
                "832a2c604956a2e37da9acedb32ebc8f6d9abae1"
            ],
            "ref": "refs/changes/73/38873/5",
            "uploader": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "createdOn": 1609775510,
            "author": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 201,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Ed, I've modified code as per your suggestions. Added check for isPowerOn() which is definitely needed here. \nAlso removed lambda and is_any(). You are right, this is a simple task here to be done and we don't need complex code to resolve that. \nFrom now, that code will update min and max values at the same time, only if min < max. If a platform is turned off, it sets NaN to min/max temp vars and we skip check for min < max (thus, I added check for isNaN(newMin) or isNaN(newMax) above). That way we will add new behavior only for the case of min >= max."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 18,
                    "deletions": 0
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "type": "MODIFIED",
                    "insertions": 28,
                    "deletions": -19
                }
            ],
            "sizeInsertions": 28,
            "sizeDeletions": 19
        },
        {
            "number": 6,
            "revision": "427625329a304fb1bc238f40a8a92083e6b5b4d2",
            "parents": [
                "6736d4b2a77cec00a8919f26035176c8b8025a4d"
            ],
            "ref": "refs/changes/73/38873/6",
            "uploader": {
                "name": "Zbigniew Lukwinski",
                "email": "zbigniew.lukwinski@linux.intel.com",
                "username": "zlukwins"
            },
            "createdOn": 1609838190,
            "author": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/COMMIT_MSG",
                    "line": 10,
                    "reviewer": {
                        "name": "Zhikui Ren",
                        "email": "zhikui.ren@intel.com",
                        "username": "ZhikuiRen"
                    },
                    "message": "Why not keep the last know good reading? These values don't change that often, right?"
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 11,
                    "reviewer": {
                        "name": "Zhikui Ren",
                        "email": "zhikui.ren@intel.com",
                        "username": "ZhikuiRen"
                    },
                    "message": "Seems like the only verification is min < max, is that correct? May want clarify here"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 198,
                    "reviewer": {
                        "name": "Zhikui Ren",
                        "email": "zhikui.ren@intel.com",
                        "username": "ZhikuiRen"
                    },
                    "message": "This does not look right - update is called if \n1. min or max file failed to read and power is off - why do we want to update in this case? \n2. min failed to read and power is on - maybe ok, min is set to 0\n3. both min and max fail to read - why do we want to update?\n4. both min and max are read and min < max - ok"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 198,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "> 1. min or max file failed to read and power is off - why do we want to update in this case?\n> 2. min failed to read and power is on - maybe ok, min is set to 0\n> 3. both min and max fail to read - why do we want to update?\nRegarding 1., 2., 3., that behavior is not introduced by my change. These cases have been serviced the same way before. I missed isPowerOn() check in the previous patch but Ed found that so now I corrected my mistake. In the past this part of code also has checked isPowerOn() and updated value with NaN in the case of power off.\nRegarding 2., I wonder if we should set max value to 127 when read failed and power is on? If not and, let's say read of both values failed, then min=max=0, and they will be not updated since it would introduce error in the ipmitool sdr read.\n\nIn fact, I did only 2 changes here: \ni) Added a check for min < max; \nii) Moved updateProperty() call, so both, min and max values, are updated at the same time. I think this is needed because we also read both values from hwmon at the same time. When value seems to be incorrect (resulting in min >= max), how can we be sure that other value is valid? Thus, adding code to update both at once causes that none of them is updated when min >= max."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 19,
                    "deletions": 0
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "type": "MODIFIED",
                    "insertions": 28,
                    "deletions": -19
                }
            ],
            "sizeInsertions": 28,
            "sizeDeletions": 19
        },
        {
            "number": 7,
            "revision": "acaba2fe6c2c86b0f8bbe657b94b60a5626d05e9",
            "parents": [
                "832a2c604956a2e37da9acedb32ebc8f6d9abae1"
            ],
            "ref": "refs/changes/73/38873/7",
            "uploader": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "createdOn": 1610045811,
            "author": {
                "name": "Wojciech Dembinski",
                "email": "wojciech.dembinski@intel.com",
                "username": "wdembinski"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/COMMIT_MSG",
                    "line": 16,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "what test cases.  Walk though what you did to test this."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 18,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Is it correct?  What are the limit values.  More information needed here."
                },
                {
                    "file": "/COMMIT_MSG",
                    "line": 18,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "Not sure what you meant by limit values?"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 155,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "can we make this into an actual struct?  Tuple was fine when it was 2 elements, but now that it's continuing to get bigger, and we don't actually use tuple for its intended purpose (variadic template construction) this would be much more clear as a hardened struct."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 187,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "If the read returned a valid value, how is it possible for the newMin < newMax check to fail?\n\nIf we're having cases where we hit the branch on 179, but this check fails, we need to go investigate the driver, not add more userspace checks."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 187,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "How do you know if the read returned a valid value? I mean, a file read could be successful but can we be sure about data provided by hardware?\n\nOn the other hand, talking about previous version of that function, why do we set a 0 value in the case when read fails but power is on? Shouldn't we have an additional property to signal the current reading status and not use this one to set some special values \n(0 or NaN in that particular case) which corresponds to some error cases?"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 187,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> How do you know if the read returned a valid value? I mean, a file read could be successful but can we be sure about data provided by hardware?\n\nI'm not following this question.  The hardware has lots of error handling mechanisms (checksums, parity, ect).  if any of those fail, the file should not read successfully.  If the file read successfully, and we trust the driver, we can trust the value it gave us.  If we don't trust the driver, we need to fix the driver.\n\n> \n> On the other hand, talking about previous version of that function, why do we set a 0 value in the case when read fails but power is on? Shouldn't we have an additional property to signal the current reading status and not use this one to set some special values \n> (0 or NaN in that particular case) which corresponds to some error cases?\n\nThe problem here becomes that these values aren't meant to ever be able to \"fail\" to read, given that they're being used to generate the SDR.  In most daemons they're a hardcoded value for the precision that sensor requires.  This is the only sensor that generates precision at runtime in a way that can fail.  Part of me wonders if we should roll this back and go back to the fixed precision.\n\nIs there a reason the added sub-degree precision is needed in this use case?"
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 188,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Please separate these and add appropriate logging if they're found to be incorrect."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 188,
                    "reviewer": {
                        "name": "Wojciech Dembinski",
                        "email": "wojciech.dembinski@intel.com",
                        "username": "wdembinski"
                    },
                    "message": "As indicated by one of the first comments, printing error message here, in a loop (that function is also called on a regular basis), in the case of a permanent problem, would make journal useless since it will be flooded with that particular error message."
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "line": 188,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Fair point.  How do you think we should log the error back?"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 21,
                    "deletions": 0
                },
                {
                    "file": "src/CPUSensor.cpp",
                    "type": "MODIFIED",
                    "insertions": 26,
                    "deletions": -24
                }
            ],
            "sizeInsertions": 26,
            "sizeDeletions": 24
        }
    ]
}