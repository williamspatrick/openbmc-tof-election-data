{
    "project": "openbmc/docs",
    "branch": "master",
    "id": "I3821b0ab23965acd2642e19946d9dc40f470bc0f",
    "number": 40289,
    "subject": "PLDM: Add a design for PLDM firmware update",
    "owner": {
        "name": "Deepak Kodihalli",
        "email": "deepak.kodihalli.83@gmail.com",
        "username": "dkodihal"
    },
    "url": "https://gerrit.openbmc.org/c/openbmc/docs/+/40289",
    "hashtags": [],
    "createdOn": 1612445967,
    "lastUpdated": 1665657985,
    "open": false,
    "status": "ABANDONED",
    "comments": [
        {
            "timestamp": 1612445967,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Uploaded patch set 1."
        },
        {
            "timestamp": 1612446115,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612464257,
            "reviewer": {
                "name": "Sumanth Bhat",
                "email": "sumanth.bhat@linux.intel.com",
                "username": "sumbhat90"
            },
            "message": "Patch Set 1:\n\n(3 comments)"
        },
        {
            "timestamp": 1612475320,
            "reviewer": {
                "name": "Adriana Kobylak",
                "email": "anoo@linux.ibm.com",
                "username": "anoo1"
            },
            "message": "Patch Set 1:\n\n(2 comments)"
        },
        {
            "timestamp": 1612482041,
            "reviewer": {
                "name": "zkxz",
                "email": "zkxz@hotmail.com",
                "username": "zkxz"
            },
            "message": "Patch Set 1:\n\n(1 comment)\n\nReally nice design, Deepak. Leaving some question there."
        },
        {
            "timestamp": 1612499073,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(6 comments)"
        },
        {
            "timestamp": 1612499571,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612511728,
            "reviewer": {
                "name": "Sumanth Bhat",
                "email": "sumanth.bhat@linux.intel.com",
                "username": "sumbhat90"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612512109,
            "reviewer": {
                "name": "Sumanth Bhat",
                "email": "sumanth.bhat@linux.intel.com",
                "username": "sumbhat90"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612773588,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 1: Code-Review-1\n\n(2 comments)\n\nFlow from bmcweb to PLDM daemon is what we need to ratify here, For PLDM Daemon (UA) to the FD it is well covered in DSP0267 related to the command flows"
        },
        {
            "timestamp": 1612774267,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612776337,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612776615,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612790456,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 1:\n\n(2 comments)"
        },
        {
            "timestamp": 1612802279,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612846375,
            "reviewer": {
                "name": "Sumanth Bhat",
                "email": "sumanth.bhat@linux.intel.com",
                "username": "sumbhat90"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612859244,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612939314,
            "reviewer": {
                "name": "Sumanth Bhat",
                "email": "sumanth.bhat@linux.intel.com",
                "username": "sumbhat90"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612945835,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612961634,
            "reviewer": {
                "name": "Arun P M",
                "email": "arun.p.m@linux.intel.com",
                "username": "arun-pm"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1612961827,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1613031261,
            "reviewer": {
                "name": "Sumanth Bhat",
                "email": "sumanth.bhat@linux.intel.com",
                "username": "sumbhat90"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1613043803,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1613385955,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Uploaded patch set 2."
        },
        {
            "timestamp": 1613671432,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 2:\n\n(8 comments)"
        },
        {
            "timestamp": 1613708363,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 2:\n\n(8 comments)"
        },
        {
            "timestamp": 1613913256,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1613929150,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 2:\n\n(6 comments)"
        },
        {
            "timestamp": 1613933044,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1613963420,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1613970374,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 2:\n\n(6 comments)"
        },
        {
            "timestamp": 1613972635,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 2:\n\n(6 comments)"
        },
        {
            "timestamp": 1613976601,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 2:\n\n(6 comments)"
        },
        {
            "timestamp": 1613978023,
            "reviewer": {
                "name": "Richard Marian Thomaiyar",
                "email": "richard.marian.thomaiyar@linux.intel.com",
                "username": "rthomaiy"
            },
            "message": "Patch Set 2:\n\n(5 comments)"
        },
        {
            "timestamp": 1613979099,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 2:\n\n(4 comments)"
        },
        {
            "timestamp": 1614150065,
            "reviewer": {
                "name": "Sumanth Bhat",
                "email": "sumanth.bhat@linux.intel.com",
                "username": "sumbhat90"
            },
            "message": "Patch Set 2:\n\n(5 comments)"
        },
        {
            "timestamp": 1614151403,
            "reviewer": {
                "name": "Sampa Misra",
                "email": "sampmisr@in.ibm.com",
                "username": "sampmisr"
            },
            "message": "Patch Set 2: Code-Review+1"
        },
        {
            "timestamp": 1614247859,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 2:\n\n(4 comments)"
        },
        {
            "timestamp": 1614250674,
            "reviewer": {
                "name": "Tom Joseph",
                "email": "rushtotom@gmail.com",
                "username": "tomjoseph83"
            },
            "message": "Patch Set 2:\n\n(9 comments)"
        },
        {
            "timestamp": 1619799531,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 2:\n\n@Deepak, are you still working on this?"
        },
        {
            "timestamp": 1622520424,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 2:\n\n> Patch Set 2:\n> \n> @Deepak, are you still working on this?\n\n@Patrick - Yes. I think it make take some time to converge to a design based on the discussion we've had here with Intel folks."
        },
        {
            "timestamp": 1622541211,
            "reviewer": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "message": "Patch Set 2:\n\n> Patch Set 2:\n> \n> > Patch Set 2:\n> > \n> > @Deepak, are you still working on this?\n> \n> @Patrick - Yes. I think it make take some time to converge to a design based on the discussion we've had here with Intel folks.\n\n@Patrick, there's also an alternate https://gerrit.openbmc-project.xyz/c/openbmc/docs/+/43660 now, which I just reviewed."
        },
        {
            "timestamp": 1665657985,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Abandoned\n\nclose due to inactivity"
        }
    ],
    "patchSets": [
        {
            "number": 1,
            "revision": "95628110bec07d692fa3a0da1e245168b9ab0dba",
            "parents": [
                "200e9db156579e144f6d96969d3cd301cadeed7d"
            ],
            "ref": "refs/changes/89/40289/1",
            "uploader": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "createdOn": 1612445967,
            "author": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/pldm-stack.md",
                    "line": 418,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Please set the 'diff width' in preferences to a value larger than 80 columns to be able to view this ascii diagram."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "why? So far we are using Phosphor-software-manager to do the update? Any specific reason for bmcweb to directly communicate with PLDMd?\nNote: \nThis will cause certain limitations\n1. Full image update level support will require changes in bmcweb (relying on phosphor-software-manager will not have this issue)\n2. what if BMC level image verification is required for certain devices?\n\nBasically, irrespective of whether the device uses Pldm or any other methodologies, the update mechanism from BMC must stand same, the diversification etc. must happen in terms of phosphor-software-manager and not in bmcweb.\nE.g. Whether BIOS is updated as normal image or PLDM model, flow from bmcweb must remain the same, and phosphor-software-manager, after doing image verification etc, and based on the header it can direct the required update mechanism (i.e. if it is PLDM request to PLDM daemon)."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Richard - What is exposed to bmcweb is a D-Bus API. This design is not proposing a change to how bmcweb activates firmware for PLDM images (please see details below in the description section). So, I am not sure I followed your concern. I don't think there is a guideline/reason that one application must house all varying implementations of a D-Bus API. For eg - bmcweb queries sensors/FRUs via well-known D-BUs APIs. Such sensor/FRU D-Bus objects can be housed by multiple daemons (that's the whole premise of having standard D-Bus APIs and bmcweb using mapper to find objects). In fact my concern with what you described above is we need phosphor-software-manager to deal with PLDM specifics - I want to avoid that."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Yes it is D-Bus, and technically possible.\nQuestion is why ? how we will handle full image update in that case? Does bmcweb takes care of individual update?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "> Yes it is D-Bus, and technically possible. Question is why?\nI'm not sure I am following. Can you elaborate the context?\n\nI'm not seeing the benefit of an additional D-Bus layer that phosphor-software-manager and PLDM would need to talk to each other."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "I agree with Deepak.  I don\u2019t think it is unreasonable for multiple applications to host the Update dbus functions.  We already have two implementations (one for BMC and one for Power host firmware).  This is just another one."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "@Sumanth or @Richard - please elaborate on how you think we'd want phosphor-software-manager to interact with pldm daemon - what does the D-Bus API look like? Based on that, I can capture that as an alternate design option and we can discuss and document pros/cons and then we can converge on one approach."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "@Deepak- Agree with your flow on the pldmd and bmcweb on FirmwareInventory flow. \n\nHowever, for the update flow, we think having the \"item manager\" functionality implemented in phosphor-software-manager would provide different BMC vendors to handle the update package the way they deem fit, and pldmd would still have the \"item updater\" functionality. Ex - A PLDM update package can be a signed one. Signature verification can be done in phosphor-software-manager. Phosphor-software-manager could also probe and find out the type of update package sent down by the user using some sort of meta-data like manifest file or probing into image headers.[Image could BMC/BIOS or others like PLDM/PSU/CPLD].\n\nIn the case of PLDM, we have a notion of IMAGE SET versioning. The PLDM update package could have multiple components targeted for multiple FDs (described in figure 6 of the spec). A typical use case could be A NIC vendor providing a single PLDM update package for different SKUs of a single generation of cards; the update package would have different component images targeting different FDs (that may or may not be in the server). The IMAGE SET version could be a good candidate for the phosphor-software-manager's version interface, and p-s-m could also host the update package's activation and activation-progress interface. The bmcweb user ,who initiated the update package, could get overall progress wrt to the entire bundle's update status.\n\nThus, in short, p-s-m can take care of vendor specific implementations like signature verification and host the version interface (based on the IMAGE SET version for pldm update package),activation and activation progress interface, and then place the PLDM only update package in a staging area (/tmp/images/pldm may be) which is compliant to Figure 6 in the spec. It could proceed to make a method call (from fwupd script ot any other mechanism) to pldmd with filepath of the PLDM only update package (if required, we could also pass the d-bus service name/object who is hosting the activation, activation-progress interfaces). \n\nFor pldmd, the update package is self descriptive and would be able to parse the headers and findout the intendent recipient of the update package (using the Device descriptors area) and then proceed with the update flow. It can update the activation state and progress interfaces hosted by p-s-m accordingly.\n\nThe advantage with this method is that pldmd would remain pure \"protocol\" daemon and customizations required by different vendors do not creep into pldmd."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "@Sumanth - I understand what you're saying, but there are other ways to solve this problem:\n\n>  pldmd would remain pure \"protocol\" daemon and customizations required by different vendors do not creep into pldmd.\nFor eg, we could come up with an image sign verification D-Bus API that p-s-m or something else can implement.\n\nWe have examples of separate process handling software management on their own - openpower PNOR and PSU code mgr. My concerns with the alternate approach are:\n- p-s-m needs to know about specific firmware update packages format, or we need to come up with additional manifest files and image purpose fields and p-s-m needs to know and maintain information that a certain image was PSU/BIOS/PLDM, etc.\n- Every item updater must provide/implement a D-Bus API for p-s-m to call into, at least to kick start activation and provide information about the objects implementing the version interface, activation interface, progress interface, etc.\n- Since pldm will not own the activation objects, creating associations with inventory objects becomes complex. We would need to provide more details on how the D-Bus APIs would look like.\n- while this approach claims that p-s-m is doing the imagemanager, in reality that image and version management has to be done by pldmd as well (for things like downstream devices)."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "My responses -\n\n\"p-s-m needs to know about specific firmware update packages format, or we need to come up with additional manifest files and image purpose fields and p-s-m needs to know and maintain information that a certain image was PSU/BIOS/PLDM, etc.\"\n- So the question here is whether the onus should be on the user to inform BMC about the update package type (via parameters in httpPushUri) or BMC to do self determination of the update package type. Take the case of PLDM only update package; a NIC vendor could have provided a pldmd update package with different component images for different SKUs. Some of the components might not be applicable to the target platform if they do not have such devices. In this scenario, should the user still need to list out all the FDs in httpPushUri ? Or should the user mention PLDM as the target? \n\n\"Every item updater must provide/implement a D-Bus API for p-s-m to call into, at least to kick start activation and provide information about the objects implementing the version interface, activation interface, progress interface, etc.\"\nEvery item updater can provide the same D-Bus API, quite similar to the FilePath interface you have proposed.\n\n\"Since pldm will not own the activation objects, creating associations with inventory objects becomes complex. We would need to provide more details on how the D-Bus APIs would look like.\nwhile this approach claims that p-s-m is doing the imagemanager, in reality that image and version management has to be done by pldmd as well (for things like downstream devices).\"\n\nAgree to this, I think we could move this to item updater.\n\nProbably we can traceout the update flow for the scenario for -\n1. Single PLDM update package which consists of multiple component images & images for downstream devices\n2. Same scenario as above, with the update package being signed\n\nFrom the user perspective how would the activation progress look like? Are we going to have D-Bus interfaces (like activation/progress) for each of the individual components that make up an PLDM update package?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Thanks, Sumanth. I will take a stab at updating the doc with the additional flows you mentioned shortly."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Hi Deepak,\nTechnically implementing the Verification / update logic in PLDMD is possible, but it has the following limitations.\n1. Image update will happen without the target (which is how BMC must be designed to eliminate any user mismatch errors and currently companies already doing the same). Target based approach is used when trying to update with a specific purpose.\n2. D-Bus API are designed for modularization, and you already stated that 2 modules already implement the same. Question is do we need to follow that suite ? I am worried in coming future, when we add further support, we will end up defining more complex D-Bus rather than current abstraction.\n3. Staging area / Image download / Synchronized firmware update across multiple user-level interfaces are always needed (including clean up). \n\nWhat i meant to say is abstraction, such that our major usage flow & future implementation will not have problem\n\nSoftware-Updater being the abstraction - purpose is to verify the image needed, protect it against multiple interface update request, clean up the image etc. Based on the image or requested target communicate it to the corresponding daemon.\n\nin short  Redfish / IPMI / etc. <--> software-updater <--> FW updating daemons (BMC / BIOS / PLDM / etc.)\n\nWith proper D-Bus API defined for both, flow will be simple and easy to maintain ? We can discuss the same in discord / meeting further"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "> 1. Image update will happen without the target (which is how BMC must be designed to eliminate any user mismatch errors and currently companies already doing the same). Target based approach is used when trying to update with a specific purpose.\n\nNot following this.\n\n> 2. D-Bus API are designed for modularization, and you already stated that 2 modules already implement the same. Question is do we need to follow that suite ? I am worried in coming future, when we add further support, we will end up defining more complex D-Bus rather than current abstraction.\n\nWhy do you think so? This design is not changing the existing D-Bus API.\n\n> 3. Staging area / Image download / Synchronized firmware update across multiple user-level interfaces are always needed (including clean up). \n\nThis design is not precluding the possibility of an image \"pre-processor\"."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Majority of the redfish client update will happen without target\n\ni.e. Post the image to the https://{bmcip}/redfish/v1/UpdateService and BMC must take care of updating the right component."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "From the Redfish update service schema on the use of HttpPushUriTargets:\n\n\"This property shall contain zero or more URIs that indicate where to apply the update image when using the URI specified by the HttpPushUri property to push a software image. These targets should correspond to SoftwareInventory instances or their related items. If this property is not present or contains no targets, the service shall apply the software image to all applicable targets, as determined by the service.\"\n\nSo a target may or may not be specified. The proposed design handles both scenarios. I don't want to comment on which is the majority. I know of platforms where we will rely on the target. I think that statistic is irrelevant as long as we make both options possible."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "My question, which one will be a better option (related to Pros / Cons & simplicity).\n\n1. Have a intermediate which will determine things and accordingly forward the same to necessary update service\nor\n2. Maintaining both direct models for target and intermediator too?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Right, what I'm not convinced about is mandating an intermediate service. An implementation could have it if intermediate non-PLDM things are to be dealt with. What implements the image manager and item updater - I'm proposing that should be in the pldmd, which is possible even if there is an intermediate service."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Yes, but i am saying we need to evaluate the same based on Pros / Cons, with all options, instead of technical possibility and accordingly choose better option. Don't want to end up in a model, which needs to be changed / providing with different option at later stage."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 444,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "I think the pros/cons I mentioned are buried in a comment somewhere to Sumanth. I think I should update the doc with the same. I can do that."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "How will PLDM know if an uploaded update image is applicable to a managed FD?  This is one big gap in our Software dbus interfaces that I\u2019d like to solve.  I don\u2019t like the current enumerations and continuing to add to them.  Maybe we can discuss on Discord what thought I\u2019ve already put into it."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "My thought (noted in 3e and 4 below) was to come up with a D-Bus interface that is something like xyz.openbmc_project.Software.ImageTarget (or a better name) that provides at least one property - the staging area of an image. The PLDM daemon would monitor one such staging area.\n\nPLDM could implement an /xyz/openbmc_project/software/pldm_imaget_target with the staging area set to /tmp/images/pldm. The BMC code udpate could host an /xyz/openbmc_project/software/bmc_image_target. The webserver could from this API make corresponding HTTP push targets.\n\nWe might have to deal with a case where the user pushes a 'single image' package to the BMC. In this scenario we might need bmcweb or some other entity to split the singe image and copy contained images into relevant staging areas.\n\nI will discuss your thoughts on this on Discord."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "@Patrick - PLDM Firmware Update specification provides a notion of Device Identifier record. This is unique to a class of device, this could something like PCIe Vendor ID-Device ID. Table 8 of DSP0267 describes the device descriptors supported for PLDM Firmware update.\n\nThe pldmd can query the device descriptors from a PLDM device during its discovery phase. During the update phase, the update package itself would contain the target device descriptors. Thus the update package (image blob) is self sufficient for pldmd to determine to which FD the update package is for."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "> During the update phase, the update package itself would contain the target device descriptors. Thus the update package (image blob) is self sufficient for pldmd to determine to which FD the update package is for.\n\nIdeally we would not be parsing every image that is ever uploaded to the BMC though.  We have some information in the VERSION and EXTENDED_VERSION fields of update files which give some indication which devices these are for.  There are also the 'VersionPurpose' field in the Software.Version interface.  My thinking is that we need to reconcile all these different fields against what/how PLDM will consume them.  I strongly suspect there are device types not already covered by 'VersionPurpose' and I'm not keen on adding additional ones, so I'd like to have another schema to handle the relationships between Versions and Devices."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Hi Patrick, \nUnfortunately, images already exists with this header usage and it can't be changed. i.e. BMC must be aware about this PLDM header and make use of it. \nIt can internally use the VERSION / EXTENDED_VERSION / PURPOSE, but we can't use the same here, as there can be different vendors / different models under vendor and sometimes same image working for different models of particular vendor.\n\nNow one of the thing which we need to integrate is to protect against in-compatible firmware update of a device. i.e. Say same network controller can be used by 2 different companies and we need to provide options for vendor verification, such that motherboard vendor approved images are only updatable (if needed for better security & compatibility control)."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "> Unfortunately, images already exists with this header usage and it can't be changed. i.e. BMC must be aware about this PLDM header and make use of it. \n\nHello Richard.  I don't know what you mean by this.  It is true that vendors might already have binary blobs built for their devices that are intended to be used by PLDM, but that isn't what I'm talking about.  The BMC code that handles the \"here is some software the BMC might be interested in updating\" only supports a tarball which contains a Manifest file.  The content in that tarball-manifest is what I'm concerned about."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "PLDM spec already defined how to correlate an image to the device (through it's meta data). i.e. Say a NIC device binary blob will be encapsulated with PLDM header (which will be used to tell, to what devices it supports). It also has a header to differentiate between PLDM & any other image type.\nNote: This is without any image verification / signing which BMC may be required. \n\nhttps://github.com/Intel-BMC/openbmc/blob/intel/meta-openbmc-mods/meta-common/recipes-phosphor/flash/phosphor-software-manager/0016-Process-PLDM-image-type.patch#L75"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "I think we might be talking about multiple things here. This is my take away:\n- PLDM fw update package is self-describing\n- We don't want to enforce PLDM-processing capabilities to be implemented in the phosphor-sfotware-manager code\n- I know this is Redfish specific, but we must talk about it in this design. Redfish's update service says *both*: a) A user must be able to upload an image to the BMC without specifying a target (and the BMC must determine and then apply that to appropriate targets). 2) A user must be able to specify the target for an image. The proposed design here enables both possibilites."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Not saying it needs to be implemented in phosphor-software-manager. Because the earlier design requires some D-Bus API update which needs to be taken care.\n\nWhat i meant to say is why can't we go for a Intermediator, which takes care and define proper D-Bus API (Acceptable) to the update service ? (whether the phosphor-software-manager / or new daemon is also fine)."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "This design doesn't preclude an optional intermediate non-PLDM service for handling things like image signature verification, etc. However I'm not convinced we should mandate this, and moreover have the intermediate service implement the Software Management D-Bus API. What I've proposed contains the implementation of the Software D-Bus API within PLDM, with the optional use of an intermediate service. I'm yet to see feedback on why the latter is not possible (I see staging area cleanup being mentioned, but no details on what the problem there is)."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Question is who will be cleaning up the staging area / maintaining it (with the optional proposal). \nAs of today,\n1. Phosphor-software-manager\n2. Power supply\n3. Optional intermediatery\n\nnow, if the image is not matching any of this, how each process knows the same and cleans it up ?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 475,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Each process does not need to know of the image. A process receives an image when someone delivers it to the staging area that the process watches. The process is responsible for cleaning up that staging area. If you mean to ask about a process that's responsible to catch images where the target has not been specified, then yes that's the intermediate service I've been talking about. That has it's own staging area, which based on the implementation can be the same staging area that p-s-m watches today (and p-s-m could be the intermediate service as well)."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 519,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "could be an array of FDs?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 519,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Yes. There is actually an array of HttpPushUris in Redfish (please see 4)."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 523,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "Would we need Manifest file for PLDM update? The image payload should be self descriptive, no? \n\nFigure 6 of DSP0267 v1.1 provides the \"image payload\" details - it consists of a package header that describes the target FDs, Image Set version, individual component version numbers. This should give us an option to skip keeping the manifest file altogether."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 523,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "I agree that the PLDM daemon would be able to prepare the payload header. However, how does it determine the version?\n\nOr, did you indicate that the payload pushed to the Redfish endpoint must already be a PLDM payload (i.e PLDM format header + binary image)? I was thinking this shouldn't be mandated."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 523,
                    "reviewer": {
                        "name": "Arun P M",
                        "email": "arun.p.m@linux.intel.com",
                        "username": "arun-pm"
                    },
                    "message": "As per my understanding the image uploaded by the user from redfish targeted to a PLDM device will comply PLDM firmware update package format(i.e PLDM format header + binary image). The PLDM header will not be created by PLDM daemon. Is that not the case?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 523,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "> As per my understanding the image uploaded by the user from redfish targeted to a PLDM device will comply PLDM firmware update package format(i.e PLDM format header + binary image)\n\nThat is correct. Might need another layer if there is a single image tarball consisting of PLDM and non-PLDM FW payloads."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 525,
                    "reviewer": {
                        "name": "Adriana Kobylak",
                        "email": "anoo@linux.ibm.com",
                        "username": "anoo1"
                    },
                    "message": "nit: 'staging'"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 525,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 529,
                    "reviewer": {
                        "name": "Adriana Kobylak",
                        "email": "anoo@linux.ibm.com",
                        "username": "anoo1"
                    },
                    "message": "This proposal looks pretty good. Looking to see if we could add a bit more details on an example. Above you mentioned that the webserver could do an HttpPushUri on endpoint /redfish/v1/UpdateService/inventory/nic0 to trigger the update. How would the PLDM service watching the staging area know this image is targeted for that FD?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 529,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "> How would the PLDM service watching the staging area know this image is targeted for that FD?\nThe staging area is specific to an FD (at least that's what I proposed above).\n\nI will add two additional flows detailing Redfish-PLDM interaction and UA-FD interaction."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 549,
                    "reviewer": {
                        "name": "zkxz",
                        "email": "zkxz@hotmail.com",
                        "username": "zkxz"
                    },
                    "message": "Will UA send *ActivateFirmware* automatically after *ApplyComplete* or depends on user options? Firwmare activation should be a separate action from firmware flashing, and let user decide when to activate."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 549,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "You're right - that depends on what the FD expects. There are properties on the FD that the UA will query to determine how the Activation should happen. If that says a reset is required, then the onus is on the user to perform a reset via another Redfish API."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 556,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "Agree with the high level flow. However, additional things can be taken care of:\n\n1) The update package could target multiple FDs and each of those FDs could have only a subset of component images applicable to them. \nIn section 7.1 of DSP0267 v1.1 describes this. Thus we could potentially loop over the list of FD, and update all the matched FDs before we proceed with the activation step.\n\n2) There could be multiple instances of the FD in the system (ex: multiple NIC cards from the same vendor would have same FDs). Are we going to update only the inventory item targeted by *HttpPushUri* ?\n\nAlso this section could benefit from a flow diagram describing UA - FD interactions, I think."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 556,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "HttpPushUriTargets is actually an array (please see 4), so yes this can target multiple FDs in one shot. I think this again goes back to what you think the Redfish payload should be - just firmware image blobs or a PLDM firmware image payload.\n\nI will add two additional flows detailing Redfish-PLDM interaction and UA-FD interaction (though the latter is well described in DSP0267)."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 556,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Sumanth - I think you're right. The payload even at Redfish level must be as per Figure 6 of DSP0267. That actually simplifies things a bit. However let's discuss if that assertion can cause problems."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 556,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "Yes, with the mechanisms provided in the FWU specification, (since the update package is self descriptive) we wouldn't require an external agent informing pldmd about the target of the update package. This just means that pldmd can simply determine the target FD just by parsing the update package headers.\n\nWhat this could essentially mean is that the current update service can stage the pldm update packages in a predetermined area and not bother about the target FD at all. We would still require the software.version, software.activation and other interfaces mentioned in 3, this would be required for Firmware Inventory, as you have noted."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 556,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "Also, any thoughts on security aspects? The PLDM firmware update specification doesn't mandate anything on the UA (onus is on the FD), however if device vendors decide to add security related headers in the update package, where would we handle it? (Perhaps a provision in pldmd to handle custom headers in the update package? or handle it in phosphor-software-manager?)"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 556,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Yes. This is needed, esp. option to allow vendor signing is essential to avoid compatibility issues."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 14,
                    "deletions": 0
                },
                {
                    "file": "designs/pldm-stack.md",
                    "type": "MODIFIED",
                    "insertions": 173,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 187,
            "sizeDeletions": 0
        },
        {
            "number": 2,
            "revision": "606d60e2416e5d5ec2544b45c26c032f5da765c6",
            "parents": [
                "200e9db156579e144f6d96969d3cd301cadeed7d"
            ],
            "ref": "refs/changes/89/40289/2",
            "uploader": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "createdOn": 1613385955,
            "author": {
                "name": "Deepak Kodihalli",
                "email": "deepak.kodihalli.83@gmail.com",
                "username": "dkodihal"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/pldm-stack.md",
                    "line": 392,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Update Agent"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 392,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 417,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "These words little bit confusing (better to rewrite to make it clear)\nDSP0267 doesn't talk about how all the downstream devices with it's instances must be updated. I meant, the structure of the PLDM & DSP0267, states, how matching of the FD and it's device descriptors has to be done, but limiting the same to single device or single instance of a device types etc. is beyond the scope of the DSP0267, i meant that will be part of OpenBMC / Redfish UpdateService usage scenario --> where how we will update multiple targeted device."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 417,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "DSP0267 does talk about this in section 7."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 417,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Nope. We have wording for single image updating for multiple models of the same component, but the order in which it needs to be updated etc., are beyond the scope of the DSP0267."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 417,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "> Nope.\nTo what statement above?\n\n> We have wording for single image updating for multiple models of the same component\nWhich is what I am describing above.\n\n> but the order in which it needs to be updated etc\nI haven't used the word order at all above."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 417,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "@416 conveys different meaning."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 417,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Different than the spec? I don't see how. The spec allows for what I've mentioned in line 416 based on the PLDM fw update image layout."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 417,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "@Deepak, on a different note - There could be an image which has few components images applicable for the devices in the system, and few component images which are not in the system.\n\nA typical usecase would be - say a device vendor could choose to release an update package for devices A1, A2 AND A3 (A3 device not present in the system). In this case, what would the HttpPushUriTarget would look like?\n\nAlso, PLDM allows for a device to support multiple component images. Say a device A1 could support two firmware components, and the update package for A1 could have either of the two components. How would the httpPushUri look like in this case?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 417,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "@Sumanth - the PLDM daemon could just expose one target URI for all PLDM enabled devices. I think we could configure in flexibility based on the platform's requirements. One URI for all PLDM enabled devices could be the default option - pldmd can determine all PLDM devices connected to the MC via discovery. I believe this should answer a similar question you have in another comment."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 429,
                    "reviewer": {
                        "name": "Tom Joseph",
                        "email": "rushtotom@gmail.com",
                        "username": "tomjoseph83"
                    },
                    "message": "What does the 4 highlight?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 434,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "Are we saying that pldmd will create a single software inventory with the related items? How would pldmd determine the relations?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 470,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "This brings following problem\nHaving separate staging area for different types of images\n1. How we will identify the device type, even before downloading for common update model.\n2. How staging area size is going to be maintained? Are we going to limit for each or combine it."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 470,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "The proposed design is not precluding an image-preprocessor. Please see special case below."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 470,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Proposed design talks about separate staging area right?, then the problem exists"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 470,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "What problem exists? The proposed design talks about optional pre-processing (signature verification, single image, etc) performed by a daemon other than pldmd."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 470,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "1. How multiple staging area size s going to be maintained? Are we going to limit for each or combined limitation? or no limitation.\n2. Cleanup of staging area, when the optional pre-processing is done? How we will determine, who has to clean the same ? How it will co-work with existing staging area watchers"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 470,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "> 1. How multiple staging area size s going to be maintained? Are we going to limit for each or combined limitation? or no limitation.\nI don't understand this question, sorry.\n\n> 2. Cleanup of staging area, when the optional pre-processing is done? How we will determine, who has to clean the same ? How it will co-work with existing staging area watchers\nWith the current proposal, two different services are not watchin the same staging area. When a service is done with its handling of an image, it clears the staging area, and it might optionally have to move the whole or part of the image other staging areas."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 470,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "with the optional \"pre-processing proposal\" is what my question is. Are you saying even that one needs different staging area?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 470,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Yes. One staging area for the case where the update target is not specified. Staging areas for the cases where specific update targets are desired."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 473,
                    "reviewer": {
                        "name": "Tom Joseph",
                        "email": "rushtotom@gmail.com",
                        "username": "tomjoseph83"
                    },
                    "message": "s/so/to"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 478,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "staging :)"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 478,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Lol, I will get it right the next time :)"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 478,
                    "reviewer": {
                        "name": "Tom Joseph",
                        "email": "rushtotom@gmail.com",
                        "username": "tomjoseph83"
                    },
                    "message": "s/staring/staging"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 481,
                    "reviewer": {
                        "name": "Tom Joseph",
                        "email": "rushtotom@gmail.com",
                        "username": "tomjoseph83"
                    },
                    "message": "the service?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 485,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "typo"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 485,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 485,
                    "reviewer": {
                        "name": "Tom Joseph",
                        "email": "rushtotom@gmail.com",
                        "username": "tomjoseph83"
                    },
                    "message": "typo:makes"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 559,
                    "reviewer": {
                        "name": "Tom Joseph",
                        "email": "rushtotom@gmail.com",
                        "username": "tomjoseph83"
                    },
                    "message": "related"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 572,
                    "reviewer": {
                        "name": "Tom Joseph",
                        "email": "rushtotom@gmail.com",
                        "username": "tomjoseph83"
                    },
                    "message": "Will PLDM FW update images have a single staging area?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 573,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "This is the new flow, and the same requires changes in the bmcweb too, as the download is done by bmcweb to a proper staging area\nThis also brings further problems\n1. How user level interface determines staging area, when the target is not known -> We require a general daemon to handle the same.\n2. If we proceed this way then many staging areas will be needed, also cleaning up those is required\n3. Backward compatibility - by saying if advertised target device doesn't expose stagingArea dir then do it in normal form. \n\nThese designs support the model with specified target, but in reality firmware update in the industry are specified or even redfish client\nsupport model is to update the image, without specifying target and BMC takes care of implementing the same. \n\nConsider a scenario of board having 5 Add-on-card or some more components, now in those, few cards can support PLDM, and few won't. In majority of the cases\nredfish client must send out the image and BMC must take care which target must be updated etc. and only in limited number of cases target will be specified. Hence my view is to choose the design / flow which supports the majority use-case and rest needs to be solved."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 573,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Please see line 472."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 573,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "As per 472, (optional proposal), we will face the said problem right?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 573,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "No, we will not. That optional section is described precisely to tackle pre-processing by a daemon other than pldmd. The other things you mentioned (cleaning up staging area) - I'm not seeing what the issue is."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 573,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "1. How we will make sure, which daemon's responsibility to clean the staging area, when the image download is not matching / corrupted?\n2. How different user interface update mechanism works. Protection against Redfish / IPMI / any other interface requesting update too."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 573,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "I answered 1) in another comment. I think I need more details about what you're saying in 2. Can you take an example and explain?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 573,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "which comment. \nRefer the question in different words here, hope this clarifies --> https://gerrit.openbmc-project.xyz/c/openbmc/docs/+/40289/1/designs/pldm-stack.md#475"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 588,
                    "reviewer": {
                        "name": "Tom Joseph",
                        "email": "rushtotom@gmail.com",
                        "username": "tomjoseph83"
                    },
                    "message": "implementing"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 596,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Do we have a document which talks about this flow ?\nReason, This itself require a proper documentation, Say cleanup of staging area, during mismatch etc. and all those steps."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 596,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "We can update this document. Can you elaborate?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 596,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Few things like, when & which daemon's responsibility to clean the downloaded image Success & Failure case"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 596,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "I can update this."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 603,
                    "reviewer": {
                        "name": "Tom Joseph",
                        "email": "rushtotom@gmail.com",
                        "username": "tomjoseph83"
                    },
                    "message": "typo"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 613,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "Not for all cases though. Today a FD can take the new image activation only after a Host reset or medium reset\nwhich we can't inform the Redfish client."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 613,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Right, that's why I said \"might\". I can add other examples."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 613,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "It has been mentioned as \"must be handled by the PLDM Service\""
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 613,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "It's an if-then clause. The \"if\" is not mandatory."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 613,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "I am talking about content in the else part (Not if-else case). \n\nI meant to say replace the must with may.\n\n\"the latter case may be handled by the PLDM service (may require intervention from a Redfish client)\".\n\n\nNot all the else case can be recovered through Redfish client. Certain interface may require physical reset and based on the need it can be done through regular reset or AC removal etc. It all depends on the interface."
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 613,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 638,
                    "reviewer": {
                        "name": "Sumanth Bhat",
                        "email": "sumanth.bhat@linux.intel.com",
                        "username": "sumbhat90"
                    },
                    "message": "nitpick: inventory"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 638,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 653,
                    "reviewer": {
                        "name": "Richard Marian Thomaiyar",
                        "email": "richard.marian.thomaiyar@linux.intel.com",
                        "username": "rthomaiy"
                    },
                    "message": "what if there is another NIC, which doesn't support PLDM, but firmware update through IPMB? Now when that image is sent what we will be doing?"
                },
                {
                    "file": "designs/pldm-stack.md",
                    "line": 653,
                    "reviewer": {
                        "name": "Deepak Kodihalli",
                        "email": "deepak.kodihalli.83@gmail.com",
                        "username": "dkodihal"
                    },
                    "message": "Please see line 472."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 14,
                    "deletions": 0
                },
                {
                    "file": "designs/pldm-stack.md",
                    "type": "MODIFIED",
                    "insertions": 273,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 287,
            "sizeDeletions": 0
        }
    ]
}