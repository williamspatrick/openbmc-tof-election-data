{
    "project": "openbmc/docs",
    "branch": "master",
    "id": "I541eea1cc0b3c80d449e2c6ca42ba5cf5dbca233",
    "number": 50509,
    "subject": "Add I2C device management daemon design doc",
    "owner": {
        "name": "Justin Ledford",
        "email": "justinledford@google.com",
        "username": "justinledford"
    },
    "url": "https://gerrit.openbmc.org/c/openbmc/docs/+/50509",
    "hashtags": [],
    "createdOn": 1642626680,
    "lastUpdated": 1665657908,
    "open": false,
    "status": "ABANDONED",
    "comments": [
        {
            "timestamp": 1642626680,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Uploaded patch set 1."
        },
        {
            "timestamp": 1642628363,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 1:\n\n(7 comments)"
        },
        {
            "timestamp": 1642634053,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 1:\n\n(10 comments)"
        },
        {
            "timestamp": 1642634055,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Uploaded patch set 2."
        },
        {
            "timestamp": 1642634080,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Patch Set 2:\n\n(7 comments)"
        },
        {
            "timestamp": 1642637013,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Uploaded patch set 3."
        },
        {
            "timestamp": 1642637029,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Patch Set 3:\n\n(5 comments)"
        },
        {
            "timestamp": 1642637189,
            "reviewer": {
                "name": "Jason Ling",
                "email": "jasonling@google.com",
                "username": "jclaz"
            },
            "message": "Patch Set 3:\n\n(2 comments)"
        },
        {
            "timestamp": 1642639301,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1642640120,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 3:\n\n(6 comments)"
        },
        {
            "timestamp": 1642640279,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1642649990,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 3:\n\n(4 comments)"
        },
        {
            "timestamp": 1642700033,
            "reviewer": {
                "name": "Jason Ling",
                "email": "jasonling@google.com",
                "username": "jclaz"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1642701125,
            "reviewer": {
                "name": "Jason Ling",
                "email": "jasonling@google.com",
                "username": "jclaz"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1642701275,
            "reviewer": {
                "name": "Jason Ling",
                "email": "jasonling@google.com",
                "username": "jclaz"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1642702069,
            "reviewer": {
                "name": "Jason Ling",
                "email": "jasonling@google.com",
                "username": "jclaz"
            },
            "message": "Patch Set 3:\n\n(1 comment)"
        },
        {
            "timestamp": 1642705389,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Uploaded patch set 4."
        },
        {
            "timestamp": 1642705562,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1642711752,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 4:\n\n(1 comment)"
        },
        {
            "timestamp": 1642721250,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 4:\n\n(2 comments)"
        },
        {
            "timestamp": 1643157452,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Uploaded patch set 5."
        },
        {
            "timestamp": 1643157475,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Patch Set 5:\n\n(2 comments)"
        },
        {
            "timestamp": 1643847435,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1643930131,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 5:\n\n(18 comments)"
        },
        {
            "timestamp": 1644260415,
            "reviewer": {
                "name": "Jason Ling",
                "email": "jasonling@google.com",
                "username": "jclaz"
            },
            "message": "Patch Set 5:\n\n(7 comments)"
        },
        {
            "timestamp": 1644261825,
            "reviewer": {
                "name": "Peter Lundgren",
                "email": "peterlundgren@google.com",
                "username": "peterlundgren"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1644305968,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 5:\n\n(2 comments)"
        },
        {
            "timestamp": 1644344666,
            "reviewer": {
                "name": "Peter Lundgren",
                "email": "peterlundgren@google.com",
                "username": "peterlundgren"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1644346888,
            "reviewer": {
                "name": "Jason Ling",
                "email": "jasonling@google.com",
                "username": "jclaz"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1644348364,
            "reviewer": {
                "name": "Peter Lundgren",
                "email": "peterlundgren@google.com",
                "username": "peterlundgren"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1644374537,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 5:\n\n(7 comments)"
        },
        {
            "timestamp": 1644621839,
            "reviewer": {
                "name": "Zev Weiss",
                "email": "zev@bewilderbeest.net",
                "username": "zevweiss"
            },
            "message": "Patch Set 5:\n\n(2 comments)"
        },
        {
            "timestamp": 1645050771,
            "reviewer": {
                "name": "Michael Jones",
                "username": "Proclivis"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1646763196,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1646768819,
            "reviewer": {
                "name": "Jason Ling",
                "email": "jasonling@google.com",
                "username": "jclaz"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1646787213,
            "reviewer": {
                "name": "Andrew Jeffery",
                "email": "andrew@aj.id.au",
                "username": "amboar"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1646790409,
            "reviewer": {
                "name": "Peter Lundgren",
                "email": "peterlundgren@google.com",
                "username": "peterlundgren"
            },
            "message": "Patch Set 5:\n\n(2 comments)"
        },
        {
            "timestamp": 1647971917,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Patch Set 5:\n\n(1 comment)"
        },
        {
            "timestamp": 1665657908,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Abandoned\n\nclose due to inactivity"
        }
    ],
    "patchSets": [
        {
            "number": 1,
            "revision": "1dd6a7dc3c0185fd1111013778db57a88949e8bd",
            "parents": [
                "8deacbf78474b1adbdfca4a78cc712de07b6f645"
            ],
            "ref": "refs/changes/09/50509/1",
            "uploader": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "createdOn": 1642626680,
            "author": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Hi Justin,\n\nI have concerns along the same lines as Patrick. I've made my own comments where I've seen fit."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 9,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Please use 'i2c'.  This makes it really annoying to grep for."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 9,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "+1"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 9,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 10,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "I'll read further but \"a single daemon for everything i2c\" doesn't really sound great to me.  Can we / should we scope this a little bit?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 10,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "+1\n\nI don't see what's written as a problem description. As it stands it's more of a solution description, which isn't what we're after?\n\nWhy do we need a single daemon for this? The \"Problem Description\" section is where you should provide motivating use-cases that expose bad or missing behaviour in OpenBMC. It shouldn't mention solutions.\n\nOtherwise it sounds like your problem is that what you've already implemented needs to be accepted by the community, which isn't how this works."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 10,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "It's not really a daemon for everything i2c, but for devices that require more than just telemetry so that all access to that device is encapsulated in a single application. I reworded the description to reflect this."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 10,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Good point, I reworded the problem description to be an actual problem description."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 24,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I'm not sold on this. No matter what, it requires some orchestration of userspace. Having a single daemon do multiple things doesn't prevent me swinging in and running some random `i2cset -f`s on the device while the daemon is running.\n\nWhat level of assurance are we trying to achieve with this proposal?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 24,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "This daemon would act as a kind of gatekeeper for i2c access to a device to try and reduce the issues described. Of course anyone could start running raw i2c commands and interfere with everything, but the motivation of this daemon is to encapsulate any access required and manage the coordination away from the user. So if the user needs to perform a firmware upgrade, that user doesn't need to worry about disabling telemetry, etc, it all happens under the hood of this application."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 24,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "Suppose we decided to go with two daemons. Existing dbus-sensors daemon and add another daemon to manage firmware upgrades and possibly other things (e.g black box record retrieval)\nNow the firmware upgrade daemon must coordinate with the sensor daemon to pause telemetry to do upgrades and then resume the sensor daemon when done.\n\nInstead the decision was made to package this together into a single daemon to eliminate this coordination.\n\nAs far as other applications coming in and forcing i2c transactions on that device.. I'm not aware of anything that can prevent that scenario."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 24,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> As far as other applications coming in and forcing i2c transactions on that device.. I'm not aware of anything that can prevent that scenario.\n\nRight, it was an extreme example and a bit unhelpful. I'll move on :)"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 31,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "What does this look like from a practical, implementation standpoint? I2C devices don't have to have any particular command interfaces, though there are some popular ones (PMBus). How is this expected to work if there's a kernel driver bound to the device?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 31,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "This daemon would potentially unbind any hwmon drivers before writing firmware, and then rebind them after the firmware is written."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 31,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "The Dbus interface here are the generic ItemUpdater/ItemManager interfaces found in phosphor-dbus-interfaces (https://github.com/openbmc/phosphor-dbus-interfaces/tree/master/yaml/xyz/openbmc_project/Software)\n\nThis daemon's intent is to allow users to update pmbus devices just like they would update BMCs.\n\nAs far as accessing the i2c devices.. There are a few approaches but mostly leaving this as an implementation detail.\n1.) IIRC, you can force i2c transactions even if there is a driver bound to the device.\n2.) You can always userspace unbind the driver and then rebind it when done\n3.) Just do everything in userspace and forget about the hwmon sysfs interface.\n4.) painstakingly go through every pmbus driver and add device upgrade features..but first standardize it as part of hwmon and get maintainer buy-in.\nWe've tried this in the past and it was rejected."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 31,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "> As far as accessing the i2c devices.. There are a few approaches but mostly leaving this as an implementation detail.\n> 1.) IIRC, you can force i2c transactions even if there is a driver bound to the device.\n\nYeah, but I expect we agree that this is a bad idea.\n\n> 2.) You can always userspace unbind the driver and then rebind it when done\n\nOkay, so the intent is to do this when the kernel interface does provide all the necessary information?\n\n> 3.) Just do everything in userspace and forget about the hwmon sysfs interface.\n\nIt's a big hammer, but sure. It's probably worthwhile looking at the phosphor-power repo as it sorta goes in the same direction. Maybe can even be generalised? Anyway, it at least already has a userspace implementation for handling PMBus devices.\n\n> 4.) painstakingly go through every pmbus driver and add device upgrade features..but first standardize it as part of hwmon and get maintainer buy-in.\n> We've tried this in the past and it was rejected.\n\nRight, it'd be good to link to this discussion in the proposal! It's certainly good fodder for the \"Alternatives Considered\" section that the design document template contains (but isn't present in this proposal)."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 31,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "> Okay, so the intent is to do this when the kernel interface does provide all the necessary information?\nYes if an existing kernel interface provides telemetry, we can unbind the driver for accessing the device for other needs.\n\nI added an Alternatives Considered section with details on how we considered extending hwmon drivers and using phosphor-power."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 31,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Thanks"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 31,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 33,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "How does this interact with existing sensors presented by dbus-sensors / phosphor-hwmon?  We already have implementations for anything exported by the hwmon subsystem in the kernel and a large percentage of those are i2c.  Again, we probably want to scope the ambition here a little?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 33,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "+1"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 33,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "A device with sensors presented from this daemon shouldn't also have sensors reported by another daemon. This daemon could include implementations for reading from hwmon drivers, or in the device-specific code contained in this daemon. (added this to the doc)"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 34,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Do we have any examples?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 34,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Yes, added one here."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 36,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "How do you provided a consistent interface to do this? This makes it sound like you're trying to insert an entire layer of indirection between applications and I2C devices, and it feels like a recipe for performance issues."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 36,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "If another application is trying to report info from this device and is performance critical, its logic should probably belong in this daemon."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 36,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Ack"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 44,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "This seems self-contradictory.  Nothing, except BMCWeb, directly exposes Redfish anyhow, so what are you getting at?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 44,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Right, I just wanted to express that this daemon isn't exposing anything over Redfish. I removed this paragraph to avoid confusion."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 49,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Is the daemon going to handle multi-slot updates (two devices of the same underlying hardware type) or is that handled by two different instances of the daemon?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 49,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Right, it's a little unclear whether the proposal is for a single instance of the daemon handling all I2C devices, or some other approach. I guess you could do one instance per bus? One instance per device?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 49,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Yes, it would handle multi-slot updates, but we would also want the ability to handle cases where there are multiple devices and those devices may require different firmware images. Added some details here."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 65,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "This sounds like a kernel patch rather than something we need a userspace daemon for?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 65,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Do you mean a patch to existing hwmon drivers? IIUC, hwmon drivers are very focused on telemetry, and other types of information wouldn't be suitable in those drivers."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 65,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Yeah I guess I'm a bit frustrated with Guenter's stance that PMBus must only be used in the hwmon subsystem in the kernel, and then NACKs anything expanding the hwmon sysfs ABI."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 65,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "That stance unfortunately kind of makes this kind of \"do more stuff in userspace\" stuff required.  I don't really like it anymore than you do, but given Guenters position, I don't see another option than doing a lot more stuff in userspace."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 65,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "I think everyone is in agreement with the sentiment expressed here, we can mark this issue resolved."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 75,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "This interface doesn't exist.  Are you going to define it?  Does this really just mean that the daemon could expose \"any other dbus interface not already identified above\"?\n\nWhat are we doing about Inventory?  Is there any inventory information we can only get over i2c?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 75,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Yes the daemon could expose a dbus interface for anything a particular device might need to expose. I believe the inventory information can still be handled by EntityManager."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 75,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "> I believe the inventory information can still be handled by EntityManager.\n\nWhat happens when the inventory information is in the same i2c end-point?  For instance, how do you get the PMBus-based power supply serial number?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 75,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "AFAIK serial number from pmbus isn't being exposed today.. so this daemon isn't any less capable (it just doesn't handle ALL possible use cases on inception).\n\nAs far as being able to reflect new properties onto inventory objects that EM owns. I think there is a pattern for that. You can capture interfaces in the Probe and then reflect them into Exposed objects.\nEd can correct me if I'm wrong on this, a similar pattern was suggested for another gpio presence daemon that is currently in review as well.\n\n(I have no issue with this daemon owning the inventory item but this was discouraged in another review..instead preferring to delegate ownership to EM - and so that's the pattern we followed here)"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 75,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Can we make this example actually include all the properties you plan on using?  I think that'll help when we actually build the interface to specify what this actually implements.  As a matter of design, we probably want to implement this property using this API:\nhttps://github.com/openbmc/phosphor-dbus-interfaces/blob/master/yaml/xyz/openbmc_project/Control/VoltageRegulatorControl.interface.yaml\ngiven that it already exists.\n\n> What happens when the inventory information is in the same i2c end-point? \nFor Pmbus devices, do we have a use case for this?  PMbus based power supplies are generally covered by an eeprom FRU, I wasn't aware that the pmbus spec supported serial numbers.  If it does, that's a pain architecturally and needs me to give some brainpower to how to do a \"dual detect\" of a pmbus device in EM.\n\n>As far as being able to reflect new properties onto inventory objects that EM owns.\n\nThis would be backward reflection, which EM can't do today, you have to get all your inventory properties from the eeprom/probe interface you want to pass through.\n\n> Ed can correct me if I'm wrong on this, a similar pattern was suggested for another gpio presence daemon that is currently in review as well.\n\nIn that case, it goes\nPresence -> Em probe for device -> SlotPresence -> Device\n\n\nIn this case, it goes something like\nEeprom Frudevice -> em probe for baseboard -> i2c device finds serial number ->  ????????\n\nThere's no backward path to attach the serial from step 3 into the object created on step 2.  Again, if this is required, it's going to need some brainpower to make it sane.  This stuff is too complicated enough as-is."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 75,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "as far as backward reflection and using serial-numbers from pmbus devices..\\\nI don't have a use-case for that today and can't think of a plausible future use-case either."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 75,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "That's what I thought.  Unless Patrick has a use case, I think we can leave it out for the moment?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 75,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "I'll also add regarding PMBus serial numbers that of the PMBus devices I've dealt with (admittedly not a huge set, but a modest handful), I think I've yet to encounter one that actually supports the MFR_SERIAL command."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 95,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "It's not clear to me what we can't achieve with in-kernel support for the I2C devices. For example, there's a hwmon PMBus driver for the adm1266. The kernel won't do firmware update, but are there specific issues you have with the existing kernel uapi for hwmon? I think these issues would do well to be described in the \"Problem Description\" section."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 10,
                    "deletions": 0
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "type": "ADDED",
                    "insertions": 111,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 121,
            "sizeDeletions": 0
        },
        {
            "number": 2,
            "revision": "ffde5b406430055522386f11e11449bedb7d4209",
            "parents": [
                "8deacbf78474b1adbdfca4a78cc712de07b6f645"
            ],
            "ref": "refs/changes/09/50509/2",
            "uploader": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "createdOn": 1642634055,
            "author": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "kind": "REWORK",
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 10,
                    "deletions": 0
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "type": "ADDED",
                    "insertions": 116,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 126,
            "sizeDeletions": 0
        },
        {
            "number": 3,
            "revision": "40387313c8318093914bfef204918a0f3def0c20",
            "parents": [
                "8deacbf78474b1adbdfca4a78cc712de07b6f645"
            ],
            "ref": "refs/changes/09/50509/3",
            "uploader": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "createdOn": 1642637013,
            "author": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Thanks for the updates and replies. I still have a nagging concern that it will turn into a kitchen-sink daemon and a bit of a maintenance/stability headache."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I should have said I'm not sure what to do about that feeling. I do understand the concerns around firmware update coordination, I'm just struggling to feel comfortable with the flow-on effects."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Shouldn't firmware update coordination be handled in-kernel?  Let the hwmon interfaces return EAGAIN if code update is being done and the sensors are unavailable."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": ">> Shouldn't firmware update coordination be handled in-kernel?\nNot according to the hwmon maintainer. An attempt was made, explicitly rejected and we were told this should be done in userspace. We respected the maintainer's decision and have since created some CLIs that do this in userspace.\nWe want to move away from hacking together services and shell scripts and formalize this into a daemon (the daemon proposed here).\n\nContext for those who are interested:\n\nhttps://lkml.org/lkml/2020/8/7/565\n\nNot going to let it happen through ioctls either\n\nhttps://lkml.org/lkml/2020/6/24/830\n\nWe tried once more through an informal chat. Maintainer's stance has not changed and he has asked us to sort this out ourselves.\n\n>> I'm just struggling to feel comfortable with the flow-on effects.\n>> I still have a nagging concern that it will turn into a kitchen-sink daemon and a bit of a maintenance/stability headache\n\nI share your concern but I view the alternative as worse (coordinating firmware upgrades with telemetry). At least when it's all in one daemon you end up debugging a single code base and don't have to worry about things like dbus latency etc..\n\nIf it helps, we have the mindset of single device single owner."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 7,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Thanks for reworking this section, I like the result."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 21,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "It's mentioned in another comment[1] that an API for firmware updates was tried and rejected. Do you have a link to the mailing list discussion? I think that would be handy background.\n\n[1] https://gerrit.openbmc-project.xyz/c/openbmc/docs/+/50509/3/designs/i2c-device-mgmt.md#31"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 21,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "There is this which has been applied to linux-next:\n    https://lore.kernel.org/lkml/cover.1640007183.git.yu.c.chen@intel.com/\n\nIt is unfortunate that the uapi is specific to these Intel ACPI interfaces, but it seems like someone could refactor that to make for a more generic interface now that this has been accepted in concept, right?\n\nThere is also the existing (linux-kernel):Documentation/driver-api/firmware.  Is there any reason this can be leveraged by devices that want to do runtime-based firmware update?\n\n> and the hwmon framework doesn't expose an API for firmware updates.\n\nThe hwmon framework never would expose an API for firmware update.  There would be a separate framework for firmware update and a device might support the APIs necessary for both the hwmon and \"firmware-update\" framework."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 21,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": ">It is unfortunate that the uapi is specific to these Intel ACPI interfaces, but it seems like someone could refactor that to make for a more generic interface now that this has been accepted in concept, right?\n\nRight, but at this point we're talking about refactoring kernel code so we don't have to do something in userspace? I've always taken the stance to do things in userspace and only put things into the kernel if I have no other choice (lower blast radius).\n\n>There is also the existing (linux-kernel):Documentation/driver-api/firmware. \nquickly reading through \"driver-api/firmware\" leaves me with the impression that this firmware is meant to be loaded onto devices in early boot.. to patch microcode or load something onto a microcontroller. Not our use-case."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 21,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "> ... I've always taken the stance to do things in userspace and only put things into the kernel if I have no other choice (lower blast radius).\n\nI believe we've had this same discussion in the CMIS proposal.  This might be your stance but it isn't the project's stance.  Our stance is to work with upstream code-bases, especially the kernel, as much as possible so that the work we do can be leveraged by the broader community.\n\n> quickly reading through \"driver-api/firmware\" leaves me with the impression that this firmware is meant to be loaded onto devices in early boot.. to patch microcode or load something onto a microcontroller. Not our use-case.\n\nSo let's discuss / propose improving that?\n\nI agree with Guenter's stance about not adding new APIs that are unique to PMBus/hwmon, but I disagree with his stance that \"nothing in the kernel should deal with update because it is 'dangerous'\".  There are lots of things the kernel does that is potentially dangerous.  (We should really be having these discussions on the LKML though.  I don't fully grasp what the statement of \"the maintainer's mindset hasn't changed and expects us to 'work it out'\" means.).\n\nIf there is already an API for getting binary blobs into the kernel to use as firmware for devices, this seems like a great starting point for getting binary blobs into the kernel to apply firmware updates for devices.  We should probably get some RFC sent upstream to see who disagrees and why.\n\nI'm really not a fan of us yet again re-implementing support we already have (ie. dbus-sensors) and especially not also re-implementing the whole pmbus/hwmon subsystem in user-space.  I'm also concerned about the error prone approach of having a separate daemon to handle firmware updates that unbinds the device from drivers out from underneath these existing daemons.  (I can't tell which direction you're proposing here because I've read words that imply both.)  I really think the best approach is to figure out how to do firmware update of these devices cooperatively with the existing pmbus subsystem."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 21,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "> I don't fully grasp what the statement of \"the maintainer's mindset hasn't changed and expects us to 'work it out'\" means.).\n\nIt means that we spoke to the maintainer of hwmon, his stance hasn't changed and he's asked us to leave him out of our debate on this matter.\n\n> I'm also concerned about the error prone approach of having a separate daemon to handle firmware updates that unbinds the device from drivers out from underneath these existing daemons.  (I can't tell which direction you're proposing here because I've read words that imply both.) \n\nWe wanted to avoid nailing down exactly how we'd do this. One of the core underlying assumption with this proposal is that the business logic of i2c firmware updates (present use-case targets pmbus) would be done in user space (motivated by our past failures to change hwmon/pmbus so to support a firmware update mechanism).\n\nDo I understand it correctly that you oppose handling i2c device updates in userspace?\nAs in a design proposal that specifies such an approach will be rejected?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 21,
                    "reviewer": {
                        "name": "Peter Lundgren",
                        "email": "peterlundgren@google.com",
                        "username": "peterlundgren"
                    },
                    "message": "> I really think the best approach is to figure out how to do firmware update of these devices cooperatively with the existing pmbus subsystem.\n\nOne approach would be to have a single i2c daemon that can pause telemetry during a firmware update. No bind/unbind needed. However, this only provides a weak opt-in exclusivity guarantee. Certainly an in-kernel approach can provide stronger guarantees."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 21,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> We wanted to avoid nailing down exactly how we'd do this.\n\nThis is a design doc.... it's kinda the point to at least throw the dart at the dartboard with \"here's what we're going to try first\", not necessarily nail down.  Keep in mind, this design doc isn't a binding legal contract.  Many..... many.... many times we've got to the implementation phase and realized the design was totally borked, or slow, or didn't meet the design goals, and regrouped on a different plan.  Lets get documented what we think we want to build.  As we all know, \"no plan survives first contact with implementation\", that doesn't mean that it's not worth writing down what the plan is, and a hybrid hwmon/userspace approach is worth at least discussing.  The other reviewers might have some input here, given that on this review we have people that have implemented lots of variations of sensor subsystems, they might see a critical flaw and save us a lot of time."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 107,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "In order to support firmware update I think you're going to need a bit more information than just this.  Please take a look at the Software update design.  There are now compatibility strings that tell you the purpose of the device / image so they can be matched up.\n\nI could have 5 VRs on my board that are all the same TI chip, but if I load the wrong firmware image into the wrong one, I'll fry the board.  There quite likely would be a different VR image for different voltage rails."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 107,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "Wouldn't name be the unique identifier?\nThat is I now have a software inventory for adm1266_0 and when you upgrade that target the device at 19-0x4d is the one that is upgraded. No other device should have the same bus-addr on a board.\n\nAnd it will use the upgrade process relevant to \"I2CDeviceType\":\"adm1266\""
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 107,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> I could have 5 VRs on my board that are all the same TI chip, but if I load the wrong firmware image into the wrong one, I'll fry the board.\n\nGross.... didn't think of that, but you're right, we probably need some kind of \"compat\" string in here?  How do VRs generally validate that a payload is for the intended rail?  Seems like anything we did there would be OEM/platform specific unless we invented (or standardized on something like fwupd) a firmware update payload.\n\n\n> That is I now have a software inventory for adm1266_0 and when you upgrade that target the device at 19-0x4d is the one that is upgraded. No other device should have the same bus-addr on a board.\n\nAt dbus/interface level, you don't know which device has which address, and the same VR update might apply to multiples, so you can't really rely on the specific bus and address.  Also, in the case of EM files, bus might (is probably not) a fixed number."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 107,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "Okay, I more carefully read through the Software update design doc and I think I get what is being said here.\n\nLooks like targeting a particular image to a particular device is doable by decorating with the\n`Inventory.Decorator.Compatible` interface.\n\ne.g\n\n`foo.software.element.mainsequencer.type.ADM1266`\n\nor\n`foo.software.element.subsequencer2.type.ADM1266`\n\n\n>How do VRs generally validate that a payload is for the intended rail?\n\nFrom my experience they don't. You make sure to test your package updates carefully before you roll the update out to the entire fleet.\n\n\n>At dbus/interface level, you don't know which device has which address, and the same VR update might apply to multiples, so you can't really rely on the specific bus and address.  \n\nSure, it sounds like the compat decorator is how we'd target a file for a particular group of devices. Seems like EM could contain the compat string when configuring this firmware upgrade daemon.. That way this daemon knows what images are meant for it."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 107,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> You make sure to test your package updates carefully before you roll the update out to the entire fleet.\n\nIn past systems I've worked on we relied on the BMC signing and embedding the firmare to ensure that it wasn't available out of band.  Agreed, I think the compatible string could solve some things here, but from a security perspective, we need to make sure it's not possible to send the wrong payload to the wrong VR, overvolt the system and brick it."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 10,
                    "deletions": 0
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "type": "ADDED",
                    "insertions": 123,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 133,
            "sizeDeletions": 0
        },
        {
            "number": 4,
            "revision": "3abb9abe7c1cad1e85fb30e87fafe25e5b15daa2",
            "parents": [
                "8deacbf78474b1adbdfca4a78cc712de07b6f645"
            ],
            "ref": "refs/changes/09/50509/4",
            "uploader": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "createdOn": 1642705389,
            "author": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 37,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "If this set of devices is not just \"all I2C devices\" then can you please provide a small list of existing devices of interest with accompanying discussion about their specific behaviours that demonstrates the need for this proposal? Also provide a small list of devices where this daemon's behaviour isn't required. Let's make things concrete. And some discussion about how to prevent these devices being automatically monitored by e.g. dbus-sensors if that's simultaneously in use on the system?\n\nIf this set of devices turns out to be \"all I2C devices\", then I suspect you have a pretty big uphill battle on your hands, as it will need to reimplement existing projects like dbus-sensors. It will be contentious at least due to community fragmentation (we already have enough of this)."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 37,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "It is not necessarily all i2c devices. Some systems may prefer to use a mix of both this daemon and dbus-sensors. Added some details to describe this and the minor changes needed to dbus-sensors."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 144,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Have you considered using a dedicated system state for device update? Say we introduce \"device-update.target\" with similar behaviour to e.g. emergency.target. We know that there won't be any concurrent access for telemetry purposes because of the minimal amount of userspace that's running.\n\nArguments for/against this can again be added here."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 144,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Done"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 10,
                    "deletions": 0
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "type": "ADDED",
                    "insertions": 155,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 165,
            "sizeDeletions": 0
        },
        {
            "number": 5,
            "revision": "b90482cc19b4424dfbecfce155853fa30fe2a53a",
            "parents": [
                "8deacbf78474b1adbdfca4a78cc712de07b6f645"
            ],
            "ref": "refs/changes/09/50509/5",
            "uploader": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "createdOn": 1643157452,
            "author": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "It looks like the discussion is trending towards improving dbus-sensors as much as possible rather than introduce yet another daemon to provide sensors, which I agree would help to reduce fragmentation. One of our primary motivations for this design was to eliminate i2c collisions from telemetry during firmware upgrades. So I'm wondering, what is everyone's preference: option A) to integrate firmware upgrades into dbus-sensors or option B) provide some sort of \"pause\" API to temporarily disable telemetry in dbus-sensors during firmware upgrades that some other dedicated firmware upgrade daemon could toggle?"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": "I vote for bundling firmware upgrades with sensor telemetry into the same daemon."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "Also voting for bundling firmware upgrades with sensor telemetry into the same daemon (option A)."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Peter Lundgren",
                        "email": "peterlundgren@google.com",
                        "username": "peterlundgren"
                    },
                    "message": "Also agree with telemetry + firmware in same daemon (option A).\n\nThe reasons why we were considering alternatives was that some I2C devices or protocols need exclusive access to the entire I2C bus; not just exclusive access to the device. But I don't see this being a big concern right now. First, I haven't seen a misbehaving device like this in a few years; hopefully we don't ever again. Second, with MCTP in the kernel, we don't need to worry about some locking scheme for a user space MCTP. That seems to cover the immediate problems."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Created a new proposal to integrate firmware updates into dbus-sensors in https://gerrit.openbmc-project.xyz/c/openbmc/docs/+/52234"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 29,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "It is?  I don't know of any instances of using phosphor-ipmi-flash for i2c firmware updates?  Maybe I'm out of touch?  No, it's the codebase that's wrong.\n\nhttps://i.kym-cdn.com/entries/icons/original/000/019/899/skinner.jpg"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 32,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Yes, we should do this as a design pattern."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 34,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Nit, this doc would read a lot better without mentioning the daemon in the \"background\" section.  At this point, no new daemon has been introduced, you're just documenting background on why some change is needed."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 43,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "This isn't a requirement.  The requirement is implementing both telemetry and firmware update/configuration changes that don't conflict.  Requirements should avoid jumping into solution space, which a single daemon is one possible solution."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 43,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Having a single daemon that supports ALL i2c devices seems like a kind of extremely large scope.  Should we decrease it a bit to scope it down a bit, to say, only pmbus devices?  Otherwise this design conflicts directly with things like the BIC controller daemon that's currently in review for a new repo."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 43,
                    "reviewer": {
                        "name": "Peter Lundgren",
                        "email": "peterlundgren@google.com",
                        "username": "peterlundgren"
                    },
                    "message": "The single daemon for all i2c idea is largely coming from my WIP proposals for performance improvements. Justin wanted to get this proposal out to get started on the firmware management discussions. Agreed, this doc doesn't provide enough justification as is. I will work with Justin and Jason to combine our proposals into a unified design.\n\nA daemon that targets all i2c devices offers significant benefits in performance (having a single scheduler that can optimize around mux topology), functionality (locking / exclusive access when required), and reliability (no race conditions, can be made real-time). That said, it is crucially important that it works in an cooperative, opt-in way. This daemon must live with other services using i2c and still provide predictable (if degraded) guarantees about performance, functionality, and reliability.\n\nExpect a more comprehensive proposal from the three of us that will superseded this doc."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 43,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "I'm a bit confused by this.  Elsewhere Jason wrote:\n\n> It's not really a daemon for everything i2c, but for devices that require more than just telemetry so that all access to that device is encapsulated in a single application. I reworded the description to reflect this.\n\nI want to be very forward that I see this proposal as being a big uphill battle to get me convinced that this is the right architectural direction.  I'll read what you have with an open mind but I don't want you to feel like you're wasting time later on.\n\n> A daemon that targets all i2c devices offers significant benefits in performance (having a single scheduler that can optimize around mux topology), functionality (locking / exclusive access when required), and reliability (no race conditions, can be made real-time)\n\nThis sounds like you're proposing yet another i2c-in-userspace implementation.  This is absolutely a no-go in my mind, unless I see a lot of data explaining why it is better.  You're talking about not only reimplementing hwmon and pmbus and mux control but EEPROM, GPIO, LED control, MCTP, IPMB, etc. and then merging them all into one giant codebase.  There is already a lot of kernel drivers and existing openbmc userspace code to handle these things.  Some of these have implementations that are leveraged for non-i2c buses, so we end up having a divergence of functionality and approach depending on which bus gets chosen by a particular hardware design.\n\nI really cannot conceive that the 2-4 bytes of i2c traffic to switch the mux is our performance bottleneck.  If you really think that it is, and again I'd like to see data that shows this, I think you have at least three better options:\n\n1. Improve your hardware design so you're not cramming so many devices on a single i2c bus, but spread it out among the 6 (or more?) masters on the BMC chip.\n\n2. Get these scheduling enhancements ideas into the kernel i2c subsystem directly.\n\n3. Improve dbus-sensors so it is mux-aware and to handle better timer scheduling of the devices it is monitoring so that mux switching is minimized."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 43,
                    "reviewer": {
                        "name": "Peter Lundgren",
                        "email": "peterlundgren@google.com",
                        "username": "peterlundgren"
                    },
                    "message": "> This sounds like you're proposing yet another i2c-in-userspace implementation.\n\nAbsolutely not! I understand your concern. We will still defer to the hwmon drivers for the vast majority of I2C traffic in the same way that dbus-sensors does today.\n\n> I really cannot conceive that the 2-4 bytes of i2c traffic to switch the mux is our performance bottleneck.\n\nWe have systems where with 2 nested muxes with i2c-mux-idle-disconnect enabled (fru-device misplaces eeproms otherwise) we see a 10x overhead with the muxes. That said, I don't want to over-emphasize this. I2C bandwidth is not the current bottleneck.\n\n> 1. Improve your hardware design so you're not cramming so many devices on a single i2c bus, but spread it out among the 6 (or more?) masters on the BMC chip.\n\nYou're right that changing the hardware design is better. And removing i2c-mux-idle-disconnect is better still. This is a case where the racy nature of the current design causes issue. We find fru-device eeprom detection process to be unreliable at scale.\n\n> 2. Get these scheduling enhancements ideas into the kernel i2c subsystem directly.\n\nScheduling in the kernel is an interesting idea. It would require something like io_uring to batch a number of requests and allowing the kernel to reorder them. That behavior would be pretty surprising. I'm not sure it makes sense.\n\n> 3. Improve dbus-sensors so it is mux-aware and to handle better timer scheduling of the devices it is monitoring so that mux switching is minimized.\n\ndbus-sensors cannot perform this scheduling because it distributes I2C responsibility across several different daemons.\n\nApologies for having a design discussion in these comments. Give us some time to come back with a more detailed proposal. I need to scrub our performance research of proprietary information so that we can publish it. That will make things more clear. I'll get back to you with more details."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 43,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "I think we're talking past eachother a little.  when I say \"ALL i2c devices\", I include smart controllers talking over IPMB, NVMe-MI capable drives, PLDM drives, and MCTP capable controllers.  I would hope that it isn't in your plan to intercept those with this deamon, considering we previously had a userspace implementation of each of the aforementioned, and moving to the kernel version improved performance, decreased the code complexity, and got rid of bugs.\n\nIf it is in your plan to intercept the above with this new implementation, that needs a much bigger design doc.\n\n\nIn the comments, we've kinda dove into some more topics than this design doc can really handle.  i2c mux optimization probably deserves a design doc on its own, as that will have some far reaching implications, and there's probably 2-3 different designs that we'll likely need to discuss with the relevant experts.\n\n\n\n> We will still defer to the hwmon drivers\n\nIs this true?  I guess I didn't process that part of this, and assumed that we'd move the paging out of telemetry values into userspace based on the doc.  Given we're doing a hybrid, can this doc explicitly call out what data we're going to get from userspace, and what we'll get from hwmon?  Assuming I'm reading this right, this is sounding more like we just need to add some features to PSUSensor (or some stronger child implementation of a different name) more than it is we need a totally new thing.\n\n\n> another i2c-in-userspace implementation.  This is absolutely a no-go in my mind, unless I see a lot of data explaining why it is better.\n\nI think it comes down to \"it's possible to accomplish in a staffable (call it 2 year) time horizon\".  upstream kernel drivers with the various sysfs interfaces for all devices and all interfaces a BMC would need seems to get stopped in upstream, which while unfortunate, doesn't leave much alternative, as this doc calls out, unless there's a path I'm missing that doesn't involve the kernel people adding a new sysfs interface, but still gets us VR firmware update and various model-specific telemetry in openbmc?  Doing pmbus in userspace is architecturally no different than a userspace implementation of IPMB reading that's being proposed for the OpenBIC stuff that the repo got requested for: It's taking an existing kernel interface, and implementing an interpretation of the raw interface in userspace.  This seems reasonable to me given the uphill battle with the kernel.  Given that, and your strong opinion here, I'm really not quite understanding where the \"no-go\" line exists."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 43,
                    "reviewer": {
                        "name": "Zev Weiss",
                        "email": "zev@bewilderbeest.net",
                        "username": "zevweiss"
                    },
                    "message": "> It would require something like io_uring to batch a number of requests and allowing the kernel to reorder them. That behavior would be pretty surprising. I'm not sure it makes sense.\n\nFWIW, at least as far as the defined semantics of existing interfaces are concerned, io_uring requests are by default not ordered (hence the kernel is free to reorder them); if there are ordering requirements that you need to enforce you can use IOSQE_IO_DRAIN and/or IOSQE_IO_LINK (see sec. 5.1 & 5.2 of https://kernel.dk/io_uring.pdf).\n\nHowever, in terms of the existing implementation, since the APIs in the i2c subsystem are all currently fully synchronous, by my understanding io_uring for i2c I/O would currently just end up punting all requests to a single work queue where I expect they'd be carried out in the order they arrive -- so while the interfaces would allow for reordering, getting that to actually happen for this use-case would be non-trivial."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 43,
                    "reviewer": {
                        "name": "Peter Lundgren",
                        "email": "peterlundgren@google.com",
                        "username": "peterlundgren"
                    },
                    "message": "Update on the sensor performance conversation:\n\nI like to conceptualize performance optimization as a peak finding problem. As we make incremental performance improvements, we're performing a gradient ascent algorithm that will find the local performance maxima. However, the classic weakness of gradient ascent is that it can get stuck on a local maxima far away from the global maxima. So if the current dbus-sensor architecture is the current peak we're on, what other peaks are out there? Should we continue to ascend the dbus-sensors peak or search for another potentially higher peak? Let's consider 3 peaks:\n\n1. dbus-sensors Peak\n\nWith our current architecture, we can make incremental performance improvements. Most significantly, we should work on making our interprocess communication as efficient as possible. D-Bus is a significant bottleneck. We can directly attack the D-Bus bottleneck by batching updates or using alternative IPC. Less dramatic changes can also make a big impact like how matching signals can be much better than polling on D-Bus or other optimizations like delayed-release for I2C muxes (https://www.spinics.net/lists/linux-i2c/msg55343.html).\n\n2. Maximum Embedded Linux Performance Peak\n\nIf we're willing to step outside of the dbus-sensors architecture, there's much more we can do to improve performance. This is where the discussions about a larger service responsible for more I2C functionality comes in. A single I2C service could perform optimizations based on mux topology, for example. With care, embedded Linux can start to take on real-time characteristics. Funneling all IPC through dbus-broker prevents any real-time tuning today. Some primitive benchmarking shows that we can saturate I2C with >10,000 sensor reads per second using <10% CPU. D-Bus can't keep up with that, but Linux can if we're willing to redesign the software.\n\n3. Alternative Hardware and Operating Systems Peak\n\nBeyond Embedded Linux is an endless landscape of entirely different architectures. Different industries can poll sensors at tremendously high rates, but needs for BMCs top out at maybe 1-10 Hz per sensor, so there's really little need to consider exotic options. I have heard discussions about using co-processors or FPGAs for sensor polling, but I wouldn't recommend them. Stick with Linux.\n\n\nPeak 3 clearly doesn't make sense for BMCs, but there's an interesting discussion to be had between options 1 and 2. Both have been tried in the past; no design is a panacea. Ultimately, we're having this discussion because we've seen performance problems with dbus-sensors and we need to fix them.\n\nCertainly earlier in this thread I was voting more for option 2, but today I am increasingly optimistic that there's a path to good enough with option 1. My colleagues and I will be working on improvements to the dbus-sensors stack in the coming year. In line with that, we should design I2C firmware updates for dbus-sensors interoperability."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 53,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Additional requirement, the code should fully deprecate the need for PSUsensor, given that it's duplicating a number of features and not sharing any code, it needs to use that featureset as a starting point to make it maintainable in the long term.\n\n\nI suspect we also need some requirements around being runtime invokable for when i2c devices exist on add in cards (solution probably being an EM reactor), otherwise this ends up being a point solution that only works on non DC-SCM baseboards."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 53,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": ">Additional requirement, the code should fully deprecate the need for PSUsensor, >given that it's duplicating a number of features and not sharing any code, it >needs to use that featureset as a starting point to make it maintainable in the >long term.\nI'm okay with making this the long term replacement for PSUSensors. Of course the initial commits will focus heavily (exclusively) on implementing the features described in this design. Justin, thoughts?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 53,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "As I think about this more, and discussed with the other dbus-sensors maintainers, what I suspect needs to happen is:\n1. Refactor the \"sensor\" specific code out of PSU sensor, such that it can be reused, and we don't immediately lose features that the community (and Google-specifically) needs.  This is kind of already done, there's a sensor class, we just need to simplify the code a bit to make it more sane.\n2. Write the new application calling the underlying routines.  I'd expect most of the existing userspace code to be shared, minus the \"where do we actually read the value\" portion, which would instead call into your userspace code.\n\nSeem reasonable?  The above avoids the problem of inventing a new \"thing\" then having to port all the use cases over to it, and I don't think your design has any plans on making major changes to how, say, thresholds, or dbus interfaces works, at least based on reading it, and we don't want to have to re-invent all that work that's already been done."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 53,
                    "reviewer": {
                        "name": "Michael Jones",
                        "username": "Proclivis"
                    },
                    "message": "From my perspective supporting PMBus/SMBus/I2C Hot Swap, Regulators, Managers, and Sequencers at ADI, and from discussions within the PMBus Technical Committee, missing capabilities in linux based management systems are:\n\nA) Fetching Fault Logs used to diagnose failures\nB) Updating firmware stored in the slave Flash or EEPROM\nC) Updating settings stored in the slave Flash or EEPROM\nD) General access to MFR commands used for diagnostics or remote diagnosis\nE) Initialization of devices that do not store settings\nF) Status monitoring\n\nSome linux hwmon drivers use devicetree for E, but this is not usable on a delivered product.\n\nThe PMBus Technical Committee is interested in C and has done work to define a data language that works for all vendors, which allows for algorithmic behavior in addition to content.\n\nI have extended the ltc2978.c driver to support fault logs using debugfs, but it\u2019s not practical because debugfs is not always enabled. But it demonstrates it is practical to do it a driver.\n\nB and C are quite different. I am a little surprised at B. I did not see this as a need until I saw it here. C is built into many products (non OBMC), and well established as a need.\n\nA enables tracking and predicting failures without requiring a product return to factory. F serves the same goal.\n\nE is probably less important for OBMC, but if more designs use newer low cost Regulators, they don\u2019t have Flash or EEPROM. E becomes an equivalent of C for these devices."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 62,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Isn't this duplicated with the requirement?\n\nHow is this interface backed?  Does it implement pmbus?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 62,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": ">Isn't this duplicated with the requirement?\n\nI don't understand this question.\n\n>How is this interface backed? \n\nIf we're talking about the interfaces used to actuate a firmware update then it's backed with a bunch of userspace code that knows how to update particular devices.\n\n>Does it implement pmbus?\n\nYes, each pmbus device gets its own class that knows how to update the device. The classes know how to read standard telemetry if we decide to do userspace vs kernel."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 62,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> >Isn't this duplicated with the requirement?\n> \n> I don't understand this question.\n\n\nI was thinking that this was kind of duplicated with requirement 1 in the section above, but in re-reading, I understand your confusion.  Fine as is on this point.\n\n> \n> >How is this interface backed? \n> \n> If we're talking about the interfaces used to actuate a firmware update then it's backed with a bunch of userspace code that knows how to update particular devices.\n> \n> >Does it implement pmbus?\n> \n> Yes, each pmbus device gets its own class that knows how to update the device. The classes know how to read standard telemetry if we decide to do userspace vs kernel.\n\n\nMy point on the two above questions is that should be called out in your design."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 68,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "This also feels like a requirement in the way it's phrased.  maybe move it up a section."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 78,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "It seems like this is kind of covered by the \"With a single daemon acting as an owner of a device\" statement previously.  If that's true, this isn't possible."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 79,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "If it does this, it needs to not duplicate code.  We already have two implementations that are able to read from hwmon implementations (hwmontempsensor/psusenor, and phosphor-hwmon) as a matter of design, we need to avoid a having a third."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 86,
                    "reviewer": {
                        "name": "Andrew Jeffery",
                        "email": "andrew@aj.id.au",
                        "username": "amboar"
                    },
                    "message": "I don't feel like this is enough of a description of how this will be implemented in practice.\n\nEM board configs are written specific to the board they support with no regard for the system context in which they live. How do you handle wanting to update a device in system context A but not in system context B for the one card? Maybe you could argue that's not valid concern, but I think the point is it's a policy decision of the system designer/owner/maintainer.\n\nHow does this property get populated? Also patching dbus-sensors to add support for something that tells it to ignore the device for the purpose of this daemon seems a bit backwards. It's almost as if you want a separate interface for these devices or something, so you don't trigger dbus-sensors to start with.\n\nBut on that front, with the work required deal with this in a separate daemon that ends up providing the Sensor interface itself, is there a reason why we can't add generic support inside dbus-sensors that could be leveraged by each of the daemon implementations? Doesn't that remove the conflict headache? Have the sensor daemons provide the Software interface?"
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 86,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Agree with arj that this is underspecified, but reading between the lines a bit this implies that OpenBMC as an implementation we have two different daemons implementing support for the same device, which would mean we've duplicated code, which as a matter of design, we shouldn't.  If this daemon supports, say, the adm1266 device fully, that node support should be removed entirely from PSUSensor so we maintain the \"one implementation per device\" guideline.\n\n\n> Also patching dbus-sensors to add support for something that tells it to ignore the device for the purpose of this daemon seems a bit backwards.\n\nAdmittedly, we kind of already have this support with the \"DisableNode\" stuff, but that was meant for when we wanted to implement more general limits, then more specific limits as more entities were detected.  It shouldn't be used for this case."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 86,
                    "reviewer": {
                        "name": "Jason Ling",
                        "email": "jasonling@google.com",
                        "username": "jclaz"
                    },
                    "message": ">If this daemon supports, say, the adm1266 device fully, that node support should >be removed entirely from PSUSensor so we maintain the \"one implementation per >device\" guideline.\n\nThat sounds reasonable to me , I was thinking that a different Type qualifier would cause the config to be ignored for dbus-sensors and used by this daemon.\n\n>But on that front, with the work required deal with this in a separate daemon that >ends up providing the Sensor interface itself, is there a reason why we can't add >generic support inside dbus-sensors that could be leveraged by each of the daemon >implementations? Doesn't that remove the conflict headache? Have the sensor >daemons provide the Software interface?\n\nYes, that would avoid the headache. one of the reasons we are more interested in spinning off our own daemon is to improve sensor polling performance while we're at it. I suspect such performance increases in dbus-sensors would require some fundamental changes..\n\nAnd so spinning off a new daemon allows us the luxury of moving forward without much worry about breaking any systems that depend on the quirks of dbus-sensors."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 86,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> >If this daemon supports, say, the adm1266 device fully, that node support should >be removed entirely from PSUSensor so we maintain the \"one implementation per >device\" guideline.\n> \n> That sounds reasonable to me , I was thinking that a different Type qualifier would cause the config to be ignored for dbus-sensors and used by this daemon.\n> \n> >But on that front, with the work required deal with this in a separate daemon that >ends up providing the Sensor interface itself, is there a reason why we can't add >generic support inside dbus-sensors that could be leveraged by each of the daemon >implementations? Doesn't that remove the conflict headache? Have the sensor >daemons provide the Software interface?\n> \n> Yes, that would avoid the headache. one of the reasons we are more interested in spinning off our own daemon is to improve sensor polling performance while we're at it.\n\nI get that, and I have a lot of context for that, but that needs its own discussion and design doc.\n\n> I suspect such performance increases in dbus-sensors would require some fundamental changes..\n\nSo, make the fundamental changes?  Dbus-sensors as a repo isn't THAT much code.  If we completely rewrote every line of it a year from now, I would be in no way sad, but we should avoid the \"yet another sensor implementation\" at the moment, when we haven't even finished the transition to dbus-sensors for all systems.\n\n> \n> And so spinning off a new daemon allows us the luxury of moving forward without much worry about breaking any systems that depend on the quirks of dbus-sensors.\n\nAnd therein lies the problem.  Those quirks (in most cases I would call them features) are in some cases important to having a solution that works for a wide array of systems.  I would much rather we break some systems in minor ways, have the community point it out, and fix the issues than try to maintain a 3rd (or 4th depending on how you count) way to scan sensors."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 122,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "EM requires that every note has a \"Type\" field (and a Name field, but you got that right).  The way you're defining this, you need to change I2CDeviceType -> Type and you'd be mostly correct."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 129,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "I think you're missing a bunch of fields here.  an ADM1266 has multiple rails, multiple sensors, and some optionally implementable features, all of which need named per-system, scaled, and min/maxed per system.  Take a look at the existing PSUsensor devices for examples of how this would work.\n\nGiven you also plan on making control interfaces available, I suspect that will need to be configurable per system.  There are a number of systems that will need to treat the VRs as \"read only\" and that will need to be configurable at some level."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 141,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Nope.  This isn't a requirement, and as a matter of being precise, entity-manager doesn't monitor any devices directly.  It does create some devices, but that's a remnant from a long dead design that I'd really like to see die at some point in the future."
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "line": 156,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Same as above.  \"any generic i2c device\" seems like a huge scope, unless you're planning on implementing support for OpenBIC, and management engine.  Lets scope this on pmbus devices."
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 10,
                    "deletions": 0
                },
                {
                    "file": "designs/i2c-device-mgmt.md",
                    "type": "ADDED",
                    "insertions": 180,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 190,
            "sizeDeletions": 0
        }
    ]
}