{
    "project": "openbmc/docs",
    "branch": "master",
    "topic": "design",
    "id": "I1bc857b7f565eb5660be9af448cf415c48514aab",
    "number": 54589,
    "subject": "design: propose simple firmware update API",
    "owner": {
        "name": "Justin Ledford",
        "email": "justinledford@google.com",
        "username": "justinledford"
    },
    "url": "https://gerrit.openbmc.org/c/openbmc/docs/+/54589",
    "hashtags": [],
    "createdOn": 1655263143,
    "lastUpdated": 1728651541,
    "open": false,
    "status": "ABANDONED",
    "comments": [
        {
            "timestamp": 1655263143,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Uploaded patch set 1."
        },
        {
            "timestamp": 1655270698,
            "reviewer": {
                "name": "Lei YU",
                "email": "mine260309@gmail.com",
                "username": "mine260309"
            },
            "message": "Patch Set 1:\n\n(2 comments)"
        },
        {
            "timestamp": 1655319523,
            "reviewer": {
                "name": "Adriana Kobylak",
                "email": "anoo@us.ibm.com",
                "username": "anoo1"
            },
            "message": "Patch Set 1:\n\n(2 comments)"
        },
        {
            "timestamp": 1655321380,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Patch Set 1:\n\n(4 comments)"
        },
        {
            "timestamp": 1657671073,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Topic set to design"
        },
        {
            "timestamp": 1657689507,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 1:\n\n(4 comments)"
        },
        {
            "timestamp": 1657689996,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 1:\n\n(6 comments)"
        },
        {
            "timestamp": 1657735014,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 1:\n\n(1 comment)"
        },
        {
            "timestamp": 1658402464,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Patch Set 1:\n\n(7 comments)"
        },
        {
            "timestamp": 1658601558,
            "reviewer": {
                "name": "Ed Tanous",
                "email": "ed@tanous.net",
                "username": "edtanous"
            },
            "message": "Patch Set 1:\n\n(7 comments)"
        },
        {
            "timestamp": 1662162690,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Uploaded patch set 2."
        },
        {
            "timestamp": 1662162807,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Ok-To-Test+1\n\nUser approved, CI ok to start"
        },
        {
            "timestamp": 1662162807,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: -Ok-To-Test"
        },
        {
            "timestamp": 1662162825,
            "reviewer": {
                "name": "OpenBMC CI",
                "email": "openbmcbump-ci@yahoo.com",
                "username": "jenkins-openbmc-ci"
            },
            "message": "Patch Set 2: Verified+1\n\nBuild Successful \n\nhttps://jenkins.openbmc.org/job/ci-repository/50329/ : SUCCESS"
        },
        {
            "timestamp": 1662162868,
            "reviewer": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "message": "Patch Set 1:\n\n(9 comments)"
        },
        {
            "timestamp": 1728583018,
            "reviewer": {
                "name": "Jayanth Othayoth",
                "email": "ojayanth@gmail.com",
                "username": "ojayanth"
            },
            "message": "Patch Set 2:\n\n(1 comment)"
        },
        {
            "timestamp": 1728651541,
            "reviewer": {
                "name": "Patrick Williams",
                "email": "patrick@stwcx.xyz",
                "username": "williamspatrick"
            },
            "message": "Abandoned\n\nnot moving forward"
        }
    ],
    "patchSets": [
        {
            "number": 1,
            "revision": "4cf8c2eaa3765bebe786595857271ec0198d78c2",
            "parents": [
                "bc8205063946cb6f2e357d22188c5dd6dfbcfd92"
            ],
            "ref": "refs/changes/89/54589/1",
            "uploader": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "createdOn": 1655263143,
            "author": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "https://gerrit.openbmc.org/c/openbmc/docs/+/51950/\nand\nhttps://gerrit.openbmc.org/c/openbmc/docs/+/37950\n\nSeem to be implementing similar things;  Can you please worth with those authors to generalize this design for everyones use cases?"
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Lots of docs on firmware update have surfaced in recent months.  Clearly this is a hot topic;  We should work as a community to get them merged into a single design that the maintainers can approve."
                },
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Realized that D-Bus can support long running methods, so removed GetFirmwareUpdateStatus and added additional errors to UpdateFirmware.\n\nI addressed some of the comments now, and will follow up with the rest."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 14,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Can you elaborate on this?  I don't understand how \"a process that holds a bunch of files that you might want to update\" has any complexity.  You need to figure out how to get files into the BMC in order to do your update, don't you?  We already have all the Redfish plumbing for that."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 14,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> Can you elaborate on this?  I don't understand how \"a process that holds a bunch of files that you might want to update\" has any complexity.\n\nThe current implementation of dbus interfaces is hard to implement (I can say that from experience, because I'm the person that implemented it for Redfish in bmcweb.)  It requires the use of the filesystem, and dbus in tandem with match expressions to do what is essentially an RPC operation (Update using this content), but now requires the client to track a lot of state.  It also causes bugs like: https://github.com/openbmc/bmcweb/issues/202\n\nBecause it requires clients to store the state of the transaction in progress. (yes, we could fix it so it doesn't seg fault, but short of writing the match information to persistent data before shutdown, there's no way to make the interface \"correct\").\n\n>  You need to figure out how to get files into the BMC in order to do your update, don't you?  We already have all the Redfish plumbing for that.\n\nThe Redfish plumbing is:\nA. Brittle (see aforementioned bug) and cannot support multiple components being updated in parallel.\nB. Hardcoded for specific use cases and slots.  It cannot be extended on dbus without Redfish patches for each individual use case.\nC. Only supports updating the BMC itself.  Moving the design to support BIOS, VR, and other firmware updates using the existing interfaces would be non-trivial.\nD. Different in design principals than how we handle basically anything else on dbus.  For all other things we enumerate the interfaces available, and when we have user data available, we do a method call to send the data to the daemon that we are interacting with.  These days we support fd, so we can still use a \"file\", it's just a lot easier if that transaction happens on dbus, because we have well-trodden ways to handle dbus method calls, and very few \"wait for thing to exist\" dbus use cases.\n\nThis is a case where having a second supported API for \"new stuff\" (while still keeping the old APIs for the existing) would be to our benefit, even though I dislike the duplication, the hope is that we can eventually get rid of the old API entirely (especially given there's only one implementer) but that requires time and effort (that I am personally willing to invest in, and I think others like justin are as well)."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 15,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "spelling?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 15,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 16,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "Please elaborate.  I don't know how \"here is your file pointer\" is a difficult part of the workflow."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 16,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "The sentance highlighted makes sense to me;  I don't think there's a \"here is your file pointer\" API today that can account for multiples of things?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 17,
                    "reviewer": {
                        "name": "Adriana Kobylak",
                        "email": "anoo@us.ibm.com",
                        "username": "anoo1"
                    },
                    "message": "Who is the vendor in this case that would have a hard time implementing the existing APIs?\nbmcweb already implements the Update Redfish API to be an update-and-activate in one call."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 17,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "There is no specific vendor, I am just speculating. Even with the bmcweb call, a vendor needs to develop against the full end-to-end flow with bmcweb, image manager and their item updater. What I'm saying here is that the vendor can easily develop and test their implementation without the full workflow. They should still test the whole workflow before sending for review, but this API could just make development easier."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 17,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> bmcweb already implements the Update Redfish API to be an update-and-activate in one call.\n\nAs the person that implemented the current API in bmcweb, it was very...very difficult for me given the complexities, and arguably breaks some of the design ideals in bmcweb to do it (requires storing state, ect), and causes bugs like:\nhttps://github.com/openbmc/bmcweb/issues/202\n\nThat basically can't be solved in a reasonable way because of having to store state that doesn't exist on dbus.\n\nAlso, it's more than one call, it's a call to the filesystem to write the payload, then it's a call to the dbus-broker to set up the match, then its a polling waiting for the update to get accepted, then it's polling to wait for the update to complete.  This design is attempting to simplify that.\n\n\nSome immediate possible users include:\nNvme, which supports updating over nvme-mi\nVRs, which have an i2c based update API\nPossible integration with fwupd, which already supports a ton of devices."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 17,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "These words of Ed's should probably be incorporated into the design as better justification."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 17,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "+1.  When this doc gets integrated with the other docs in progress, lets get the above added."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 45,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "This seems totally insufficient for doing updates.  A few shortfalls:\n\n1. How do you deal with firmware which is not applied yet (staged), like all ROTs seem to want to do?\n\n2. How do you deal with firmware which might be applied immediately, without a reboot?  (I think the current API expresses this as well).\n\n3. How do we identify which version of firmware is currently installed in a device?  What if the device has multiple storage locations?\n\n4. How do we identify device compatibility with the firmware image?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 45,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> This seems totally insufficient for doing updates.  A few shortfalls:\n> \n> 1. How do you deal with firmware which is not applied yet (staged), like all ROTs seem to want to do?\n\nMy immediate kneejerk reacion is \"UpdateFirmware\" is the stage command (maybe it needs renamed \"StageFirmware\".  Then we need a separate, optional interface for \"ApplyFirmware()\" that, for simple use cases, wouldn't exist, and staging would imply apply, or would imply \"applied on reset\" (maybe that needs another parameter to denote which?)\n\n> \n> 2. How do you deal with firmware which might be applied immediately, without a reboot?  (I think the current API expresses this as well).\n\nAnswered in the last question.\n\n> \n> 3. How do we identify which version of firmware is currently installed in a device?\n\nPresumably we have the existing version APIs for that.  DO they need to change at all?\n\n>  What if the device has multiple storage locations?\n\nIs there a use case for \"I as a user want to update a specific storage location\".  For AB update, generally I've seen that's an implementation detail hidden from the user for security reasons (you don't want the user to be able to \"pick\" to update the backup intended to protect them.\n\n> \n> 4. How do we identify device compatibility with the firmware image?\n\n+1.  This seems like something we need to answer."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 45,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "1/2. Added an ApplyFirmware method with a parameter to distinguish between applying immediately or on the next reset.\n\n3. Mentioned below that Version will still be used.\n\n4. Does that really need to be part of the API? I suppose if it's not, the user could accidentally update a device with a non-compatible image, but couldn't we leave those kinds of checks to the implementation?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 48,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "It looks like the ImagePath is the path on BMC that is the uploaded image is it?\nWhat is the difference between this new API and the existing `RequestedActivation`?\n\nI feel that they are doing pretty much the same thing?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 48,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Yes the path is local to the BMC.\nRequestedActivation requires the ItemUpdater to first know about an image through the Version object published by the ImageManager, and then creating that Activation object. This new API cuts out that extra step so a client can directly send an image to an ItemUpdater-like daemon."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 48,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "> This new API cuts out that extra step so a client can directly send an image to an ItemUpdater-like daemon.\n\nBut _which_ daemon is it going to send it to?  Is the implication that all software updates will now go through a single daemon?\n\nYou've taken what use to be decoupled (image manager gets the new image, various daemons monitor to determine if it is relevant for them) and turned it into a tightly coupled system where one daemon is responsible for routing all firmware updates.  This seems _worse_ for vendor compatibility, not better."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 48,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> > This new API cuts out that extra step so a client can directly send an image to an ItemUpdater-like daemon.\n> \n> But _which_ daemon is it going to send it to?\n\nThe daemon exposing the API.  The VR daemon would expose the API for VR devices, the NVMe daemon would expose the API for nvme devices, ect.\n\n>  Is the implication that all software updates will now go through a single daemon?\n\nI don't think so?  At least that's not my reading.\n\n> \n> You've taken what use to be decoupled (image manager gets the new image, various daemons monitor to determine if it is relevant for them) and turned it into a tightly coupled system where one daemon is responsible for routing all firmware updates.  This seems _worse_ for vendor compatibility, not better."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 48,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "No, the intent is not for a single daemon to do all firmware updates. Like Ed mentioned, there could be one daemon for each type of device."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 54,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Can we just avoid the filesystem altogether and pass an FD?  we've used it in other places successfully, it just wasn't well known when the first update APIs were built, and it avoids a lot of permissions issues that we've seen in the past with daemons sharing FDs.\n\nAlternatively, could we just make this array<uint8>?  Is there a dbus limit that we would hit?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 58,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "We shouldn't be passing a signature on the filesystem.  It's not intended to be large.\n\nAlso, we need to support:\n1. Devices with no crypto verification\n2. Devices for which the crypto signature is embedded in the payload.\n\nSo at a minimum, this needs to be optional, but I suspect in most cases we'd just embed it in the image itself.\n\n\nIn terms of documentation, because this is a common interface, we probably need a lot more details on what requirements on the signature are.  \"string\" isn't very descriptive about format or behavior."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 60,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Probably need an error type of \"Firmware Update already in progress\", \"signature failure\" and \"Device not in required state\" (probably power state)."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 60,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Done"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 62,
                    "reviewer": {
                        "name": "Lei YU",
                        "email": "mine260309@gmail.com",
                        "username": "mine260309"
                    },
                    "message": "How does this API tell which status is for which image?\nE.g. if user tries to update BMC and BIOS images, and calls UpdateFirmware twice, how does this API tell which image is in progress?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 62,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "There would be separate objects for each device. So if BIOS and BMC are managed by the same daemon, there should be 2 separate objects on that daemon."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 76,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Can we call this \"idle\" instead?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 76,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "I think this no longer applies after removing GetFirmwareUpdateStatus. Please re-open this comment if you have a concern."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 81,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "The task service APIs give a progress indicator thats 0-100.  We should probably at least make that possible."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 81,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Stated below in the doc, but the existing ActivationProgress can still be used to give a progress indicator"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 90,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "In each of these states, it adds some unknowns to the behavior.  How long is an update implementation required to stay in the \"done\" state before it goes back to None?  If VerifyError occurs, is it possible to go back to None?  Is it required to allow a reattempt?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 90,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "I think this no longer applies after removing GetFirmwareUpdateStatus. Please re-open this comment if you have a concern."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 104,
                    "reviewer": {
                        "name": "Adriana Kobylak",
                        "email": "anoo@us.ibm.com",
                        "username": "anoo1"
                    },
                    "message": "An alternative could be adding an option in the existing interfaces that when an image is uploaded it automatically sets the RequestedActivations property to start the activation."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 104,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Would that be an option passed through Redfish to bmcweb, so that bmcweb automatically sets the RequestedActivations property? I believe bmcweb already does this by default.\n\nA problem this new API is trying to solve is for firmware upgrades without Redfish, where some local process within the BMC is coordinating the firmware upgrade. In that case (and even in the case of Redfish SimpleUpdate) I don't see the use for the ImageManager, when the image can be passed directly to the ItemUpdater."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 104,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "> An alternative could be adding an option in the existing interfaces that when an image is uploaded it automatically sets the RequestedActivations property to start the activation.\n\nthe problem here is that it still requires an untrusted daemon (bmcweb) to be writing the filesystem, which requires some level of permissions.  That's one of the big things being avoided.\n\nWith that said, Adriana is right here, there should be something in the alternatives section, even if it's just \"keep the current API\""
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 109,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "If this is the plan, please plan on removing the ImageManager interface first, and having that be the first target before the bmcweb patches land.  This avoids having to support two implementations for a period of time, and needing to have complex logic to determine which implementation to use at any given time."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 109,
                    "reviewer": {
                        "name": "Patrick Williams",
                        "email": "patrick@stwcx.xyz",
                        "username": "williamspatrick"
                    },
                    "message": "This implies that for _all_ cases the ImageManager relationship is overkill.  Is this true?  We need to elaborate on that as well."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 109,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Yeah, I rethought this;  Clearly I was drunk on caffeine when I wrote the above comment, and I now disagree with myself.  As the maintainer of the primary application that I suspect this is targeting (ie Redfish) I'm ok with maintaining two implementations of this for a time, and they should be relatively separable given the current code stack.  That also gives us a chance to prove out the new interfaces meet the needs without blowing up the old (no need to burn the ships).  If we accomplish our goals, yes, I think the point would be to get rid of the ItemUpdater API."
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 115,
                    "reviewer": {
                        "name": "Ed Tanous",
                        "email": "ed@tanous.net",
                        "username": "edtanous"
                    },
                    "message": "Surely theres some testing?"
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "line": 115,
                    "reviewer": {
                        "name": "Justin Ledford",
                        "email": "justinledford@google.com",
                        "username": "justinledford"
                    },
                    "message": "Since this proposal is only concerned with defining the D-Bus interface I wouldn't think there is anything concrete to test?"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "type": "ADDED",
                    "insertions": 115,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 128,
            "sizeDeletions": 0
        },
        {
            "number": 2,
            "revision": "0c2863a5da1462191fbe64040f159c7e1e3c02e1",
            "parents": [
                "bc8205063946cb6f2e357d22188c5dd6dfbcfd92"
            ],
            "ref": "refs/changes/89/54589/2",
            "uploader": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "createdOn": 1662162690,
            "author": {
                "name": "Justin Ledford",
                "email": "justinledford@google.com",
                "username": "justinledford"
            },
            "kind": "REWORK",
            "comments": [
                {
                    "file": "/PATCHSET_LEVEL",
                    "line": 0,
                    "reviewer": {
                        "name": "Jayanth Othayoth",
                        "email": "ojayanth@gmail.com",
                        "username": "ojayanth"
                    },
                    "message": "No progress in review , removing from my list"
                }
            ],
            "files": [
                {
                    "file": "/COMMIT_MSG",
                    "type": "ADDED",
                    "insertions": 13,
                    "deletions": 0
                },
                {
                    "file": "designs/simple-firmware-update-api.md",
                    "type": "ADDED",
                    "insertions": 102,
                    "deletions": 0
                }
            ],
            "sizeInsertions": 115,
            "sizeDeletions": 0
        }
    ]
}